%YAML 1.2
---
name: Ecmascript
file_extensions: [ js, es, es6 ]
scope: source.js source.es

# es 20:15
# though I walk through the valley of the shadow
# of PHP, I will fear no feature creep, for Crockford and Eich...

# Captures with the ^BS suffix are included for interoperability with themes
# that target Babel Sublime or JS Next. This is not always possible to achieve
# since there are cases where one would always clobber the other. In some cases
# you will see "^BS, adapted" or "^BS, partial", indicating scopes which may not
# lead to 1:1 exact coloring between themes but will nonetheless appear
# harmonious. "-BS" indicates cases where it would not be good to include these
# fallback scopes for various reasons, though they won’t cause any real coloring
# problems; in fact some are improvments where we’ve disambiguated a previous
# conflation. Captures with no ‘BS’ annotations either correspond directly
# already to, or are more specific versions of, scopes from BS & JSNext.

variables:
  # CONTEXT CONTROL PATTERNS ###################################################
  MAT_word_or_any_one_char: '\w+|\S'
  PLA_anything: '(?=[\S\s])'

  # UNICODE PROPERTY CLASS SHIMS ###############################################
  ID_Continue: '{{ID_Start}}\p{Mn}\p{Mc}\p{Nd}\p{Pc}{{Other_ID_Continue}}'
  ID_Start: '\p{L}\p{Nl}{{Other_ID_Start}}'
  Other_ID_Continue: '··፩-፱᧚'
  Other_ID_Start: '℘℮゛゜'

  # OTHER CHARACTER GROUPS #####################################################
  boxchars: '[─-╿▀-▟]+'
  whiteNoLine: '[\s&&[^\n\r]]+'

  # KEYWORDS ###################################################################
  # The absence of ‘async’ in reserved is intentional (due to the Node library
  # by that name). Note ‘keywordOther’ includes what are technically identifiers
  # rather than keywords, but for practical purposes they may be considered to
  # belong to the latter group (they may not actually be redefined anymore).
  keywordLanguage: >-
    break | case | catch | class | const | continue | debugger | default |
    delete | do | else | export | extends | finally | for | function | if |
    import | in | instanceof | let | new | return | super | switch | this |
    throw | try | typeof | var | void | while | with | yield
  keywordReserved: >-
    await | enum | implements | interface |
    package | private | protected | public
  keywordLiteral: >-
    false | null | true
  keywordOther: >-
    Infinity | NaN | undefined
  reservedWords: >-
    {{keywordLanguage}}|
    {{keywordReserved}}|
    {{keywordLiteral}}|
    {{keywordOther}}

  # IDENTIFIERS ################################################################
  identifier: >-
    (?x)
      (?! (?:{{reservedWords}})
      [^\$_‍‍{{ID_Continue}}] )
      (?<![{{ID_Continue}}])
      {{identifierName}}
  identifierInitCap: '(?:\p{Lu}{{identifierPart}}){{idEnd}}'
  identifierInitCapStrict: >-
    (?x)
      (?! (?:{{reservedWords}})
      [^\$_‍‍{{ID_Continue}}] )
      (?<![{{ID_Continue}}])
      {{identifierInitCap}}
  identifierAllCaps: '(?:[\p{Lu}\d_]{2,}|\p{Lu}){{idEnd}}'
  identifierAllCapsStrict: >-
    (?x)
      (?! (?:{{reservedWords}})
      [^\$_‍‍{{ID_Continue}}] )
      (?<![{{ID_Continue}}])
      {{identifierAllCaps}}
  identifierName: '{{identifierStart}}{{identifierPart}}'
  identifierPart: '(?:[\$_‍‍{{ID_Continue}}]|{{unicodeEscape}})*' # ZWN?J after _
  identifierStart: '(?:[\$_{{ID_Start}}]|{{unicodeEscape}})'
  allThreeIDs: '({{identifierAllCaps}})|({{identifierInitCap}})|({{identifier}})'
  unicodeEscape: '\\u(?:\h{4}|\{\h+\})'
  jsxIdentifer: '{{identifierName}}(?:-(?:{{identifierPart}})*)*'

  # WELL-KNOWN IDENTIFIERS #####################################################
  # Note, Symbol is not a real constructor -- but even ECMA 262 calls it one.
  intrinsicConstructors: >-
    Array(?:Buffer)? | Atomics | Boolean | Date | DataView |
    (?:Eval|Range|Reference|Syntax|Type|URI)?Error |
    Float(?:32|64)Array | Function | Int(?:8|16|32)Array |
    Number | Object | Promise | Proxy | Reflect | RegExp | SharedArrayBuffer |
    String | Symbol | Uint(?:8(?:Clamped)?|16|32)Array | (?:Weak)?(?:Map|Set)
  intrinsicFunctions: >-
    (?:de|en)codeURI(?:Component)? |
    eval | is(?:Finite|Nan) | parse(?:Float|Int) |
    (?:set|clear)(?:Timeout|Interval|Immediate)

  # NUMERIC LITERALS ###########################################################

  binNum: '(0[Bb])([01]+)'
  octNum: '(0[Oo])([0-7]+)'

  # Decimal has 6 captures: dec, dec, dec, exp-e, exp-sign, exp-dig
  decNum: >-
    (?x)
      (?:
        0 (?: (\.) \d* )? |
        [1-9]\d* (?: (\.) \d* )? |
        (\.) \d*
      )
      (?: ([Ee]) ([\+\-])? (\d+) )?
      {{idEnd}}

  hexNum: '(0[Xx])(\h+)'

  # LOOKAHEADS #################################################################
  idEnd: '(?=[^\$_‍‍{{ID_Continue}}]|$)'

contexts:

# MAIN, META & PROTOTYPE #######################################################

  main:
    - meta_include_prototype: false
    # SHEBANG
    - match: '^(\#\!)(.*)'
      scope: comment.line.shebang.es
      captures:
        1: punctuation.definition.comment.begin.es
        2: meta.comment.body.es
      set: root
    - match: '{{PLA_anything}}'
      set: root

  root:
    - include: useStrict
    # IMPORT DECLARATION
    - match: '((import)){{idEnd}}(?!\s*[\(\.])'
      captures:
        1: storage.type.module.import.es
        2: keyword.operator.module.js # ^BS
      push: moduleDeclaration_AFTER_IMPORT
    # EXPORT DECLARATION
    - match: '((export)){{idEnd}}'
      captures:
        1: storage.type.module.export.es
        2: keyword.operator.module.js # ^BS
      push: moduleDeclaration_AFTER_EXPORT
    # STATEMENT LIST
    - include: statements

  prototype:
    # Captured for practical reasons (keeps other patterns simpler)
    - match: '\s+'
      scope: meta.whitespace.es
    # MERGE CONFLICTS
    - match: '<<<<<<< (.+)\n'
      scope: 'invalid.merge-conflict.delimiter.our-changes'
      push: merge_conflict_our_changes
    # COMMENTS
    - match: '((\/\/))'
      captures:
        1: meta.comment.border.es
        2: punctuation.definition.comment.begin.es
      push:
        - meta_scope: comment.line.es
        - match: '\n'
          pop: true
        - match: '\/\/+'
          scope: meta.comment.border.es
        - match: '{{boxchars}}'
          scope: meta.comment.box-drawing.es
        - match: '\b(?i:todo|hack)\b'
          scope: comment.line.todo.es
    - match: '((\/\*))'
      captures:
        1: meta.comment.border.es
        2: punctuation.definition.comment.begin.es
      push:
        - meta_scope: comment.block.es
        - match: '((?:\*+)?(\*\/))'
          captures:
            1: meta.comment.border.es
            2: punctuation.definition.comment.end.es
          pop: true
        - match: '(^\/)?((?!\*\/)\*)+'
          scope: meta.comment.border.es
        - match: '{{boxchars}}'
          scope: meta.comment.box-drawing.es
        - match: '\b(?i:todo|hack)\b'
          scope: comment.line.todo.es

  merge_conflict_our_changes:
    - meta_scope: invalid.merge-conflict.our-changes
    - match: '=======\n'
      scope: 'invalid.merge-conflict.delimiter.separator'
      set: merge_conflict_their_changes

  merge_conflict_their_changes:
    - meta_scope: invalid.merge-conflict.their-changes
    - match: '>>>>>>> (.+)\n'
      scope: 'invalid.merge-conflict.delimiter.their-changes'
      pop: true

  # If no match has been made, gently and quietly pop
  else_pop:
    - match: '{{PLA_anything}}'
      pop: true

  # Associated with a handful of "no-line-terminator-here" statements.
  optional_semicolon_pop:
    - match: '$'
      pop: true
    - match: ';'
      scope: punctuation.terminator.statement.es
      pop: true
    - include: else_pop

  # Similar to above but used when a single statement in an if or do may have
  # been an expression statement.
  semicolon_maybe:
    - match: ';'
      scope: punctuation.terminator.statement.es
      pop: true
    - include: else_pop

  # Brand the evil token, but stand your ground.
  other_illegal:
    - match: '{{MAT_word_or_any_one_char}}'
      scope: invalid.illegal.token.es

  # Reject it and run.
  other_illegal_pop:
    - match: '{{MAT_word_or_any_one_char}}'
      scope: invalid.illegal.token.es
      pop: true

# STATEMENTS ###################################################################

  statements:
    # THE NOBLE EMPTY STATEMENT
    - match: ';'
      scope: punctuation.terminator.statement.es
    # Or,
    - match: '{{PLA_anything}}'
      push: statement # note push

  statement:
    # BLOCK STATEMENT
    - match: '((\{))'
      captures:
        1: punctuation.definition.block.begin.es
        2: meta.brace.curly.js # ^BS
      set: blockStatement
    # IF STATEMENT
    - match: 'if{{idEnd}}'
      scope: keyword.control.conditional.if.es
      set: ifStatement_AFTER_IF
    # DO STATEMENT
    - match: 'do{{idEnd}}'
      scope: keyword.control.loop.do.es
      set: doStatement_AFTER_DO
    # LET DECLARATION
    - match: 'let{{idEnd}}'
      scope: storage.type.variable.let.es
      set: constLetVarDeclaration_AFTER_WORD
    # VAR DECLARATION
    - match: 'var{{idEnd}}'
      scope: storage.type.variable.var.es
      set: constLetVarDeclaration_AFTER_WORD
    # FOR STATEMENT
    - match: 'for{{idEnd}}'
      scope: keyword.control.loop.for.es
      set: forStatement_AFTER_FOR
    # TRY STATEMENT
    - match: 'try{{idEnd}}'
      scope: keyword.control.trycatch.try.es
      set: tryStatement_AFTER_TRY
    # WITH STATEMENT
    - match: 'with{{idEnd}}'
      scope: keyword.control.with.es # -BS
      set: withStatement_AFTER_WITH
    # CONST DECLARATION
    - match: 'const{{idEnd}}'
      scope: storage.type.constant.es
      set: constLetVarDeclaration_AFTER_WORD
    # CLASS DECLARATION
    - match: 'class{{idEnd}}'
      scope: storage.type.class.es
      set: classDeclaration_AFTER_CLASS
    # WHILE STATEMENT
    - match: 'while{{idEnd}}'
      scope: keyword.control.loop.while.es
      set: whileStatement_AFTER_WHILE
    # THROW STATEMENT
    - match: 'throw{{idEnd}}'
      scope: keyword.control.flow.throw.es # -BS
      set: throwStatement
    # BREAK STATEMENT
    - match: 'break{{idEnd}}'
      scope: keyword.control.flow.break.es # -BS
      set: breakOrContinue_AFTER_WORD
    # RETURN STATEMENT
    - match: 'return{{idEnd}}'
      scope: keyword.control.flow.return.es
      set: returnStatement
    # SWITCH STATEMENT
    - match: 'switch{{idEnd}}'
      scope: keyword.control.switch.es
      set: switchStatement_AFTER_SWITCH
    # * GENERATOR DECLARATION
    - match: '((function))\s*((\*))'
      captures:
        1: storage.type.function.js # ^BS -- Cobalt
        2: storage.type.function.generator.es
        3: keyword.generator.asterisk.js # ^BS
        4: storage.modifier.generator.asterisk.es
      set: generatorDeclaration_AFTER_ASTERISK
    # FUNCTION DECLARATION
    - match: '((function)){{idEnd}}(?!\s*\.)'
      captures:
        1: storage.type.function.js # ^BS -- Cobalt
        2: storage.type.function.es
      set: functionDeclaration_AFTER_FUNCTION
    # ASYNC DECLARATION
    - match: '(async)\s*((function)){{idEnd}}'
      captures:
        1: storage.modifier.async.es # -BS
        2: storage.type.function.js # ^BS -- Cobalt
        3: storage.type.function.async.es
      set: asyncDeclaration_AFTER_FUNCTION
    # CONTINUE STATEMENT
    - match: 'continue{{idEnd}}'
      scope: keyword.control.flow.continue.es # -BS
      set: breakOrContinue_AFTER_WORD
    # DEBUGGER STATEMENT
    - match: 'debugger{{idEnd}}'
      scope: keyword.other.debugger.es
      set: optional_semicolon_pop
    # * LABELLED STATEMENT (note: does not pop or transition)
    - match: '(({{identifier}})\s*(:(?!:)))'
      captures:
        1: constant.other.object.key.js string.unquoted.label.js # ^BS, adapted
        2: entity.name.statement.es
        3: punctuation.separator.label-statement.es # -BS
    # DECORATED CLASS DECLARATION
    - match: '((@))'
      captures:
        1: punctuation.definition.tag.js # ^BS
        2: punctuation.definition.decorator.es
      set: [ classDeclaration_AFTER_DECORATOR, decoratorExpression ]
    # EMPTY STATEMENT
    - match: ';'
      scope: punctuation.terminator.statement.es
    # EXPRESSION STATEMENT
    # Though expression statements are a subset of possible expressions, the
    # disallowed cases are all captured by previous matches.
    - include: expression

  blockStatement:
    - match: '((\}))'
      captures:
        1: punctuation.definition.block.end.es
        2: meta.brace.curly.js # ^BS
      pop: true
    - include: statements

  breakOrContinue_AFTER_WORD:
    - match: '$'
      pop: true
    - match: ';'
      scope: punctuation.terminator.statement.es
      pop: true
    - match: '(({{identifier}}))'
      captures:
        1: constant.other.object.key.js string.unquoted.label.js # ^BS, adapted
        2: entity.name.statement.es
      set: optional_semicolon_pop
    - include: else_pop

  doStatement_AFTER_DO:
    - match: '((\{))'
      captures:
        1: punctuation.definition.block.loop.begin.es
        2: meta.brace.curly.js # ^BS
      set: doStatement_STMT_AFTER_BRACE
    - match: '{{PLA_anything}}'
      set: [ doStatement_AFTER_STMT, semicolon_maybe, statement ]

  doStatement_STMT_AFTER_BRACE:
    - match: '((\}))'
      captures:
        1: punctuation.definition.block.loop.end.es
        2: meta.brace.curly.js # ^BS
      set: doStatement_AFTER_STMT
    - include: statements

  doStatement_AFTER_STMT:
    - match: 'while{{idEnd}}'
      scope: keyword.control.loop.while.es
      set: doStatement_AFTER_WHILE
    - include: else_pop

  doStatement_AFTER_WHILE:
    - match: '((\())'
      captures:
        1: punctuation.definition.expression.loop.begin.es
        2: meta.brace.round.js # ^BS
      set: [ doStatement_AFTER_EXP, expression ]
    - include: other_illegal_pop

  doStatement_AFTER_EXP:
    - match: '((\)))'
      captures:
        1: punctuation.definition.expression.loop.end.es
        2: meta.brace.round.js # ^BS
      pop: true
    - include: other_illegal

  forStatement_AFTER_FOR:
    - match: '((\())'
      captures:
        1: punctuation.definition.expression.loop.begin.es
        2: meta.brace.round.js # ^BS
      set: forStatement_AFTER_PAREN_OPEN
    - match: 'await{{idEnd}}'
      scope: keyword.control.flow.await
      set:
        - match: '((\())'
          captures:
            1: punctuation.definition.expression.loop.begin.es
            2: meta.brace.round.js # ^BS
          set: forStatement_AFTER_PAREN_OPEN
        - include: other_illegal_pop
    - match: '(each){{idEnd}}'
      scope: keyword.control.flow.loop.es
      captures:
        1: invalid.deprecated.es
      set: forStatement_AFTER_EACH
    - include: other_illegal_pop

  forStatement_AFTER_EACH:
    - match: '((\())'
      captures:
        1: punctuation.definition.expression.loop.begin.es
        2: meta.brace.round.js # ^BS
      set: forStatement_AFTER_PAREN_OPEN
    - include: other_illegal_pop

  forStatement_AFTER_PAREN_OPEN:
    # This is an exceedingly tricky area. Consistently differentiating between
    # the three types of ‘for’ statements isn’t only impossible due to the need
    # for lookaheads that may cross lines -- it’s complicated by the fact that
    # any of the tokens we might wish to seek are themselves valid in every
    # other possible pattern if contextualized correctly. While not so terrible
    # generally if it meant only that we were more permissive of malformed
    # syntax, the problem mainly concerns difficulty with distinguishing the
    # homonym ‘in’ (operator vs control keyword).
    #
    # Our best bet, as far as I can tell, is to use the existence of a non-
    # terminal semi-colon as a heuristic indicator that this is a ‘legacy’ for
    # loop. This can be refined further by saying it doesn’t count if ‘in’
    # appeared before the first semicolon, since for-;; loops disallow this
    # expressly.

    # The expression (series) ends abruptly.
    - match: '\)'
      scope: invalid.illegal.token.es
      set: whileOrForStatement_STMT
    # The line contains a non-terminal semicolon, but not after 'in'.
    - match: '(?=(?![^;]+\bin\b).*;.)'
      set: forStatement_EXP_LEGACY_INIT
    # At this point we believe we are in a for-in or for-of loop. Though the
    # circumstances that would lead to this being false would be unusual in
    # practice, we now stand a tiny chance of breaking highlighting. To make it
    # work, we need a whole duplicative version of the expression ‘tree’ that
    # exists only to disallow the ‘in’ operator.
    - match: 'var{{idEnd}}'
      scope: storage.type.variable.var.es
      set: forStatement_IN_OR_OF_DECLARATION_AFTER_WORD
    - match: 'let{{idEnd}}'
      scope: storage.type.variable.let.es
      set: forStatement_IN_OR_OF_DECLARATION_AFTER_WORD
    - match: 'const{{idEnd}}'
      scope: storage.type.constant.es
      set: forStatement_IN_OR_OF_DECLARATION_AFTER_WORD
    - match: '{{PLA_anything}}'
      set: [ forStatement_IN_OR_OF_AFTER_BINDING, assignmentExpression_NO_IN ] # (lhse)

  forStatement_EXP_LEGACY_INIT:
    - match: ';'
      scope: punctuation.separator.loop-expression.es # -BS
      set: forStatement_EXP_LEGACY_COND
    - match: '\)'
      scope: invalid.illegal.token.es
      set: whileOrForStatement_STMT
    - match: 'var{{idEnd}}'
      scope: storage.type.variable.var.es
      set: [ forStatement_EXP_LEGACY_INIT_AFTER_EXP, constLetVarDeclaration_AFTER_WORD ]
    - match: 'let{{idEnd}}'
      scope: storage.type.variable.let.es
      set: [ forStatement_EXP_LEGACY_INIT_AFTER_EXP, constLetVarDeclaration_AFTER_WORD ]
    - match: 'const{{idEnd}}'
      scope: storage.type.constant.es
      set: [ forStatement_EXP_LEGACY_INIT_AFTER_EXP, constLetVarDeclaration_AFTER_WORD ]
    - match: '{{PLA_anything}}'
      set: [ forStatement_EXP_LEGACY_INIT_AFTER_EXP, expression ]

  forStatement_EXP_LEGACY_INIT_AFTER_EXP:
    - match: ';'
      scope: punctuation.separator.loop-expression.es # -BS
      set: forStatement_EXP_LEGACY_COND
    - match: '\)'
      scope: invalid.illegal.token.es
      set: whileOrForStatement_STMT
    - include: other_illegal

  forStatement_EXP_LEGACY_COND:
    - match: ';'
      scope: punctuation.separator.loop-expression.es # -BS
      set: forStatement_EXP_LEGACY_AFTERTHOUGHT
    - match: '\)'
      scope: invalid.illegal.token.es
      set: whileOrForStatement_STMT
    - match: '{{PLA_anything}}'
      set: [ forStatement_EXP_LEGACY_COND_AFTER_EXP, expression ]

  forStatement_EXP_LEGACY_COND_AFTER_EXP:
    - match: ';'
      scope: punctuation.separator.loop-expression.es # -BS
      set: forStatement_EXP_LEGACY_AFTERTHOUGHT
    - match: '\)'
      scope: invalid.illegal.token.es
      set: whileOrForStatement_STMT
    - include: other_illegal

  forStatement_EXP_LEGACY_AFTERTHOUGHT:
    - match: '((\)))'
      captures:
        1: punctuation.definition.expression.loop.end.es
        2: meta.brace.round.js # ^BS
      set: whileOrForStatement_STMT
    - match: '{{PLA_anything}}'
      set: [ forStatement_AFTER_FINAL_EXP, expression ]

  forStatement_IN_OR_OF_DECLARATION_AFTER_WORD:
    - match: '((\[))'
      captures:
        1: punctuation.definition.binding.array.begin.es
        2: meta.brace.square.js # ^BS
      set: [ forStatement_IN_OR_OF_AFTER_BINDING, bindingArray ]
    - match: '((\{))'
      captures:
        1: punctuation.definition.binding.object.begin.es
        2: meta.brace.curly.js # ^BS
      set: [ forStatement_IN_OR_OF_AFTER_BINDING, bindingObject ]
    - match: '{{identifier}}'
      scope: variable.other.readwrite.es
      set: forStatement_IN_OR_OF_AFTER_BINDING
    - include: other_illegal

  forStatement_IN_OR_OF_AFTER_BINDING:
    - match: 'of{{idEnd}}'
      scope: keyword.control.loop.of.es # -BS
      set: [ forStatement_AFTER_FINAL_EXP, assignmentExpression ]
    - match: 'in{{idEnd}}'
      scope: keyword.control.loop.in.es # -BS
      set: [ forStatement_AFTER_FINAL_EXP, expression ]
    - match: ','
      scope: invalid.illegal
    # Perhaps we were really in a for-;; loop that did not have its first
    # semicolon on the initial line... we can recover in some cases.
    - match: ';'
      scope: punctuation.separator.loop-expression.es # -BS
      set: forStatement_EXP_LEGACY_COND
    - include: other_illegal

  forStatement_AFTER_FINAL_EXP:
    - match: '((\)))'
      captures:
        1: punctuation.definition.expression.loop.end.es
        2: meta.brace.round.js # ^BS
      set: whileOrForStatement_STMT
    - include: other_illegal

  ifStatement_AFTER_IF:
    - match: '((\())'
      captures:
        1: punctuation.definition.expression.conditional.begin.es
        2: meta.brace.round.js # ^BS
      set: [ ifStatement_AFTER_EXP, expression ]
    - include: other_illegal_pop

  ifStatement_AFTER_EXP:
    - match: '((\)))'
      captures:
        1: punctuation.definition.expression.conditional.end.es
        2: meta.brace.round.js # ^BS
      set: ifStatement_STMT
    - include: other_illegal

  ifStatement_STMT:
    - match: '((\{))'
      captures:
        1: punctuation.definition.block.conditional.begin.es
        2: meta.brace.curly.js # ^BS
      set: ifStatement_STMT_AFTER_BRACE
    - match: '{{PLA_anything}}'
      set: [ ifStatement_AFTER_STMT, semicolon_maybe, statement ]

  ifStatement_STMT_AFTER_BRACE:
    - match: '((\}))'
      captures:
        1: punctuation.definition.block.conditional.end.es
        2: meta.brace.curly.js # ^BS
      set: ifStatement_AFTER_STMT
    - include: statements

  ifStatement_AFTER_STMT:
    - match: 'else{{idEnd}}'
      scope: keyword.control.conditional.else.es
      set: statement
    - include: else_pop

  returnStatement:
    - match: '$'
      pop: true
    - match: ';'
      scope: punctuation.terminator.statement.es
      pop: true
    - match: '{{PLA_anything}}'
      set: [ optional_semicolon_pop, expression ]

  switchStatement_AFTER_SWITCH:
    - match: '((\())'
      captures:
        1: punctuation.definition.expression.switch.begin.es
        2: meta.brace.round.js # ^BS
      set: [ switchStatement_AFTER_EXP, expression ]
    - include: other_illegal_pop

  switchStatement_AFTER_EXP:
    - match: '((\)))'
      captures:
        1: punctuation.definition.expression.switch.end.es
        2: meta.brace.round.js # ^BS
      set: switchStatement_BEFORE_BRACE
    - include: other_illegal

  switchStatement_BEFORE_BRACE:
    - match: '((\{))'
      captures:
        1: punctuation.definition.block.switch.begin.es
        2: meta.brace.curly.js # ^BS
      set: switchStatement_AFTER_BRACE
    - include: other_illegal_pop

  switchStatement_AFTER_BRACE:
    - match: '((\}))'
      captures:
        1: punctuation.definition.block.switch.end.es
        2: meta.brace.curly.js # ^BS
      pop: true
    - match: 'case{{idEnd}}'
      scope: keyword.control.switch.case.es
      set: [ switchStatement_CASE_AFTER_EXP, expression ]
    - match: 'default{{idEnd}}'
      scope: keyword.control.switch.case.default.es
      set: switchStatement_CASE_AFTER_EXP
    - include: other_illegal

  switchStatement_CASE_AFTER_EXP:
    - match: ':'
      scope: punctuation.separator.case-statements.es # -BS
      set: switchStatement_CASE_STMT
    - match: '((\}))'
      captures:
        1: invalid.illegal.token.es
        2: meta.brace.curly.js # ^BS
      pop: true
    - match: '{{MAT_word_or_any_one_char}}'
      scope: invalid.illegal.token.es
      set: switchStatement_AFTER_BRACE

  switchStatement_CASE_STMT:
    - match: '((\}))'
      captures:
        1: punctuation.definition.block.switch.end.es
        2: meta.brace.curly.js # ^BS
      pop: true
    - match: 'case{{idEnd}}'
      scope: keyword.control.switch.case.es
      set: [ switchStatement_CASE_AFTER_EXP, expression ]
    - match: 'default{{idEnd}}'
      scope: keyword.control.switch.case.default.es
      set: switchStatement_CASE_AFTER_EXP
    - include: statements

  throwStatement:
    - match: '$'
      pop: true
    - match: '{{PLA_anything}}'
      set: [ optional_semicolon_pop, expression ]

  tryStatement_AFTER_TRY:
    - match: '((\{))'
      captures:
        1: punctuation.definition.block.trycatch.begin.es
        2: meta.brace.curly.js # ^BS
      set: tryStatement_AFTER_TRY_BRACE
    - include: other_illegal_pop

  tryStatement_AFTER_TRY_BRACE:
    - match: '((\}))'
      captures:
        1: punctuation.definition.block.trycatch.end.es
        2: meta.brace.curly.js # ^BS
      set: tryStatement_AFTER_TRY_BLOCK
    - include: statements

  tryStatement_AFTER_TRY_BLOCK:
    - match: 'catch{{idEnd}}'
      scope: keyword.control.trycatch.catch.es
      set: tryStatement_AFTER_CATCH
    - match: 'finally{{idEnd}}'
      scope: keyword.control.trycatch.finally.es
      set: tryStatement_AFTER_FINALLY
    - include: other_illegal_pop

  tryStatement_AFTER_CATCH:
    - match: '((\())'
      captures:
        1: punctuation.definition.parameters.catch.begin.es
        2: meta.brace.round.js # ^BS
      set: tryStatement_CATCH_PARAM
    - match: '((\{))'
      captures:
        1: punctuation.definition.block.trycatch.begin.es
        2: meta.brace.curly.js # ^BS
      set: tryStatement_AFTER_CATCH_BRACE
    - include: other_illegal_pop

  tryStatement_CATCH_PARAM:
    - match: '{{identifier}}'
      scope: variable.parameter.catch.es # -BS
      set: tryStatement_AFTER_CATCH_PARAM
    - match: '((\[))'
      captures:
        1: punctuation.definition.binding.array.parameter.begin.es
        2: meta.brace.square.js # ^BS
      set: [ tryStatement_AFTER_CATCH_PARAM, bindingArray_PARAM ]
    - match: '((\{))'
      captures:
        1: punctuation.definition.binding.object.parameter.begin.es
        2: meta.brace.curly.js # ^BS
      set: [ tryStatement_AFTER_CATCH_PARAM, bindingObject_PARAM ]
    - match: '\)'
      scope: invalid.illegal.token.es
      set: tryStatement_AFTER_CATCH_PARAM

  tryStatement_AFTER_CATCH_PARAM:
    - match: '((\)))'
      captures:
        1: punctuation.definition.parameters.catch.end.es
        2: meta.brace.round.js # ^BS
      set: tryStatement_BEFORE_CATCH_BRACE
    - include: other_illegal

  tryStatement_BEFORE_CATCH_BRACE:
    - match: '((\{))'
      captures:
        1: punctuation.definition.block.trycatch.begin.es
        2: meta.brace.curly.js # ^BS
      set: tryStatement_AFTER_CATCH_BRACE
    - include: other_illegal_pop

  tryStatement_AFTER_CATCH_BRACE:
    - match: '((\}))'
      captures:
        1: punctuation.definition.block.trycatch.end.es
        2: meta.brace.curly.js # ^BS
      set: tryStatement_AFTER_CATCH_BLOCK
    - include: statements

  tryStatement_AFTER_CATCH_BLOCK:
    - match: 'finally{{idEnd}}'
      scope: keyword.control.trycatch.finally.es
      set: tryStatement_AFTER_FINALLY
    - include: else_pop

  tryStatement_AFTER_FINALLY:
    - match: '((\{))'
      captures:
        1: punctuation.definition.block.trycatch.begin.es
        2: meta.brace.curly.js # ^BS
      set: tryStatement_AFTER_FINALLY_BRACE
    - include: other_illegal_pop

  tryStatement_AFTER_FINALLY_BRACE:
    - match: '((\}))'
      captures:
        1: punctuation.definition.block.trycatch.end.es
        2: meta.brace.curly.js # ^BS
      pop: true
    - include: statements

  whileStatement_AFTER_WHILE:
    - match: '((\())'
      captures:
        1: punctuation.definition.expression.loop.begin.es
        2: meta.brace.round.js # ^BS
      set: [ whileStatement_AFTER_EXP, expression ]
    - include: other_illegal_pop

  whileStatement_AFTER_EXP:
    - match: '((\)))'
      captures:
        1: punctuation.definition.expression.loop.end.es
        2: meta.brace.round.js # ^BS
      set: whileOrForStatement_STMT
    - include: other_illegal

  whileOrForStatement_STMT:
    - match: '((\{))'
      captures:
        1: punctuation.definition.block.loop.begin.es
        2: meta.brace.curly.js # ^BS
      set: whileOrForStatement_STMT_AFTER_BRACE
    - match: '{{PLA_anything}}'
      set: statement

  whileOrForStatement_STMT_AFTER_BRACE:
    - match: '((\}))'
      captures:
        1: punctuation.definition.block.loop.end.es
        2: meta.brace.curly.js # ^BS
      pop: true
    - include: statements

  withStatement_AFTER_WITH:
    - match: '((\())'
      captures:
        1: punctuation.definition.expression.with.begin.es
        2: meta.brace.round.js # ^BS
      set: [ withStatement_AFTER_EXP, expression ]
    - include: other_illegal_pop

  withStatement_AFTER_EXP:
    - match: '((\)))'
      captures:
        1: punctuation.definition.expression.with.end.es
        2: meta.brace.round.js # ^BS
      set: withStatement_STMT
    - include: other_illegal

  withStatement_STMT:
    - match: '((\{))'
      captures:
        1: punctuation.definition.block.with.begin.es
        2: meta.brace.curly.js # ^BS
      set: withStatement_STMT_AFTER_BRACE
    - match: '{{PLA_anything}}'
      set: statement

  withStatement_STMT_AFTER_BRACE:
    - match: '((\}))'
      captures:
        1: punctuation.definition.block.with.end.es
        2: meta.brace.curly.js # ^BS
      pop: true
    - include: statements

# DECLARATIONS #################################################################

  classDeclaration_AFTER_CLASS:
    - match: '(({{identifier}}))'
      captures:
        1: entity.name.class.js # ^BS -- Monokai
        2: entity.name.class.es
      set: classDeclaration_AFTER_NAME
    - include: other_illegal_pop

  classDeclaration_AFTER_NAME:
    - match: '((\{))'
      captures:
        1: punctuation.definition.class.body.begin.es
        2: meta.brace.curly.js # ^BS
      set: classDeclaration_AFTER_BRACE
    - match: '((extends)){{idEnd}}'
      captures:
        1: storage.type.extends.js # ^BS
        2: storage.modifier.extends.es
      set: [ classDeclaration_AFTER_HERITAGE, assignmentExpression ] # (lhse)
    - include: other_illegal_pop

  classDeclaration_AFTER_HERITAGE:
    - meta_scope: meta.super-expression.es
    - match: '((\{))'
      captures:
        1: punctuation.definition.class.body.begin.es
        2: meta.brace.curly.js # ^BS
      set: classDeclaration_AFTER_BRACE
    - include: other_illegal_pop

  classDeclaration_AFTER_BRACE:
    - match: '((\}))'
      captures:
        1: punctuation.definition.class.body.end.es
        2: meta.brace.curly.js # ^BS
      pop: true
    # Semicolons in the class body are legal.
    - match: ';'
      scope: punctuation.terminator.statement.es
    # Proposed ‘class fields’:
    - match: '((static))\s+({{identifierName}})\s*(=)'
      captures:
        1: storage.modifier.static.es
        2: storage.type.js # ^BS
        3: variable.other.readwrite.property.class.es
        4: punctuation.separator.key-value.es
      push:
        - - match: ';'
            scope: punctuation.terminator.property.es
            pop: true
          - match: '{{PLA_anything}}'
            set: assignmentExpression
    - match: '((static)){{idEnd}}'
      captures:
        1: storage.modifier.static.es
        2: storage.type.js # ^BS
      set: classDeclaration_METHOD_COMMON
    - match: '((constructor)){{idEnd}}'
      captures:
        1: entity.name.method.js # ^BS
        2: entity.name.constructor.es
      push: constructorMethod_AFTER_CONSTRUCTOR
    - match: '((@))'
      captures:
        1: punctuation.definition.tag.js # ^BS
        2: punctuation.definition.decorator.es
      push: decoratorExpression
    # Proposed ‘class fields’:
    - match: '({{identifierName}})\s*(=)'
      captures:
        1: variable.other.readwrite.property.class.es
        2: punctuation.separator.key-value.es
      push:
        - - match: ';'
            scope: punctuation.terminator.property.es
            pop: true
          - match: '{{PLA_anything}}'
            set: assignmentExpression
    - include: classDeclaration_METHOD_COMMON

  classDeclaration_METHOD_COMMON:
    - match: '((\*))'
      captures:
        1: keyword.generator.asterisk.js # ^BS
        2: storage.modifier.generator.asterisk.method.es
      set: [ classDeclaration_AFTER_BRACE, generatorMethod_AFTER_ASTERISK ]
    - match: '((get))(?!\s*\(){{idEnd}}'
      captures:
        1: storage.type.accessor.js # ^BS
        2: storage.modifier.accessor.get.es
      set: [ classDeclaration_AFTER_BRACE, accessorMethod_AFTER_GET ]
    - match: '((set))(?!\s*\(){{idEnd}}'
      captures:
        1: storage.type.accessor.js # ^BS
        2: storage.modifier.accessor.set.es
      set: [ classDeclaration_AFTER_BRACE, accessorMethod_AFTER_SET ]
    - match: '((async)){{idEnd}}((\s*\*))?'
      captures:
        1: storage.type.js # ^BS
        2: storage.modifier.async.method.es
        3: keyword.generator.asterisk.js # ^BS
        4: storage.modifier.generator.asterisk.method.es
      set: [ classDeclaration_AFTER_BRACE, asyncMethod_AFTER_ASYNC ]
    - match: '(({{identifierName}}))'
      captures:
        1: entity.name.method.js # ^BS -- monokai
        2: entity.name.method.es
      set: [ classDeclaration_AFTER_BRACE, method_AFTER_NAME ]
    - match: "'"
      scope: punctuation.definition.string.quoted.single.begin.es
      set: [ classDeclaration_AFTER_BRACE, method_AFTER_NAME, stringSingle_AFTER_OPEN ]
    - match: '"'
      scope: punctuation.definition.string.quoted.double.begin.es
      set: [ classDeclaration_AFTER_BRACE, method_AFTER_NAME, stringDouble_AFTER_OPEN ]
    # None of the remainder are handled correctly in BS or JSN, so they are all
    # technically "-BS" cases
    - match: '({{decNum}})'
      scope: constant.numeric.decimal.es
      captures:
        1: entity.name.method.es
        2: punctuation.decimal.es
        3: punctuation.decimal.es
        4: punctuation.decimal.es
        5: meta.numeric.exponent.e.es
        6: meta.numeric.exponent.sign.es
        7: meta.numeric.exponent.digit.es
      set: [ classDeclaration_AFTER_BRACE, method_AFTER_NAME ]
    - match: '({{binNum}})'
      scope: constant.numeric.binary.es
      captures:
        1: entity.name.method.es
        2: meta.numeric.prefix.es
      set: [ classDeclaration_AFTER_BRACE, method_AFTER_NAME ]
    - match: '({{octNum}})'
      scope: constant.numeric.octal.es
      captures:
        1: entity.name.method.es
        2: meta.numeric.prefix.es
      set: [ classDeclaration_AFTER_BRACE, method_AFTER_NAME ]
    - match: '({{hexNum}})'
      scope: constant.numeric.hexadecimal.es
      captures:
        1: entity.name.method.es
        2: meta.numeric.prefix.es
      set: [ classDeclaration_AFTER_BRACE, method_AFTER_NAME ]
    - match: '((\[))'
      captures:
        1: punctuation.definition.accessor.begin.es
        2: meta.brace.square.js # ^BS
      set: [ classDeclaration_AFTER_BRACE, method_AFTER_NAME, computedProp_AFTER_AE, assignmentExpression ]
    - include: other_illegal_pop

  classDeclaration_AFTER_DECORATOR:
    - match: '((@))'
      captures:
        1: punctuation.definition.tag.js # ^BS
        2: punctuation.definition.decorator.es
      push: decoratorExpression
    - match: 'class'
      scope: storage.type.class.es
      set: classDeclaration_AFTER_CLASS
    # TEMPORARY, WILL PROBABLY BE REMOVED WHEN BABEL REINTRODUCES DECORATORS
    # In Babel 5, the class decorator implementation departed from the proposal
    # grammar and introduced its own production, <decorator> <exportStatement>,
    # where the exportStatement was a new production restricted to only those
    # which contain class declarations. I’m not sure if this was intentional or
    # accidental, but there’s no sign that this will ever be part of the actual
    # proposal (it looks nice, but syntactically, it doesn’t really make sense),
    # and I suspect Babel 6 will rectify this when it implements the new version
    # of the decorator proposal.
    - match: '(?=export\s+(default\s+)?class)'
      pop: true
    - include: other_illegal_pop

  constLetVarDeclaration_AFTER_WORD:
    # The first four of these are used to assign scopes for using in the symbol
    # list. This is important as the `const x =` function ‘declaration’ pattern
    # seems to be taking off now that there’s an actual reason for it. This same
    # set of matches allows us to apply scopes for BS / JSN themes.
    - match: '((({{allThreeIDs}})))(?=\s*=\s*function\s*\*)'
      captures:
        1: meta.function.js entity.name.function.js # ^BS
        2: meta.symbol-helper.generator.es # -BS
        3: variable.other.readwrite.allCap.es # -BS
        4: variable.other.readwrite.initCap.es
        5: variable.other.readwrite.es
        6: entity.name.function.generator.es
      set: constLetVarDeclaration_AFTER_BINDING
    - match: '((({{allThreeIDs}})))(?=\s*=\s*async\s+function{{idEnd}})'
      captures:
        1: meta.function.js entity.name.function.js # ^BS
        2: meta.symbol-helper.function.es
        3: variable.other.readwrite.allCap.es # -BS
        4: variable.other.readwrite.initCap.es
        5: variable.other.readwrite.es
        6: entity.name.function.async.es
      set: constLetVarDeclaration_AFTER_BINDING
    - match: '((({{allThreeIDs}})))(?=\s*=\s*function{{idEnd}})'
      captures:
        1: meta.function.js entity.name.function.js # ^BS
        2: meta.symbol-helper.function.es
        3: variable.other.readwrite.allCap.es # -BS
        4: variable.other.readwrite.initCap.es
        5: variable.other.readwrite.es
        6: entity.name.function.es
      set: constLetVarDeclaration_AFTER_BINDING
    - match: '(({{allThreeIDs}}))(?=\s*=\s*class\s*(?:\{|extends{idEnd}))'
      captures:
        1: meta.function.js entity.name.class.js # ^BS, augmented
        2: meta.symbol-helper.class.es
        3: variable.other.readwrite.allCap.es # -BS
        4: variable.other.readwrite.initCap.es
        5: variable.other.readwrite.es
      set: constLetVarDeclaration_AFTER_BINDING
    - match: >-
        (?x)
          ((( {{allThreeIDs}} )))
          (?=
            \s* = \s* (async\s+)?
            (?:
              \(
                (?<parens> [^\(\)] | \( \g<parens>* \) )*
              \)
              |
              {{identifierName}}
            )
            \s* =>
          )
      captures:
        1: meta.function.arrow.js entity.name.function.js # ^BS
        2: meta.symbol-helper.arrow.es
        3: variable.other.readwrite.allCap.es
        4: variable.other.readwrite.initCap.es
        5: variable.other.readwrite.es
        6: entity.name.function.es
      set: constLetVarDeclaration_AFTER_BINDING
    - match: '{{allThreeIDs}}'
      captures:
        1: variable.other.readwrite.allCap.es # -BS
        2: variable.other.readwrite.initCap.es
        3: variable.other.readwrite.es
      set: constLetVarDeclaration_AFTER_BINDING
    - match: '((\[))'
      captures:
        1: punctuation.definition.binding.array.begin.es
        2: meta.brace.square.js # ^BS
      set: [ constLetVarDeclaration_AFTER_BINDING_PATTERN, bindingArray ]
    - match: '((\{))'
      captures:
        1: punctuation.definition.binding.object.begin.es
        2: meta.brace.curly.js # ^BS
      set: [ constLetVarDeclaration_AFTER_BINDING_PATTERN, bindingObject ]
    # We forgive syntax errors here to prevent mid-typing scope error cascades
    - include: else_pop

  constLetVarDeclaration_AFTER_BINDING:
    - match: '((,))'
      captures:
        1: punctuation.separator.binding-binding.es
        2: meta.delimiter.comma.js
      set: constLetVarDeclaration_AFTER_WORD
    - match: '='
      scope: keyword.operator.assignment.es
      push: assignmentExpression
    - include: else_pop

  constLetVarDeclaration_AFTER_BINDING_PATTERN:
    - match: '='
      scope: keyword.operator.assignment.es
      set: [ constLetVarDeclaration_AFTER_BINDING, assignmentExpression ]
    - include: other_illegal_pop

  functionDeclaration_AFTER_FUNCTION:
    - match: '{{allThreeIDs}}'
      captures:
        1: entity.name.function.allCap.es
        2: entity.name.function.initCap.es
        3: entity.name.function.es
      set: functionDeclaration_AFTER_NAME
    - include: other_illegal_pop

  functionDeclaration_AFTER_NAME:
    - match: '((\())'
      captures:
        1: punctuation.definition.parameters.function.begin.es
        2: meta.brace.round.js # ^BS
      set: [ functionDeclaration_AFTER_PARAMS, parameters ]
    - include: other_illegal_pop

  functionDeclaration_AFTER_PARAMS:
    - match: '((\)))'
      captures:
        1: punctuation.definition.parameters.function.end.es
        2: meta.brace.round.js # ^BS
      set: functionDeclaration_BEFORE_BRACE
    - include: other_illegal

  functionDeclaration_BEFORE_BRACE:
    - match: '((\{))'
      captures:
        1: punctuation.definition.function.body.begin.es
        2: meta.brace.curly.js # ^BS
      set: functionDeclaration_AFTER_BRACE
    - include: other_illegal_pop

  functionDeclaration_AFTER_BRACE:
    - match: '((\}))'
      captures:
        1: punctuation.definition.function.body.end.es
        2: meta.brace.curly.js # ^BS
      pop: true
    - include: useStrict
    - include: statements

  asyncDeclaration_AFTER_FUNCTION:
    - match: '((\*))'
      captures:
        1: keyword.generator.asterisk.js # ^BS
        2: storage.modifier.generator.asterisk.method.es
      set:
        - match: '{{allThreeIDs}}'
          scope: entity.name.function.async.es
          set: asyncDeclaration_AFTER_NAME
        - include: other_illegal_pop
    - match: '{{allThreeIDs}}'
      scope: entity.name.function.async.es
      set: asyncDeclaration_AFTER_NAME
    - include: other_illegal_pop

  asyncDeclaration_AFTER_NAME:
    - match: '((\())'
      captures:
        1: punctuation.definition.parameters.function.async.begin.es
        2: meta.brace.round.js # ^BS
      set: [ asyncDeclaration_AFTER_PARAMS, parameters ]
    - include: other_illegal_pop

  asyncDeclaration_AFTER_PARAMS:
    - match: '((\)))'
      captures:
        1: punctuation.definition.parameters.function.async.end.es
        2: meta.brace.round.js # ^BS
      set: asyncDeclaration_BEFORE_BRACE
    - include: other_illegal

  asyncDeclaration_BEFORE_BRACE:
    - match: '((\{))'
      captures:
        1: punctuation.definition.function.async.body.begin.es
        2: meta.brace.curly.js # ^BS
      set: asyncDeclaration_AFTER_BRACE
    - include: other_illegal_pop

  asyncDeclaration_AFTER_BRACE:
    - match: '((\}))'
      captures:
        1: punctuation.definition.function.async.body.end.es
        2: meta.brace.curly.js # ^BS
      pop: true
    - include: useStrict
    - include: statements

  generatorDeclaration_AFTER_ASTERISK:
    - match: '{{identifier}}'
      scope: entity.name.function.generator.es
      set: generatorDeclaration_AFTER_NAME
    - include: other_illegal_pop

  generatorDeclaration_AFTER_NAME:
    - match: '((\())'
      captures:
        1: punctuation.definition.parameters.generator.begin.es
        2: meta.brace.round.js # ^BS
      set: [ generatorDeclaration_AFTER_PARAMS, parameters ]
    - include: other_illegal_pop

  generatorDeclaration_AFTER_PARAMS:
    - match: '((\)))'
      captures:
        1: punctuation.definition.parameters.generator.end.es
        2: meta.brace.round.js # ^BS
      set: generatorDeclaration_BEFORE_BRACE
    - include: other_illegal

  generatorDeclaration_BEFORE_BRACE:
    - match: '((\{))'
      captures:
        1: punctuation.definition.generator.body.begin.es
        2: meta.brace.curly.js # ^BS
      set: generatorDeclaration_AFTER_BRACE
    - include: other_illegal_pop

  generatorDeclaration_AFTER_BRACE:
    - match: '((\}))'
      captures:
        1: punctuation.definition.generator.body.end.es
        2: meta.brace.curly.js # ^BS
      pop: true
    - include: useStrict
    - include: statements

  moduleDeclaration_AFTER_EXPORT:
    - match: '((\*))'
      captures:
        1: keyword.operator.module.js # ^BS, augmented
        2: storage.modifier.module.namespace.es
      set: moduleDeclaration_BEFORE_FROM
    - match: '((\{))'
      captures:
        1: punctuation.definition.module-binding.begin.es
        2: meta.brace.curly.js # ^BS
      set: moduleDeclaration_EXPORT_BINDING_AFTER_BRACE
    - match: '((@))'
      captures:
        1: punctuation.definition.tag.js # ^BS
        2: punctuation.definition.decorator.es
      push: decoratorExpression
    - match: '((default)){{idEnd}}'
      captures:
        1: keyword.operator.module.js # ^BS
        2: storage.modifier.module.default.es
      set: moduleDeclaration_AFTER_DEFAULT
    - match: 'let{{idEnd}}'
      scope: storage.type.variable.let.es
      set: constLetVarDeclaration_AFTER_WORD
    - match: 'var{{idEnd}}'
      scope: storage.type.variable.var.es
      set: constLetVarDeclaration_AFTER_WORD
    - match: 'class{{idEnd}}'
      scope: storage.type.class.es
      set: classDeclaration_AFTER_CLASS
    - match: 'const{{idEnd}}'
      scope: storage.type.constant.es
      set: constLetVarDeclaration_AFTER_WORD
    - match: '((function))\s*((\*))'
      captures:
        1: storage.type.function.js # ^BS -- Cobalt
        2: storage.type.function.generator.es
        3: keyword.generator.asterisk.js # ^BS
        4: storage.modifier.generator.asterisk.es
      set: generatorDeclaration_AFTER_ASTERISK
    - match: '((function)){{idEnd}}'
      captures:
        1: storage.type.function.js # ^BS -- Cobalt
        2: storage.type.function.es
      set: functionDeclaration_AFTER_FUNCTION
    - match: '((async))\s*((function)){{idEnd}}'
      captures:
        1: storage.type.js # ^BS
        2: storage.modifier.async.es
        3: storage.type.function.js # ^BS -- Cobalt
        4: storage.type.function.async.es
      set: asyncDeclaration_AFTER_FUNCTION
    # ES proposal: re-export default without 'default' (supported by Babel)
    # Technically if this proposal gets in, I’m guessing it would also permit
    # constructions like...
    #
    # export Foo, { bar } from 'baz'
    #
    # ...but I’m not gonna bother with that quite yet.
    - match: '{{identifier}}'
      scope: variable.other.readwrite.export.es
      set: moduleDeclaration_BEFORE_FROM
    - include: other_illegal_pop

  moduleDeclaration_AFTER_DEFAULT:
    - match: 'class{{idEnd}}'
      scope: storage.type.class.es
      set: moduleDeclaration_DEFAULT_AFTER_CLASS
    - match: '((function))\s*((\*))'
      captures:
        1: storage.type.function.js # ^BS -- Cobalt
        2: storage.type.function.generator.es
        3: keyword.generator.asterisk.js # ^BS
        4: storage.modifier.generator.asterisk.es
      set: moduleDeclaration_DEFAULT_AFTER_ASTERISK
    - match: '((function)){{idEnd}}'
      captures:
        1: storage.type.function.js # ^BS -- Cobalt
        2: storage.type.function.es
      set: moduleDeclaration_DEFAULT_AFTER_FUNCTION
    - match: '((async))\s*((function)){{idEnd}}((\s*\*))?'
      captures:
        1: storage.type.js # ^BS
        2: storage.modifier.async.es
        3: storage.type.function.js # ^BS -- Cobalt
        4: storage.type.function.async.es
        5: keyword.generator.asterisk.js # ^BS
        6: storage.modifier.generator.asterisk.method.es
      set: moduleDeclaration_DEFAULT_AFTER_ASYNC_FUNCTION
    - match: '((@))'
      captures:
        1: punctuation.definition.tag.js # ^BS
        2: punctuation.definition.decorator.es
      set: [ moduleDeclaration_DEFAULT_AFTER_DECORATOR, decoratorExpression ]
    - match: '{{PLA_anything}}'
      set: assignmentExpression

  moduleDeclaration_DEFAULT_AFTER_DECORATOR:
    - match: 'class{{idEnd}}'
      scope: storage.type.class.es
      set: moduleDeclaration_DEFAULT_AFTER_CLASS
    - match: '((@))'
      captures:
        1: punctuation.definition.tag.js # ^BS
        2: punctuation.definition.decorator.es
      push: [ decoratorExpression ]
    - include: other_illegal_pop

  moduleDeclaration_DEFAULT_AFTER_CLASS:
    - match: '((\{))'
      captures:
        1: punctuation.definition.class.body.begin.es
        2: meta.brace.curly.js # ^BS
      set: classDeclaration_AFTER_BRACE
    - match: '((extends)){{idEnd}}'
      captures:
        1: storage.type.extends.js # ^BS
        2: storage.modifier.extends.es
      set: [ classDeclaration_AFTER_HERITAGE, assignmentExpression ]
    - match: '(({{identifier}}))'
      captures:
        1: entity.name.class.js # ^BS -- monokai
        2: entity.name.class.es
      set: classDeclaration_AFTER_NAME
    - include: other_illegal_pop

  moduleDeclaration_DEFAULT_AFTER_ASTERISK:
    - match: '((\())'
      captures:
        1: punctuation.definition.parameters.generator.begin.es
        2: meta.brace.round.js # ^BS
      set: [ generatorDeclaration_AFTER_PARAMS, parameters ]
    - match: '{{identifier}}'
      scope: entity.name.function.generator.es
      set: generatorDeclaration_AFTER_NAME
    - include: other_illegal_pop

  moduleDeclaration_DEFAULT_AFTER_FUNCTION:
    - match: '((\())'
      captures:
        1: punctuation.definition.parameters.function.begin.es
        2: meta.brace.round.js # ^BS
      set: [ functionDeclaration_AFTER_PARAMS, parameters ]
    - match: '{{allThreeIDs}}'
      captures:
        1: entity.name.function.allCap.es
        2: entity.name.function.initCap.es
        3: entity.name.function.es
      set: functionDeclaration_AFTER_NAME
    - include: other_illegal_pop

  moduleDeclaration_DEFAULT_AFTER_ASYNC_FUNCTION:
    - match: '((\())'
      captures:
        1: punctuation.definition.parameters.function.async.begin.es
        2: meta.brace.round.js # ^BS
      set: [ asyncDeclaration_AFTER_PARAMS, parameters ]
    - match: '{{allThreeIDs}}'
      scope: entity.name.function.async.es
      set: asyncDeclaration_AFTER_NAME
    - include: other_illegal_pop

  moduleDeclaration_BEFORE_FROM:
    - match: '((from)){{idEnd}}'
      captures:
        1: keyword.operator.module.js # ^BS
        2: storage.modifier.module.from.es
      set: moduleDeclaration_BEFORE_SPECIFIER
    - include: other_illegal_pop

  moduleDeclaration_BEFORE_SPECIFIER:
    - match: "'"
      scope: punctuation.definition.string.quoted.single.begin.es
      set: stringSingle_AFTER_OPEN
    - match: '"'
      scope: punctuation.definition.string.quoted.double.begin.es
      set: stringDouble_AFTER_OPEN
    - include: other_illegal_pop

  moduleDeclaration_EXPORT_BINDING_AFTER_BRACE:
    - match: '((\}))'
      captures:
        1: punctuation.definition.module-binding.end.es
        2: meta.brace.curly.js # ^BS
      set: moduleDeclaration_EXPORT_AFTER_BINDING
    - match: '({{identifier}})\s+((as)){{idEnd}}'
      captures:
        1: variable.other.readwrite.export.es
        2: keyword.operator.module.js # ^BS
        3: storage.modifier.module.as.es
      set: moduleDeclaration_EXPORT_BINDING_AFTER_AS
    - match: '(default)\s+((as)){{idEnd}}'
      captures:
        1: storage.modifier.module.default.es
        2: keyword.operator.module.js # ^BS
        3: storage.modifier.module.as.es
      set: moduleDeclaration_EXPORT_BINDING_AFTER_AS
    - match: '{{identifier}}'
      scope: variable.other.readwrite.export.es
      set: moduleDeclaration_AFTER_EXPORT_BINDING_SPECIFIER_AMBIG
    - include: other_illegal

  moduleDeclaration_EXPORT_BINDING_AFTER_AS:
    - match: '{{identifier}}'
      scope: entity.name.module.export.es
      set: moduleDeclaration_AFTER_EXPORT_BINDING_SPECIFIER
    - include: other_illegal_pop

  moduleDeclaration_AFTER_EXPORT_BINDING_SPECIFIER:
    - match: '((\}))'
      captures:
        1: punctuation.definition.module-binding.end.es
        2: meta.brace.curly.js # ^BS
      set: moduleDeclaration_EXPORT_AFTER_BINDING
    - match: '((,))'
      captures:
        1: punctuation.separator.module-binding.es
        2: meta.delimiter.comma.js # ^BS
      set: moduleDeclaration_EXPORT_BINDING_AFTER_BRACE
    - include: other_illegal

  moduleDeclaration_AFTER_EXPORT_BINDING_SPECIFIER_AMBIG:
    - match: '((as)){{idEnd}}'
      captures:
        1: keyword.operator.module.js # ^BS
        2: storage.modifier.module.as.es
      set: moduleDeclaration_EXPORT_BINDING_AFTER_AS
    - include: moduleDeclaration_AFTER_EXPORT_BINDING_SPECIFIER

  moduleDeclaration_EXPORT_AFTER_BINDING:
    - match: ';'
      scope: punctuation.terminator.statement.es
      pop: true
    - match: '((from)){{idEnd}}'
      captures:
        1: keyword.operator.module.js # ^BS
        2: storage.modifier.module.from.es
      set: moduleDeclaration_BEFORE_SPECIFIER
    - include: else_pop

  moduleDeclaration_AFTER_IMPORT:
    - match: '((\*))'
      captures:
        1: keyword.operator.module.js # ^BS, augmented
        2: storage.modifier.module.namespace.es
      set: moduleDeclaration_IMPORT_BINDING_AFTER_ASTERISK
    - match: '((\{))'
      captures:
        1: punctuation.definition.module-binding.begin.es
        2: meta.brace.curly.js # ^BS
      set: moduleDeclaration_IMPORT_BINDING_AFTER_BRACE
    - match: '{{identifier}}'
      scope: variable.other.readwrite.import.es
      set: moduleDeclaration_IMPORT_AFTER_IDENTIFIER
    - include: moduleDeclaration_BEFORE_SPECIFIER

  moduleDeclaration_IMPORT_AFTER_IDENTIFIER:
    - match: '((,))'
      captures:
        1: punctuation.separator.module-binding.es
        2: meta.delimiter.comma.js # ^BS
      set: moduleDeclaration_IMPORT_AFTER_IDENTIFIER_COMMA
    - match: '((from)){{idEnd}}'
      captures:
        1: keyword.operator.module.js # ^BS
        2: storage.modifier.module.from.es
      set: moduleDeclaration_BEFORE_SPECIFIER

  moduleDeclaration_IMPORT_AFTER_IDENTIFIER_COMMA:
    - match: '((\*))'
      captures:
        1: keyword.operator.module.js # ^BS, augmented
        2: storage.modifier.module.namespace.es
      set: moduleDeclaration_IMPORT_BINDING_AFTER_ASTERISK
    - match: '((\{))'
      captures:
        1: punctuation.definition.module-binding.begin.es
        2: meta.brace.curly.js # ^BS
      set: moduleDeclaration_IMPORT_BINDING_AFTER_BRACE
    - include: other_illegal_pop

  moduleDeclaration_IMPORT_BINDING_AFTER_ASTERISK:
    - match: '((as)){{idEnd}}'
      captures:
        1: keyword.operator.module.js # ^BS
        2: storage.modifier.module.as.es
      set: moduleDeclaration_IMPORT_BINDING_AFTER_AS
    - include: other_illegal_pop

  moduleDeclaration_IMPORT_BINDING_AFTER_AS:
    - match: '{{identifier}}'
      scope: variable.other.readwrite.import.es
      set: moduleDeclaration_BEFORE_FROM
    - include: other_illegal_pop

  moduleDeclaration_IMPORT_BINDING_AFTER_BRACE:
    - match: '((\}))'
      captures:
        1: punctuation.definition.module-binding.end.es
        2: meta.brace.curly.js # ^BS
      set: moduleDeclaration_BEFORE_FROM
    - match: '({{identifier}})\s+((as)){{idEnd}}'
      captures:
        1: entity.name.module.import.es
        2: keyword.operator.module.js # ^BS
        3: storage.modifier.module.as.es
      set: moduleDeclaration_IMPORT_BINDING_AFTER_AS_BEFORE_BRACE_CLOSE
    - match: '{{identifier}}'
      scope: variable.other.readwrite.import.es
      set: moduleDeclaration_AFTER_IMPORT_BINDING_SPECIFIER_AMBIG
    - include: other_illegal

  moduleDeclaration_IMPORT_BINDING_AFTER_AS_BEFORE_BRACE_CLOSE:
    - match: '{{identifier}}'
      scope: variable.other.readwrite.import.es
      set: moduleDeclaration_AFTER_IMPORT_BINDING_SPECIFIER
    - include: other_illegal_pop

  moduleDeclaration_AFTER_IMPORT_BINDING_SPECIFIER:
    - match: '((\}))'
      captures:
        1: punctuation.definition.module-binding.end.es
        2: meta.brace.curly.js # ^BS
      set: moduleDeclaration_BEFORE_FROM
    - match: '((,))'
      captures:
        1: punctuation.separator.module-binding.es
        2: meta.delimiter.comma.js # ^BS
      set: moduleDeclaration_IMPORT_BINDING_AFTER_BRACE
    - include: other_illegal

  moduleDeclaration_AFTER_IMPORT_BINDING_SPECIFIER_AMBIG:
    - match: '((as)){{idEnd}}'
      captures:
        1: keyword.operator.module.js # ^BS
        2: storage.modifier.module.as.es
      set: moduleDeclaration_IMPORT_BINDING_AFTER_AS_BEFORE_BRACE_CLOSE
    - include: moduleDeclaration_AFTER_IMPORT_BINDING_SPECIFIER

# EXPRESSION ###################################################################

  # An expression is either a single assignment expression, or multiple AEs
  # separated by commas. Unlike commas appearing in parameters, imports, arrays,
  # and objects, this comma is an operator (...technically). Sad little thing.

  expression:
    - match: '{{PLA_anything}}'
      set: [ expression_AFTER_AE, assignmentExpression ]

  expression_AFTER_AE:
    - match: ','
      scope: keyword.operator.comma.es
      push: assignmentExpression
    - include: else_pop

  decoratorExpression:
    # While the expression in a decorator is simply an assignment expression,
    # realistically it will nearly always be an identifier, and it is something
    # to which we would like to give a unique scope when possible. However to be
    # safe we still need to continue on to the usual AE context.
    #
    # Also note that there are problems with the current spec’s grammar
    # definition. Allowing an assignment expression before a method definition
    # creates ambiguities that even a real parser wouldn’t like, muchless a
    # linear regex syntax def. To deal with this we actually need to add to add
    # a kindof hackish lookahead in assignment expression to (hopefully) pop on
    # generator definitions. We can also try to deal with some computed props.
    - match: '(?!async{{idEnd}})(({{identifier}}))(?!\s*=){{idEnd}}'
      captures:
        1: entity.name.tag.js # ^ BS
        2: variable.other.readwrite.decorator.es
      set: ae_AFTER_IDENTIFIER
    - include: assignmentExpression

  # AE is what we generally think of when we say ‘expression’. Since we always
  # must arrive at expressions from the ‘statement level’, it’s worth noting
  # that there are only three types of expressions demanded there:
  #
  # - expression
  # - assignment expression
  # - left hand side expression
  #
  # For our purposes, though, the last one must be ignored; there’s just no
  # practical way -- nor any real benefit re: highlighting -- to ensuring that a
  # given expression is in fact an LHSE. And this is just one of many ways that
  # assigning scopes within expressions is far more permissive than the rigid
  # approach used for statements (which generally have nice clear structures and
  # keywords and delimiting punctuation that we want to scope).
  #
  # This context is a greedy consumer. That is, while it requires that there be
  # at least one valid assignment expression, it continues trying to match
  # expression components for as long as possible before popping, since one AE
  # is often be a composition of what could be multiple AEs.
  #
  # Many of the contexts here are only groupings used in includes for clarity
  # and convenience rather than states that one would transition to. However the
  # match sequence is important.
  #
  # Finally note that there are two versions: one which allows the in operator
  # and one which does not. The latter is required for distinguishing the
  # operator from the control keyword in for loops. Though it leads to an
  # especially perverse amount of duplication, I consider this too important to
  # not do.

  assignmentExpression:
    - include: assignmentExpression_CORE
    - include: other_illegal_pop

  assignmentExpression_CORE:
    - include: ae_LITERAL_VALUES
    - include: ae_NUMBERS
    - include: ae_STRING_REGEX
    - include: ae_ARRAY_COMPREHENSION
    - include: ae_OBJECT_ARRAY_BINDING
    - include: ae_OBJECT_ARRAY_LITERAL
    - include: ae_YIELD_NEW
    - include: ae_FUNCTION_GENERATOR_CLASS
    - include: ae_PREFIX_OPS
    - include: ae_ARROW
    - include: ae_IDENTIFIERS
    - include: ae_GENERATOR_COMPREHENSION
    - include: ae_PARENTHESIZED
    - include: ae_DO
    - include: ae_JSX

  ae_AFTER_IDENTIFIER:
    - match: '=>'
      scope: storage.type.function.arrow.es
      set: ae_ARROW_AFTER_ARROW
    - include: ae_AFTER_THING

  # The ‘thing’ in question is a ‘value’ that is conceivably invocable.
  ae_AFTER_THING:
    - match: '((\())'
      captures:
        1: punctuation.definition.arguments.begin.es
        2: meta.brace.round.js # ^BS
      push: arguments
    - match: '`'
      scope: punctuation.definition.string.interpolated.begin.es # -BS
      set: [ ae_AFTER_VALUE, templateString_AFTER_OPEN ]
    - include: ae_POSTFIX_OPS
    - include: ae_INFIX_OPS_ASSIGNMENT
    - include: ae_AFTER_VALUE

  # The ‘value’ in question is anything which might be followed by property
  # access or infix operators other than assignment operators -- or it could
  # just be the end of the assignment expression.
  ae_AFTER_VALUE:
    # Refinement for error cases that are artifacts of active typing
    - match: '\.(?=\s*[\}\)\]])'
      scope: invalid.illegal.token
      pop: true
    # Accessor operator
    - match: '\.'
      scope: keyword.operator.accessor.es
      set: ae_AFTER_ACCESSOR_OPERATOR
    # This is another special cases for crybaby decorator expressions. It will
    # work only for computed properties that do not contain other brackets, but
    # that should be sufficient for any realistic cases. It isn’t needed in the
    # ‘NO_IN’ series.
    - match: >-
        (?x) (?=
          \[
            [^\[\]]+
          \]
          \s* \( [^\)]* \) \s* \{
        )
      pop: true
    # Accessor brackets
    - match: '((\[))'
      captures:
        1: punctuation.definition.accessor.begin.es
        2: meta.brace.square.js # ^BS
      set: [ ae_AFTER_THING, computedProp_AFTER_AE, assignmentExpression ]
    - include: ae_INFIX_OPS
    - include: ae_AFTER_POSTFIX

  ae_AFTER_POSTFIX:
    - include: ae_INFIX_OPS
    - include: else_pop

  ae_AFTER_ACCESSOR_OPERATOR:
    - match: '((({{identifierAllCaps}})))\s*((\())'
      captures:
        1: variable.other.readwrite.property.allCap.es
        2: meta.function-call # ^BS
        3: meta.invocation.es
        4: punctuation.definition.arguments.begin.es
        5: meta.brace.round.js # ^BS
      set: [ ae_AFTER_THING, arguments ]
    - match: '((({{identifierInitCap}})))\s*((\())'
      captures:
        1: variable.other.readwrite.property.initCap.es
        2: meta.function-call # ^BS
        3: meta.invocation.es
        4: punctuation.definition.arguments.begin.es
        5: meta.brace.round.js # ^BS
      set: [ ae_AFTER_THING, arguments ]
    - match: '((({{identifierName}})))\s*((\())'
      captures:
        1: variable.other.readwrite.property.es
        2: meta.function-call # ^BS
        3: meta.invocation.es
        4: punctuation.definition.arguments.begin.es
        5: meta.brace.round.js # ^BS
      set: [ ae_AFTER_THING, arguments ]
    - match: '(prototype){{idEnd}}'
      scope: variable.other.readwrite.property.prototype.es
      captures:
        1: variable.language.prototype.es # for compatibility
      set: ae_AFTER_THING
    - match: '(__proto__){{idEnd}}'
      scope: variable.other.readwrite.property.proto.es
      captures:
        1: variable.language.proto.es # for compatibility
      set: ae_AFTER_THING
    - match: '(({{identifierName}}))(?=\s*=\s*async\s+function\b)'
      captures:
        1: variable.other.readwrite.property.es
        2: entity.name.method.async.es
      set: ae_AFTER_THING
    - match: '(({{identifierName}}))(?=\s*=\s*function\s*\*)'
      captures:
        1: variable.other.readwrite.property.es
        2: entity.name.method.generator.es
      set: ae_AFTER_THING
    - match: '(({{identifierName}}))(?=\s*=\s*function\b)'
      captures:
        1: variable.other.readwrite.property.es
        2: entity.name.method.es
      set: ae_AFTER_THING
    - match: '(({{identifierName}}))\s*(=)\s*(\()(?=(?<parens>[^\(\)]|\(\g<parens>*\))*\)\s*=>)'
      captures:
        1: variable.other.readwrite.property.es
        2: entity.name.method.es
        3: keyword.operator.assignment.es
        4: punctuation.definition.parameters.function.arrow.begin.es
      set: [ ae_ARROW_AFTER_PARAMS, parameters ]
    - match: '(({{identifierName}}))\s*(=)\s*({{identifier}})\s*(=>)'
      captures:
        1: variable.other.readwrite.property.es
        2: entity.name.method.es
        3: keyword.operator.assignment.es
        4: variable.parameter.es
        5: storage.type.function.arrow.es
      set: ae_ARROW_AFTER_ARROW
    - match: '(({{identifierName}}))\s*(=)\s*((async))\s+({{identifier}})\s*(=>)'
      captures:
        1: variable.other.readwrite.property.es
        2: entity.name.method.async.es
        3: keyword.operator.assignment.es
        4: storage.type.js
        5: storage.modifier.async.expression.es
        6: variable.parameter.es
        7: storage.type.function.arrow.es
      set: ae_ASYNC_ARROW_AFTER_ARROW
    - match: '(({{identifierName}}))\s*(=)\s*((async))\s*(\()'
      captures:
        1: variable.other.readwrite.property.es
        2: entity.name.method.async.es
        3: keyword.operator.assignment.es
        4: storage.type.js # ^BS
        5: storage.modifier.async.expression.es
        6: punctuation.definition.parameters.function.arrow.begin.es
      set: [ ae_ASYNC_ARROW_AFTER_PARAMS, parameters ]
    - match: '{{identifierName}}'
      scope: variable.other.readwrite.property.es
      set: ae_AFTER_THING
    # Refinement for error cases that are artifacts of active typing
    - match: '(?=[\}\)\]])'
      pop: true
    - include: other_illegal_pop

  ae_ARRAY_COMPREHENSION:
    - match: '((\[))\s*(for){{idEnd}}'
      captures:
        1: punctuation.definition.comprehension.array.begin.es
        2: meta.brace.square.js # ^BS
        3: keyword.control.loop.for.comprehension.array.es
      set: ae_ARRAY_COMPREHENSION_AFTER_FOR

  ae_ARRAY_COMPREHENSION_AFTER_FOR:
    - match: '((\())'
      captures:
        1: punctuation.definition.expression.loop.comprehension.array.begin.es
        2: meta.brace.round.js # ^BS
      set: [ ae_ARRAY_COMPREHENSION_AFTER_LHSE, assignmentExpression ]
    - match: '{{MAT_word_or_any_one_char}}'
      scope: invalid.illegal.token.es
      set: ae_ARRAY_COMPREHENSION_BEFORE_CLOSE

  ae_ARRAY_COMPREHENSION_AFTER_LHSE:
    - match: 'of{{idEnd}}'
      scope: keyword.control.loop.of.comprehension.array.es
      set: [ ae_ARRAY_COMPREHENSION_AFTER_EXP_BODY, expression ]
    - match: '{{MAT_word_or_any_one_char}}'
      scope: invalid.illegal.token.es
      set: ae_ARRAY_COMPREHENSION_AFTER_EXP_BODY

  ae_ARRAY_COMPREHENSION_AFTER_EXP_BODY:
    - match: '((\)))'
      captures:
        1: punctuation.definition.expression.loop.comprehension.array.begin.es
        2: meta.brace.round.js # ^BS
      set: ae_ARRAY_COMPREHENSION_AFTER_EXP
    - match: '{{MAT_word_or_any_one_char}}'
      scope: invalid.illegal.token.es
      set: ae_ARRAY_COMPREHENSION_BEFORE_CLOSE

  ae_ARRAY_COMPREHENSION_AFTER_EXP:
    - match: 'if{{idEnd}}'
      scope: keyword.control.loop.conditional.if.comprehension.array.es
      set: ae_ARRAY_COMPREHENSION_AFTER_IF
    - match: 'for{{idEnd}}'
      scope: keyword.control.loop.for.comprehension.array.es
      set: ae_ARRAY_COMPREHENSION_AFTER_FOR
    - match: '{{PLA_anything}}'
      set: [ ae_ARRAY_COMPREHENSION_BEFORE_CLOSE, expression ]
    - match: '{{MAT_word_or_any_one_char}}'
      scope: invalid.illegal.token.es
      set: ae_ARRAY_COMPREHENSION_BEFORE_CLOSE

  ae_ARRAY_COMPREHENSION_AFTER_IF:
    - match: '((\())'
      captures:
        1: punctuation.definition.expression.conditional.comprehension.array.begin.es
        2: meta.brace.round.js # ^BS
      set: [ ae_ARRAY_COMPREHENSION_AFTER_IF_EXP, expression ]
    - match: '{{MAT_word_or_any_one_char}}'
      scope: invalid.illegal.token.es
      set: ae_ARRAY_COMPREHENSION_AFTER_IF_EXP

  ae_ARRAY_COMPREHENSION_AFTER_IF_EXP:
    - match: '((\)))'
      captures:
        1: punctuation.definition.expression.conditional.comprehension.array.begin.es
        2: meta.brace.round.js # ^BS
      set: ae_ARRAY_COMPREHENSION_AFTER_EXP
    - match: '{{MAT_word_or_any_one_char}}'
      scope: invalid.illegal.token.es
      set: ae_ARRAY_COMPREHENSION_BEFORE_CLOSE

  ae_ARRAY_COMPREHENSION_BEFORE_CLOSE:
    - match: '((\]))'
      captures:
        1: punctuation.definition.comprehension.array.end.es
        2: meta.brace.square.js # ^BS
      set: ae_AFTER_VALUE
    - include: other_illegal

  ae_ARROW:
    # This will work so long as the => is on the same line as the arguments. An
    # arrow function with a single argument will instead be matched in
    # ae_AFTER_VALUE.
    - match: '(?x) \( (?= (?<parens> [^\(\)] | \( \g<parens>* \) )* \)\s*=> )'
      scope: punctuation.definition.parameters.function.arrow.begin.es
      set: [ ae_ARROW_AFTER_PARAMS, parameters ]
    - match: '((async))\s*(\()'
      captures:
        1: storage.type.js # ^BS
        2: storage.modifier.async.expression.es
        3: punctuation.definition.parameters.function.async.arrow.begin.es
      set: [ ae_ASYNC_ARROW_AFTER_PARAMS, parameters ]

  ae_ARROW_AFTER_PARAMS:
    - match: '\)'
      scope: punctuation.definition.parameters.function.arrow.end.es
      set: ae_ARROW_BEFORE_ARROW
    # The following might be unreachable in theory, but just to be safe:
    - include: other_illegal_pop

  ae_ARROW_BEFORE_ARROW:
    - match: '=>'
      scope: storage.type.function.arrow.es
      set: ae_ARROW_AFTER_ARROW
    # (Likewise)
    - include: other_illegal_pop

  ae_ARROW_AFTER_ARROW:
    - match: '((\{))'
      captures:
        1: punctuation.definition.function.arrow.body.begin.es
        2: meta.brace.curly.js # ^BS
      set: ae_ARROW_AFTER_BRACE
    - match: '{{PLA_anything}}'
      set: assignmentExpression

  ae_ARROW_AFTER_BRACE:
    - match: '((\}))'
      captures:
        1: punctuation.definition.function.arrow.body.end.es
        2: meta.brace.curly.js # ^BS
      set: ae_AFTER_THING
    - include: useStrict
    - include: statements
    - include: other_illegal

  ae_ASYNC_ARROW_AFTER_PARAMS:
    - match: '\)'
      scope: punctuation.definition.parameters.function.async.arrow.end.es
      set: ae_ASYNC_ARROW_BEFORE_ARROW
    # The following might be unreachable in theory, but just to be safe:
    - include: other_illegal_pop

  ae_ASYNC_ARROW_BEFORE_ARROW:
    - match: '=>'
      scope: storage.type.function.async.arrow.es
      set: ae_ASYNC_ARROW_AFTER_ARROW
    # (Likewise)
    - include: other_illegal_pop

  ae_ASYNC_ARROW_AFTER_ARROW:
    - match: '((\{))'
      captures:
        1: punctuation.definition.function.async.arrow.body.begin.es
        2: meta.brace.curly.js # ^BS
      set: ae_ASYNC_ARROW_AFTER_BRACE
    - match: '{{PLA_anything}}'
      set: assignmentExpression

  ae_ASYNC_ARROW_AFTER_BRACE:
    - match: '((\}))'
      captures:
        1: punctuation.definition.function.async.arrow.body.end.es
        2: meta.brace.curly.js # ^BS
      set: ae_AFTER_THING
    - include: useStrict
    - include: statements
    - include: other_illegal

  ae_CLASS_AFTER_CLASS:
    - match: '((\{))'
      captures:
        1: punctuation.definition.class.body.begin.es
        2: meta.brace.curly.js # ^BS
      set: [ ae_AFTER_THING, classDeclaration_AFTER_BRACE ]
    - match: '((extends)){{idEnd}}'
      captures:
        1: storage.type.extends.js # ^BS
        2: storage.modifier.extends.es
      set: [ ae_AFTER_THING, classDeclaration_AFTER_HERITAGE, assignmentExpression ]
    - match: '(({{identifier}}))'
      captures:
        1: entity.name.class.js # ^BS -- monokai
        2: entity.name.class.es
      set: [ ae_AFTER_THING, classDeclaration_AFTER_NAME ]
    - include: other_illegal_pop

  ae_DO:
    - match: 'do{{idEnd}}'
      scope: keyword.control.do-expression.do.es
      set: [ ae_AFTER_THING, ae_DO_AFTER_DO ]

  ae_DO_AFTER_DO:
    - match: '((\{))'
      captures:
        1: punctuation.definition.block.do-expression.begin.es
        2: meta.brace.curly.js # ^BS
      set: 'ae_DO_AFTER_BRACE'
    - include: other_illegal_pop

  ae_DO_AFTER_BRACE:
    - match: '((\}))'
      captures:
        1: punctuation.definition.block.do-expression.end.es
        2: meta.brace.curly.js # ^BS
      pop: true
    - include: statements

  ae_FUNCTION_GENERATOR_CLASS:
    - match: 'function\s*\.\s*sent'
      scope: variable.language.function-sent.es
      set: ae_AFTER_THING
    - match: '((function))\s*((\*))'
      captures:
        1: storage.type.function.js # ^BS -- Cobalt
        2: storage.type.function.generator.expression.es
        3: keyword.generator.asterisk.js # ^BS
        4: storage.modifier.generator.asterisk.expression.es
      set: ae_GENERATOR_AFTER_ASTERISK
    - match: '\s*((function)){{idEnd}}'
      captures:
        1: storage.type.function.js # ^BS -- Cobalt
        2: storage.type.function.expression.es
      set: ae_FUNCTION_AFTER_FUNCTION
    - match: '((async))\s+((function)){{idEnd}}'
      captures:
        1: storage.type.js # ^BS
        2: storage.modifier.async.expression.es
        3: storage.type.function.js # ^BS -- Cobalt
        4: storage.type.function.async.expression.es
      set:
        - - include: ae_ASYNC_AFTER_FUNCTION
        - - match: '((\*))'
            captures:
              1: keyword.generator.asterisk.js # ^BS
              2: storage.modifier.generator.asterisk.method.es
            pop: true
          - include: else_pop
    - match: 'class{{idEnd}}'
      scope: storage.type.class.expression.es
      set: ae_CLASS_AFTER_CLASS

  ae_FUNCTION_AFTER_FUNCTION:
    - match: '\('
      scope: punctuation.definition.parameters.function.begin.es
      set: [ ae_AFTER_THING, functionDeclaration_AFTER_PARAMS, parameters ]
    - match: '{{identifier}}'
      scope: entity.name.function.es
      set: [ ae_AFTER_THING, functionDeclaration_AFTER_NAME ]
    - include: other_illegal_pop

  ae_ASYNC_AFTER_FUNCTION:
    - match: '\('
      scope: punctuation.definition.parameters.function.async.begin.es
      set: [ ae_AFTER_THING, asyncDeclaration_AFTER_PARAMS, parameters ]
    - match: '{{identifier}}'
      scope: entity.name.function.async.es
      set: [ ae_AFTER_THING, asyncDeclaration_AFTER_NAME ]
    - include: other_illegal_pop

  ae_GENERATOR_AFTER_ASTERISK:
    - match: '\('
      scope: punctuation.definition.parameters.generator.begin.es
      set: [ ae_AFTER_THING, generatorDeclaration_AFTER_PARAMS, parameters ]
    - match: '{{identifier}}'
      scope: entity.name.function.generator.es
      set: [ ae_AFTER_THING, generatorDeclaration_AFTER_NAME ]
    - include: other_illegal_pop

  ae_GENERATOR_COMPREHENSION:
    - match: '((\())\s*(for){{idEnd}}'
      captures:
        1: punctuation.definition.comprehension.generator.begin.es
        2: meta.brace.round.js # ^BS
        3: keyword.control.loop.for.comprehension.generator.es
      set: ae_GENERATOR_COMPREHENSION_AFTER_FOR

  ae_GENERATOR_COMPREHENSION_AFTER_FOR:
    - match: '((\())'
      captures:
        1: punctuation.definition.expression.loop.comprehension.generator.begin.es
        2: meta.brace.round.js # ^BS
      set: [ ae_GENERATOR_COMPREHENSION_AFTER_LHSE, assignmentExpression ]
    - match: '{{MAT_word_or_any_one_char}}'
      scope: invalid.illegal.token.es
      set: ae_GENERATOR_COMPREHENSION_BEFORE_CLOSE

  ae_GENERATOR_COMPREHENSION_AFTER_LHSE:
    - match: 'of{{idEnd}}'
      scope: keyword.control.loop.of.comprehension.generator.es
      set: [ ae_GENERATOR_COMPREHENSION_AFTER_EXP_BODY, expression ]
    - match: '{{MAT_word_or_any_one_char}}'
      scope: invalid.illegal.token.es
      set: ae_GENERATOR_COMPREHENSION_AFTER_EXP_BODY

  ae_GENERATOR_COMPREHENSION_AFTER_EXP_BODY:
    - match: '((\)))'
      captures:
        1: punctuation.definition.expression.loop.comprehension.generator.begin.es
        2: meta.brace.round.js # ^BS
      set: ae_GENERATOR_COMPREHENSION_AFTER_EXP
    - match: '{{MAT_word_or_any_one_char}}'
      scope: invalid.illegal.token.es
      set: ae_GENERATOR_COMPREHENSION_BEFORE_CLOSE

  ae_GENERATOR_COMPREHENSION_AFTER_EXP:
    - match: 'if{{idEnd}}'
      scope: keyword.control.loop.conditional.if.comprehension.generator.es
      set: ae_GENERATOR_COMPREHENSION_AFTER_IF
    - match: 'for{{idEnd}}'
      scope: keyword.control.loop.for.comprehension.generator.es
      set: ae_GENERATOR_COMPREHENSION_AFTER_FOR
    - match: '{{PLA_anything}}'
      set: [ ae_GENERATOR_COMPREHENSION_BEFORE_CLOSE, expression ]
    - match: '{{MAT_word_or_any_one_char}}'
      scope: invalid.illegal.token.es
      set: ae_GENERATOR_COMPREHENSION_BEFORE_CLOSE

  ae_GENERATOR_COMPREHENSION_AFTER_IF:
    - match: '((\())'
      captures:
        1: punctuation.definition.expression.conditional.comprehension.generator.begin.es
        2: meta.brace.round.js # ^BS
      set: [ ae_GENERATOR_COMPREHENSION_AFTER_IF_EXP, expression ]
    - match: '{{MAT_word_or_any_one_char}}'
      scope: invalid.illegal.token.es
      set: ae_GENERATOR_COMPREHENSION_AFTER_IF_EXP

  ae_GENERATOR_COMPREHENSION_AFTER_IF_EXP:
    - match: '((\)))'
      captures:
        1: punctuation.definition.expression.conditional.comprehension.generator.begin.es
        2: meta.brace.round.js # ^BS
      set: ae_GENERATOR_COMPREHENSION_AFTER_EXP
    - match: '{{MAT_word_or_any_one_char}}'
      scope: invalid.illegal.token.es
      set: ae_GENERATOR_COMPREHENSION_BEFORE_CLOSE

  ae_GENERATOR_COMPREHENSION_BEFORE_CLOSE:
    - match: '((\)))'
      captures:
        1: punctuation.definition.comprehension.generator.end.es
        2: meta.brace.round.js # ^BS
      set: ae_AFTER_THING
    - match: '\('
      scope: invalid.illegal.token.es
      set: ae_GENERATOR_COMPREHENSION_AFTER_EXP_BODY
    - include: other_illegal

  ae_IDENTIFIERS:
    - include: ae_IDENTIFIERS_LANGUAGE
    - match: '(({{identifier}}))\s*(=)\s*(\()(?=(?<parens>[^\(\)]|\(\g<parens>*\))*\)\s*=>)'
      captures:
        1: variable.other.readwrite.es
        2: entity.name.function.arrow.es
        3: keyword.operator.assignment.es
        4: punctuation.definition.parameters.function.arrow.begin.es
      set: [ ae_ARROW_AFTER_PARAMS, parameters ]
    - match: '(({{identifier}}))\s*(=)\s*({{identifier}})\s*(=>)'
      captures:
        1: variable.other.readwrite.es
        2: entity.name.function.arrow.es
        3: keyword.operator.assignment.es
        4: variable.parameter.es
        5: storage.type.function.arrow.es
      set: ae_ARROW_AFTER_ARROW
    - match: '(({{identifier}}))\s*(=)\s*((async))\s+({{identifier}})\s*(=>)'
      captures:
        1: variable.other.readwrite.es
        2: entity.name.function.async.arrow.es
        3: keyword.operator.assignment.es
        4: storage.type.js
        5: storage.modifier.async.expression.es
        6: variable.parameter.es
        7: storage.type.function.arrow.es
      set: ae_ASYNC_ARROW_AFTER_ARROW
    - match: '(({{identifier}}))\s*(=)\s*((async))\s*(\()'
      captures:
        1: variable.other.readwrite.es
        2: entity.name.function.async.arrow.es
        3: keyword.operator.assignment.es
        4: storage.type.js # ^BS
        5: storage.modifier.async.expression.es
        6: punctuation.definition.parameters.function.arrow.begin.es
      set: [ ae_ASYNC_ARROW_AFTER_PARAMS, parameters ]
    - match: '(({{identifier}}))\s*(=)\s*(?=function\s*\*)'
      captures:
        1: variable.other.readwrite.es
        2: entity.name.function.generator.es
        3: keyword.operator.assignment.es
      set: assignmentExpression
    - match: '(({{identifier}}))\s*(=)\s*(?=function{{idEnd}})'
      captures:
        1: variable.other.readwrite.es
        2: entity.name.function.es
        3: keyword.operator.assignment.es
      set: assignmentExpression
    - match: '(({{identifier}}))\s*(=)\s*(?=async\s+function{{idEnd}})'
      captures:
        1: variable.other.readwrite.es
        2: entity.name.function.async.es
        3: keyword.operator.assignment.es
      set: assignmentExpression
    - match: '({{identifier}})\s*(=>)'
      captures:
        1: variable.parameter.es
        2: storage.type.function.arrow.es
      set: ae_ARROW_AFTER_ARROW
    - match: '((async))\s+({{identifier}})\s*(=>)'
      captures:
        1: storage.type.js
        2: storage.modifier.async.expression.es
        3: variable.parameter.es
        4: storage.type.function.arrow.es
      set: ae_ASYNC_ARROW_AFTER_ARROW
    - include: ae_IDENTIFIERS_INTRINSIC
    - include: ae_IDENTIFIERS_ENVIRONMENTAL
    - match: '((({{identifierAllCapsStrict}})))\s*((\())'
      captures:
        1: variable.other.readwrite.allCap.es # -BS
        2: meta.function-call # ^BS
        3: meta.invocation.es
        4: punctuation.definition.arguments.begin.es
        5: meta.brace.round.js # ^BS
      set: [ ae_AFTER_THING, arguments ]
    - match: '{{identifierAllCapsStrict}}'
      scope: variable.other.readwrite.allCap.es # -BS
      set: ae_AFTER_IDENTIFIER
    - match: '((({{identifierInitCapStrict}})))\s*((\())'
      captures:
        1: variable.other.readwrite.initCap.es
        2: meta.function-call # ^BS
        3: meta.invocation.es
        4: punctuation.definition.arguments.begin.es
        5: meta.brace.round.js # ^BS
      set: [ ae_AFTER_THING, arguments ]
    - match: '{{identifierInitCapStrict}}'
      scope: variable.other.readwrite.initCap.es
      set: ae_AFTER_IDENTIFIER
    - match: '((({{identifier}})))\s*((\())'
      captures:
        1: variable.other.readwrite.es
        2: meta.function-call # ^BS
        3: meta.invocation.es
        4: punctuation.definition.arguments.begin.es
        5: meta.brace.round.js # ^BS
      set: [ ae_AFTER_THING, arguments ]
    - match: '{{identifier}}'
      scope: variable.other.readwrite.es
      set: ae_AFTER_IDENTIFIER

  ae_IDENTIFIERS_LANGUAGE:
    # THIS
    - match: '(((this)))\s*((\())'
      captures:
        1: variable.language.this.es
        2: meta.function-call # ^BS
        3: meta.invocation.es
        4: punctuation.definition.arguments.begin.es
        5: meta.brace.round.js # ^BS
      set: [ ae_AFTER_THING, arguments ]
    - match: 'this{{idEnd}}'
      scope: variable.language.this.es
      set: ae_AFTER_THING
    # SUPER
    - match: '(((super)))\s*((\())'
      captures:
        1: variable.language.super.es
        2: meta.function-call # ^BS
        3: meta.invocation.es
        4: punctuation.definition.arguments.begin.es
        5: meta.brace.round.js # ^BS
      set: [ ae_AFTER_THING, arguments ]
    - match: 'super{{idEnd}}'
      scope: variable.language.super.es
      set: ae_AFTER_THING
    # IMPORT META
    - match: 'import\s*\.\s*meta\b'
      scope: variable.language.import-meta
      set: ae_AFTER_VALUE
    # DYNAMIC IMPORT
    - match: 'import\s*\('
      scope: variable.language.import-dynamic
      set:
        - - match: '\)'
            scope: variable.language.import-dynamic
            set: ae_AFTER_THING
          - include: other_illegal
        - - include: assignmentExpression
    # ARGUMENTS
    - match: 'arguments{{idEnd}}'
      scope: variable.language.arguments.es
      set: ae_AFTER_THING

  ae_IDENTIFIERS_ENVIRONMENTAL:
    # NODE CONSTRUCTORS
    - match: '((((Buffer)))\s*)((\())'
      captures:
        1: variable.other.readwrite.es
        2: meta.instance.constructor entity.name.type.new # ^BS
        3: meta.instantiation.es
        4: support.class.node.es
        5: punctuation.definition.arguments.begin.es
        6: meta.brace.round.js # ^BS
      set: [ ae_AFTER_THING, arguments ]
    - match: '(Buffer){{idEnd}}'
      scope: variable.other.readwrite.es
      captures:
        1: support.class.node.es
      set: ae_AFTER_THING
    # NODE FUNCTIONS
    # Or function, rather. This may also be a useful scope for AMD users.
    - match: '(((require)))\s*((\())'
      captures:
        1: meta.function-call # ^BS
        2: meta.invocation.es
        3: support.function.node.require.es
        4: punctuation.definition.arguments.begin.es
        5: meta.brace.round.js # ^BS
      set: [ ae_AFTER_THING, arguments ]
    # NODE OBJECTS
    # Omitted ‘root’ intentionally (identifier too common). ‘require’ makes a
    # second appearance moonlighting as a namespace object.
    - match: '(global|GLOBAL|process|__(?:dir|file)name|require){{idEnd}}'
      scope: support.variable.node.es
      set: ae_AFTER_THING
    - match: '(?:(module)(?:(\.)(exports))?|(exports)){{idEnd}}'
      captures:
        1: support.variable.node.module.es
        2: keyword.operator.accessor.es
        3: support.variable.node.module.es
        4: support.variable.node.module.es
      set: ae_AFTER_THING
    # VERY SPECIAL LIBRARIES OF LEGEND
    # This is iffy territory for me. The criteria should be clear though. These
    # are libraries with iconic identifiers that, even if used for something
    # else, are nonetheless likely to be ‘highlight worthy’ because of their
    # uniqueness. Either they have become so synonymous with their purposes that
    # multiple libraries in the same domain use them as a kind of signal, and
    # they are often used as extensions to the language itself, or else the name
    # is sufficiently unique that it is safe to not fret over ‘collision’.
    #
    # UNDERSCORE, LODASH & RAMDA
    # The inclusion of Ramda’s R is very questionable, I admit. It doesn’t yet
    # meet the criteria I just gave. On the other hand it’s not a very likely
    # identifier for other things and it’s quickly becoming a common functional
    # language extension. I’m going back and forth on this one still.
    - match: '(_|R){{idEnd}}'
      scope: support.variable.functional-library.es
      set: ae_AFTER_THING
    # JQUERY, ZEPTO, PROTOTYPE & MOOTOOLS; ALSO MAJOR FRAMEWORKS
    - match: '(?:\$|angular|Polymer|React(DOM)?){{idEnd}}'
      scope: support.variable.dom-library.es
      set: ae_AFTER_THING
    # HELLSCAPE OBJECTS
    # This is deliberately minimal. The browser environment has literally
    # hundreds of global objects / window properties. In a way I feel like the
    # DOM is so ‘specific’ of a domain and yet its area is so wide that I’m
    # loathe to include it at all; even in this small list, I have reservations
    # about identifiers so generic as ‘history’ and ‘location’ which are just as
    # likely to show up in non-browser contexts. In any case, the following are
    # the items that seem to be considered ‘core’ global objects, while
    # everything else (perhaps?) is better understood as a window property.
    - match: '(document|frames|history|location|navigator|screen|window){{idEnd}}'
      scope: support.variable.dom.es
      set: ae_AFTER_THING

  ae_IDENTIFIERS_INTRINSIC:
    # CONSTRUCTORS
    - match: '(((({{intrinsicConstructors}})))\s*)((\())'
      captures:
        1: variable.other.readwrite.es
        2: meta.instance.constructor # ^BS
        3: meta.instantiation.es
        4: support.class.builtin.es
        5: punctuation.definition.arguments.begin.es
        6: meta.brace.round.js # ^BS
      set: [ ae_AFTER_THING, arguments ]
    - match: '(?x) ({{intrinsicConstructors}}){{idEnd}}'
      scope: variable.other.readwrite.es
      captures:
        1: support.class.builtin.es
      set: ae_AFTER_THING
    # OBJECTS
    # Console is not technically intrinsic, but it may as well be.
    - match: '(?:console|Intl|JSON|Math|SIMD){{idEnd}}'
      scope: support.variable.builtin.es
      set: ae_AFTER_THING
    # FUNCTIONS
    # The timeout-related functions are also not technically intrinsic but are
    # included here as ‘de facto’ intrinsic as well.
    - match: '(?x) ((( {{intrinsicFunctions}} )))\s*((\())'
      captures:
        1: meta.function-call # ^BS
        2: meta.invocation.es
        3: support.function.builtin.es
        4: punctuation.definition.arguments.begin.es
        5: meta.brace.round.js # ^BS
      set: [ ae_AFTER_THING, arguments ]
    - match: '(?x) ({{intrinsicFunctions}}){{idEnd}}'
      scope: support.function.builtin.es
      set: ae_AFTER_THING

  ae_INFIX_OPS:
    # TERNARY
    - match: '\?'
      scope: keyword.operator.ternary.if.es
      set: ae_TERNARY_AFTER_QUESTION
    # ARITHMETIC
    - match: '\+(?!=)'
      scope: keyword.operator.arithmetic.addition.es
      set: assignmentExpression
    - match: '-(?!=)'
      scope: keyword.operator.arithmetic.subtraction.es
      set: assignmentExpression
    - match: '\*\*(?!=)'
      scope: keyword.operator.arithmetic.exponentiation.es
      set: assignmentExpression
    # The lookaheads here (aside from the first) are an awkward way to prevent
    # bad matching when a decorator is followed by a generator. It’s imperfect,
    # but exceptional cases should be rare. I think the final decorator syntax
    # will need to be far more restrictive because these problems, while worse
    # for us, are also going to affect real parsers.
    - match: >-
        (?x)
          \*
          (?! [=\*])
          (?! \s* " [^"]+ " \s* \( )
          (?! \s* '' [^'']+ '' \s* \( )
          (?! \s* \[ [\]]+ \] \s* \( )
          (?! \s* {{identifier}} \s* \([^)]*\) \s* \{)
      scope: keyword.operator.arithmetic.multiplication.es
      set: assignmentExpression
    - match: '\/(?!=)'
      scope: keyword.operator.arithmetic.division.es
      set: assignmentExpression
    - match: '%(?!=)'
      scope: keyword.operator.arithmetic.modulo.es
      set: assignmentExpression
    # EQUALITY
    - match: '==='
      scope: keyword.operator.comparison.equality.strict.es
      set: assignmentExpression
    - match: '=='
      scope: keyword.operator.comparison.equality.coercive.es
      set: assignmentExpression
    - match: '!=='
      scope: keyword.operator.comparison.non-equality.strict.es
      set: assignmentExpression
    - match: '!='
      scope: keyword.operator.comparison.non-equality.coercive.es
      set: assignmentExpression
    # LOGICAL
    - match: '&&'
      scope: keyword.operator.logical.and.es
      set: assignmentExpression
    - match: '\|\|(?!=)'
      scope: keyword.operator.logical.or.es
      set: assignmentExpression
    # BITWISE LOGICAL
    - match: '&(?!=)'
      scope: keyword.operator.bitwise.logical.and.es
      set: assignmentExpression
    - match: '\|(?![=\|])'
      scope: keyword.operator.bitwise.logical.or.es
      set: assignmentExpression
    - match: '\^(?!=)'
      scope: keyword.operator.bitwise.logical.xor.es
      set: assignmentExpression
    # BITWISE SHIFT
    - match: '<<(?!=)'
      scope: keyword.operator.bitwise.shift.left.es
      set: assignmentExpression
    - match: '>>>(?!=)'
      scope: keyword.operator.bitwise.shift.right.unsigned.es
      set: assignmentExpression
    - match: '>>(?![=>])'
      scope: keyword.operator.bitwise.shift.right.es
      set: assignmentExpression
    # RELATIONAL
    - match: '<='
      scope: keyword.operator.relational.lte.es
      set: assignmentExpression
    - match: '<'
      scope: keyword.operator.relational.lt.es
      set: assignmentExpression
    - match: '>='
      scope: keyword.operator.relational.gte.es
      set: assignmentExpression
    - match: '>'
      scope: keyword.operator.relational.gt.es
      set: assignmentExpression
    - match: 'instanceof{{idEnd}}'
      scope: keyword.operator.relational.instanceof.es
      set: assignmentExpression
    - match: 'in{{idEnd}}'
      scope: keyword.operator.relational.in.es
      set: assignmentExpression
    # BINDING
    - match: '::'
      scope: keyword.operator.bind.es
      set: assignmentExpression

  ae_INFIX_OPS_ASSIGNMENT:
    # VANILLA
    - match: '=(?!=)'
      scope: keyword.operator.assignment.es
      set: assignmentExpression
    # ARITHMETIC
    - match: '\+='
      scope: keyword.operator.assignment.augmented.arithmetic.addition.es
      set: assignmentExpression
    - match: '-='
      scope: keyword.operator.assignment.augmented.arithmetic.subtraction.es
      set: assignmentExpression
    - match: '\*\*='
      scope: keyword.operator.assignment.augmented.arithmetic.exponentiation.es
      set: assignmentExpression
    - match: '\*='
      scope: keyword.operator.assignment.augmented.arithmetic.multiplication.es
      set: assignmentExpression
    - match: '\/='
      scope: keyword.operator.assignment.augmented.arithmetic.division.es
      set: assignmentExpression
    - match: '%='
      scope: keyword.operator.assignment.augmented.arithmetic.modulo.es
      set: assignmentExpression
    # MALLET
    - match: '\|\|='
      scope: keyword.operator.assignment.conditional.mallet.es
      set: assignmentExpression
    # BITWISE LOGICAL
    - match: '&='
      scope: keyword.operator.assignment.augmented.bitwise.logical.and.es
      set: assignmentExpression
    - match: '\^='
      scope: keyword.operator.assignment.augmented.bitwise.logical.xor.es
      set: assignmentExpression
    - match: '\|='
      scope: keyword.operator.assignment.augmented.bitwise.logical.or.es
      set: assignmentExpression
    # BITWISE SHIFT
    - match: '<<='
      scope: keyword.operator.assignment.augmented.bitwise.shift.left.es
      set: assignmentExpression
    - match: '>>>='
      scope: keyword.operator.assignment.augmented.bitwise.shift.right.unsigned.es
      set: assignmentExpression
    - match: '>>='
      scope: keyword.operator.assignment.augmented.bitwise.shift.right.es
      set: assignmentExpression

  ae_LITERAL_VALUES:
    # Technically ‘undefined’ and ‘Infinity’ aren’t language constants, but it’s
    # totally reasonable to scope them as such since this odd fact is just a bit
    # of legacy bs. In modern implementions they can’t be redefined (although
    # the assignment is itself a legal operation, fun fact).
    - match: 'NaN(?![{{ID_Continue}}])'
      scope: constant.language.nan.es
      set: ae_AFTER_VALUE
    - match: 'null(?![{{ID_Continue}}])'
      scope: constant.language.null.es
      set: ae_AFTER_VALUE
    - match: 'true(?![{{ID_Continue}}])'
      scope: constant.language.boolean.true.es
      set: ae_AFTER_VALUE
    - match: 'false(?![{{ID_Continue}}])'
      scope: constant.language.boolean.false.es
      set: ae_AFTER_VALUE
    - match: 'Infinity(?![{{ID_Continue}}])'
      scope: constant.language.infinity.es
      set: ae_AFTER_VALUE
    - match: 'undefined(?![{{ID_Continue}}])'
      scope: constant.language.undefined.es
      set: ae_AFTER_VALUE

  ae_NUMBERS:
    - match: '{{decNum}}'
      scope: constant.numeric.decimal.es
      captures:
        1: punctuation.decimal.es
        2: punctuation.decimal.es
        3: punctuation.decimal.es
        4: meta.numeric.exponent.e.es
        5: meta.numeric.exponent.sign.es
        6: meta.numeric.exponent.digit.es
      set: ae_AFTER_VALUE
    - match: '{{binNum}}'
      scope: constant.numeric.binary.es
      captures:
        1: meta.numeric.prefix.es
      set: ae_AFTER_VALUE
    - match: '{{octNum}}'
      scope: constant.numeric.octal.es
      captures:
        1: meta.numeric.prefix.es
      set: ae_AFTER_VALUE
    - match: '{{hexNum}}'
      scope: constant.numeric.hexadecimal.es
      captures:
        1: meta.numeric.prefix.es
      set: ae_AFTER_VALUE

  ae_OBJECT_ARRAY_BINDING:
    # Of all the ‘only works without naughty linebreak’ cases, this is the most
    # problematic, simply because unlike the others, it’s quite plausible that
    # a binding pattern could span multiple lines. Not an everyday thing, sure,
    # but I can imagine circumstances where it might make sense. I haven’t yet
    # worked out the best way to deal with this, but I think what we could do
    # is handle certain (normally illegal) tokens in obj/arr literals and
    # switch to binding at that point. You’d have the wrong scopes at the start,
    # but at least no ‘illegal’ sections.
    #
    # Note that ‘ae_AFTER_THING’ is fine since = is preestablished as the next
    # character.
    - match: '(?x) ((\{)) (?= (?<brackets> [^\{\}] | \{ \g<brackets>* \} )* \}\s*=[^=])'
      captures:
        1: punctuation.definition.binding.object.begin.es
        2: meta.brace.curly.js # ^BS
      set: [ ae_AFTER_THING, bindingObject ]
    - match: '(?x) ((\[)) (?= (?<brackets> [^\[\]] | \[ \g<brackets>* \] )* \]\s*=[^=])'
      captures:
        1: punctuation.definition.binding.array.begin.es
        2: meta.brace.square.js # ^BS
      set: [ ae_AFTER_THING, bindingArray ]

  ae_OBJECT_ARRAY_LITERAL:
    - match: '((\{))'
      captures:
        1: punctuation.definition.object.begin.es
        2: meta.brace.curly.js # ^BS
      set: [ ae_OBJECT_ARRAY_LITERAL_END, literalObject_OPEN ]
    - match: '((\[))'
      captures:
        1: punctuation.definition.array.begin.es
        2: meta.brace.square.js # ^BS
      set: [ ae_OBJECT_ARRAY_LITERAL_END, literalArray_OPEN ]

  ae_OBJECT_ARRAY_LITERAL_END:
    # Attempt recovery if this was actually a multiline binding pattern.
    - match: '=(?!=)'
      scope: keyword.operator.assignment.es
      set: assignmentExpression
    - include: ae_AFTER_VALUE

  ae_PARENTHESIZED:
    - match: '((\())'
      captures:
        1: punctuation.definition.expression.begin.es
        2: meta.brace.round.js # ^BS
      set: ae_PARENTHESIZED_AFTER_OPEN

  ae_PARENTHESIZED_AFTER_OPEN:
    # Note that we transition to ae_AFTER_IDENTIFIER. This is deliberate; it
    # allows us to recover from erroneous scoping if the parenthesized
    # expression was actually the parameters of an arrow function whose arrow
    # token was not on the same line as the opening parenthesis.
    - match: '((\)))'
      captures:
        1: punctuation.definition.expression.end.es
        2: meta.brace.round.js # ^BS
      set: ae_AFTER_IDENTIFIER
    - match: '{{PLA_anything}}'
      push: expression

  ae_POSTFIX_OPS:
    # Always wondered: why do we say ‘postfix’ instead of ‘suffix’?
    - match: '\+\+'
      scope: keyword.operator.arithmetic.increment.postfix.es
      set: ae_AFTER_POSTFIX
    - match: '--'
      scope: keyword.operator.arithmetic.decrement.postfix.es
      set: ae_AFTER_POSTFIX

  ae_PREFIX_OPS:
    # Note that these matches do not cause a context transition.
    - match: 'delete{{idEnd}}'
      scope: keyword.operator.unary.delete.es
    - match: 'void{{idEnd}}'
      scope: keyword.operator.unary.void.es
    - match: 'typeof{{idEnd}}'
      scope: keyword.operator.unary.typeof.es
    - match: '\+\+'
      scope: keyword.operator.arithmetic.increment.prefix.es
    - match: '\+'
      scope: keyword.operator.arithmetic.sign.positive.es
    - match: '--'
      scope: keyword.operator.arithmetic.decrement.prefix.es
    - match: '-'
      scope: keyword.operator.arithmetic.sign.negative.es
    - match: '~'
      scope: keyword.operator.bitwise.logical.not.es
    - match: '(!!)'
      scope: keyword.operator.logical.not.es
      captures:
        1: meta.idiomatic-cast.boolean.es
    - match: '!'
      scope: keyword.operator.logical.not.es
    - match: '::'
      scope: keyword.operator.bind.es
    # The current strawman spec suggests this is the reasonable place for await.
    # Syntactically, it isn’t like yield. I’m unsure if this is intended to be a
    # no-linebreak-here situation. Babel currently gets upset by newlines before
    # the operand, but the spec doesn’t say anything about this.
    - match: 'await{{idEnd}}'
      scope: keyword.control.flow.await

  ae_STRING_REGEX:
    - match: "'"
      scope: punctuation.definition.string.quoted.single.begin.es
      set: [ ae_AFTER_VALUE, stringSingle_AFTER_OPEN ]
    - match: '"'
      scope: punctuation.definition.string.quoted.double.begin.es
      set: [ ae_AFTER_VALUE, stringDouble_AFTER_OPEN ]
    - match: '`'
      scope: punctuation.definition.string.interpolated.begin.es
      set: [ ae_AFTER_VALUE, templateString_AFTER_OPEN ]
    - match: '\/'
      scope: punctuation.definition.string.regexp.begin.es
      set: [ ae_AFTER_VALUE, regex_AFTER_OPEN ]
    - match: '((({{identifier}})))\s*(`)'
      captures:
        1: entity.quasi.tag.name.js # ^BS
        2: variable.other.readwrite.tag.es
        3: punctuation.definition.string.interpolated.begin.es
      set: [ ae_AFTER_VALUE, templateString_AFTER_OPEN ]

  ae_TERNARY_AFTER_QUESTION:
    - match: ':'
      scope: invalid.illegal.token.es
      set: assignmentExpression
    - match: '{{PLA_anything}}'
      set: [ ae_TERNARY_AFTER_IF_CASE, assignmentExpression ]

  ae_TERNARY_AFTER_IF_CASE:
    - match:  ':'
      scope: keyword.operator.ternary.else.es
      set: assignmentExpression
    - include: other_illegal_pop

  ae_YIELD_NEW:
    # Grouped simply because they both have weird rules. Yield is unique
    # because it’s the only time ‘assignment expression or nothing’ is valid.
    # New is weird because, as of ES6, it’s both an operator and, contextually,
    # a ... well, a token in a series of three tokens that resolves to a
    # reference and appears to be property access but actually is a composite
    # language keyword which may contain an arbitrary amount of whitespace and
    # newlines.
    #
    # Congratulations on your new Wat()...
    #
    #   new                               .                          target
    #   ,                                new                        .target
    #   ,                                new                              .
    #   target,                          new
    #                                  .target,
    #   new                            .target,                         new
    #                .                target,new                .
    #   target,     new                .target,                new        .
    #   target,     new                .target,                new        .
    #              target,            new.target              ,new.
    #              target,            new.target,     new   .target,
    #   new       .target,          new.target,new          .target,
    #            new.target,        new.target,new          .target,
    #            new.target,      new . target, new.       target,new
    #            . target ,       new . target ,new.       new.target,
    #            new.target,     new.target,new.target    ,new.target,
    #           new .target, new.target,new. target ,new. target, new.
    #          target,new . target,new. target,new .target,new. target,
    #          new . target,new . target,new . target,new . target,new
    #        .target,new. target,new.target new .target ,new.target,new.
    #        target,new .target,new.target , new. target,new .target,new
    #                          .target == ANGKOR WAT
    - match: >-
        (?x)
          (new) \s+ (((
            ( Buffer ) |
            ( {{intrinsicConstructors}} ) |
            {{identifier}}
          ))){{idEnd}}(?!\s*\.)
      captures:
        1: keyword.operator.new.es
        2: variable.other.readwrite.es
        3: meta.instance.constructor entity.name.type.new # ^BS
        4: meta.instantiation.es
        5: support.class.node.es
        6: support.class.builtin.es
      set: ae_AFTER_THING
    # When the constructor is a property it’s tougher. Rather than creating a
    # new set of contexts for this case, we’ll handle up to the fifth level and
    # consider anything else a rare enough edge case to not worry about.
    - match: >-
        (?x)
          (new) \s+
          (?: ({{identifier}}) (\.) )
          (?: ({{identifier}}) (\.)
            (?: ({{identifier}}) (\.)
              (?:
                ({{identifier}}) (\.)
              )?
            )?
          )?
          ((({{identifier}})))(?!\s*\.)
      captures:
        1: keyword.operator.new.es
        2: variable.other.readwrite.es
        3: keyword.operator.accessor.es
        4: variable.other.readwrite.es
        5: keyword.operator.accessor.es
        6: variable.other.readwrite.es
        7: keyword.operator.accessor.es
        8: variable.other.readwrite.es
        9: keyword.operator.accessor.es
        10: variable.other.readwrite.es
        11: meta.instance.constructor entity.name.type.new # ^BS, augmented
        12: meta.instantiation.es
      set: ae_AFTER_THING
    - match: '(new)\s*(\.)'
      captures:
        1: variable.language.new-target.fake-object.es
        2: variable.language.new-target.fake-accessor.es
      set: ae_YIELD_NEW_AFTER_NEW_WAT
    - match: 'new{{idEnd}}'
      scope: keyword.operator.new.es
      set: ae_YIELD_NEW_AFTER_NEW_OPERATOR
    - match: 'yield{{idEnd}}'
      scope: keyword.control.flow.yield.es
      set: ae_YIELD_NEW_AFTER_YIELD

  ae_YIELD_NEW_AFTER_YIELD:
    - match: '\*'
      scope: keyword.control.flow.yield.iterate.es # -BS
      set: assignmentExpression
    - match: '$'
      pop: true
    - include: assignmentExpression_CORE
    - include: else_pop

  ae_YIELD_NEW_AFTER_NEW_OPERATOR:
    # Newlines are permitted, so it’s ‘possible’ that the previously matched
    # ‘new operator’ was actually a reference to the ‘new object’. Hey, I try to
    # be rigorous.
    - match: '\.'
      scope: variable.language.new-target.fake-accessor.es
      set: ae_YIELD_NEW_AFTER_NEW_WAT
    - include: assignmentExpression

  ae_YIELD_NEW_AFTER_NEW_WAT:
    - match: 'target{{idEnd}}'
      scope: variable.language.new-target.fake-property.es
      set: ae_AFTER_THING
    - match: '{{MAT_word_or_any_one_char}}'
      scope: invalid.illegal.token.es
      set: ae_AFTER_ACCESSOR_OPERATOR

################################################################################
################################################################################
################################################################################
#   DO NOT UPDATE THIS SECTION DIRECTLY -- IT SHOULD ALWAYS MIRROR THE ABOVE   #
#   BUT WITH _NO_IN -- and no "in". (Though prefix ops can be reused). Just    #
#   F&R and re-paste over this. I may just add a build script to handle this   #
#   later.                                                                     #
################################################################################

  assignmentExpression_NO_IN:
    - include: assignmentExpression_NO_IN_CORE
    - include: other_illegal_pop
  assignmentExpression_NO_IN_CORE:
    - include: ae_NO_IN_LITERAL_VALUES
    - include: ae_NO_IN_NUMBERS
    - include: ae_NO_IN_STRING_REGEX
    - include: ae_NO_IN_ARRAY_COMPREHENSION
    - include: ae_NO_IN_OBJECT_ARRAY_BINDING
    - include: ae_NO_IN_OBJECT_ARRAY_LITERAL
    - include: ae_NO_IN_YIELD_NEW
    - include: ae_NO_IN_FUNCTION_GENERATOR_CLASS
    - include: ae_PREFIX_OPS
    - include: ae_NO_IN_ARROW
    - include: ae_NO_IN_IDENTIFIERS
    - include: ae_NO_IN_GENERATOR_COMPREHENSION
    - include: ae_NO_IN_PARENTHESIZED
    - include: ae_NO_IN_DO
  ae_NO_IN_AFTER_IDENTIFIER:
    - match: '=>'
      scope: storage.type.function.arrow.es
      set: ae_NO_IN_ARROW_AFTER_ARROW
    - include: ae_NO_IN_AFTER_THING
  ae_NO_IN_AFTER_THING:
    - match: '((\())'
      captures:
        1: punctuation.definition.arguments.begin.es
        2: meta.brace.round.js
      push: arguments
    - match: '`'
      scope: punctuation.definition.string.interpolated.begin.es
      set: [ ae_NO_IN_AFTER_VALUE, templateString_AFTER_OPEN ]
    - include: ae_NO_IN_POSTFIX_OPS
    - include: ae_NO_IN_INFIX_OPS_ASSIGNMENT
    - include: ae_NO_IN_AFTER_VALUE
  ae_NO_IN_AFTER_VALUE:
    - match: '\.'
      scope: keyword.operator.accessor.es
      set: ae_NO_IN_AFTER_ACCESSOR_OPERATOR
    - match: '((\[))'
      captures:
        1: punctuation.definition.accessor.begin.es
        2: meta.brace.square.js
      set: [ ae_NO_IN_AFTER_THING, computedProp_AFTER_AE, assignmentExpression_NO_IN ]
    - include: ae_NO_IN_INFIX_OPS
    - include: ae_NO_IN_AFTER_POSTFIX
  ae_NO_IN_AFTER_POSTFIX:
    - include: ae_NO_IN_INFIX_OPS
    - include: else_pop
  ae_NO_IN_AFTER_ACCESSOR_OPERATOR:
    - match: '((({{identifierAllCaps}})))\s*((\())'
      captures:
        1: variable.other.readwrite.property.allCap.es
        2: meta.function-call
        3: meta.invocation.es
        4: punctuation.definition.arguments.begin.es
        5: meta.brace.round.js
      set: [ ae_NO_IN_AFTER_THING, arguments ]
    - match: '((({{identifierInitCap}})))\s*((\())'
      captures:
        1: variable.other.readwrite.property.initCap.es
        2: meta.function-call
        3: meta.invocation.es
        4: punctuation.definition.arguments.begin.es
        5: meta.brace.round.js
      set: [ ae_NO_IN_AFTER_THING, arguments ]
    - match: '((({{identifierName}})))\s*((\())'
      captures:
        1: variable.other.readwrite.property.es
        2: meta.function-call
        3: meta.invocation.es
        4: punctuation.definition.arguments.begin.es
        5: meta.brace.round.js
      set: [ ae_NO_IN_AFTER_THING, arguments ]
    - match: '(prototype){{idEnd}}'
      scope: variable.other.readwrite.property.prototype.es
      captures:
        1: variable.language.prototype.es
      set: ae_NO_IN_AFTER_THING
    - match: '(__proto__){{idEnd}}'
      scope: variable.other.readwrite.property.proto.es
      captures:
        1: variable.language.proto.es
      set: ae_NO_IN_AFTER_THING
    - match: '{{identifierName}}'
      scope: variable.other.readwrite.property.es
      set: ae_NO_IN_AFTER_THING
    - include: other_illegal_pop
  ae_NO_IN_ARRAY_COMPREHENSION:
    - match: '((\[))\s*(for){{idEnd}}'
      captures:
        1: punctuation.definition.comprehension.array.begin.es
        2: meta.brace.square.js
        3: keyword.control.loop.for.comprehension.array.es
      set: ae_NO_IN_ARRAY_COMPREHENSION_AFTER_FOR
  ae_NO_IN_ARRAY_COMPREHENSION_AFTER_FOR:
    - match: '((\())'
      captures:
        1: punctuation.definition.expression.loop.comprehension.array.begin.es
        2: meta.brace.round.js
      set: [ ae_NO_IN_ARRAY_COMPREHENSION_AFTER_LHSE, assignmentExpression_NO_IN ]
    - match: '{{MAT_word_or_any_one_char}}'
      scope: invalid.illegal.token.es
      set: ae_NO_IN_ARRAY_COMPREHENSION_BEFORE_CLOSE
  ae_NO_IN_ARRAY_COMPREHENSION_AFTER_LHSE:
    - match: 'of{{idEnd}}'
      scope: keyword.control.loop.of.comprehension.array.es
      set: [ ae_NO_IN_ARRAY_COMPREHENSION_AFTER_EXP_BODY, expression ]
    - match: '{{MAT_word_or_any_one_char}}'
      scope: invalid.illegal.token.es
      set: ae_NO_IN_ARRAY_COMPREHENSION_AFTER_EXP_BODY
  ae_NO_IN_ARRAY_COMPREHENSION_AFTER_EXP_BODY:
    - match: '((\)))'
      captures:
        1: punctuation.definition.expression.loop.comprehension.array.begin.es
        2: meta.brace.round.js
      set: ae_NO_IN_ARRAY_COMPREHENSION_AFTER_EXP
    - match: '{{MAT_word_or_any_one_char}}'
      scope: invalid.illegal.token.es
      set: ae_NO_IN_ARRAY_COMPREHENSION_BEFORE_CLOSE
  ae_NO_IN_ARRAY_COMPREHENSION_AFTER_EXP:
    - match: 'if{{idEnd}}'
      scope: keyword.control.loop.conditional.if.comprehension.array.es
      set: ae_NO_IN_ARRAY_COMPREHENSION_AFTER_IF
    - match: 'for{{idEnd}}'
      scope: keyword.control.loop.for.comprehension.array.es
      set: ae_NO_IN_ARRAY_COMPREHENSION_AFTER_FOR
    - match: '{{PLA_anything}}'
      set: [ ae_NO_IN_ARRAY_COMPREHENSION_BEFORE_CLOSE, expression ]
    - match: '{{MAT_word_or_any_one_char}}'
      scope: invalid.illegal.token.es
      set: ae_NO_IN_ARRAY_COMPREHENSION_BEFORE_CLOSE
  ae_NO_IN_ARRAY_COMPREHENSION_AFTER_IF:
    - match: '((\())'
      captures:
        1: punctuation.definition.expression.conditional.comprehension.array.begin.es
        2: meta.brace.round.js
      set: [ ae_NO_IN_ARRAY_COMPREHENSION_AFTER_IF_EXP, expression ]
    - match: '{{MAT_word_or_any_one_char}}'
      scope: invalid.illegal.token.es
      set: ae_NO_IN_ARRAY_COMPREHENSION_AFTER_IF_EXP
  ae_NO_IN_ARRAY_COMPREHENSION_AFTER_IF_EXP:
    - match: '((\)))'
      captures:
        1: punctuation.definition.expression.conditional.comprehension.array.begin.es
        2: meta.brace.round.js
      set: ae_NO_IN_ARRAY_COMPREHENSION_AFTER_EXP
    - match: '{{MAT_word_or_any_one_char}}'
      scope: invalid.illegal.token.es
      set: ae_NO_IN_ARRAY_COMPREHENSION_BEFORE_CLOSE
  ae_NO_IN_ARRAY_COMPREHENSION_BEFORE_CLOSE:
    - match: '((\]))'
      captures:
        1: punctuation.definition.comprehension.array.end.es
        2: meta.brace.square.js
      set: ae_NO_IN_AFTER_VALUE
    - include: other_illegal
  ae_NO_IN_ARROW:
    - match: '(?x) \( (?= (?<parens> [^\(\)] | \( \g<parens>* \) )* \)\s*=> )'
      scope: punctuation.definition.parameters.function.arrow.begin.es
      set: [ ae_NO_IN_ARROW_AFTER_PARAMS, parameters ]
    - match: '((async))\s*(\()'
      captures:
        1: storage.type.js
        2: storage.modifier.async.expression.es
        3: punctuation.definition.parameters.function.arrow.begin.es
      set: [ ae_NO_IN_ARROW_AFTER_PARAMS, parameters ]
  ae_NO_IN_ARROW_AFTER_PARAMS:
    - match: '\)'
      scope: punctuation.definition.parameters.function.arrow.end.es
      set: ae_NO_IN_ARROW_BEFORE_ARROW
    - include: other_illegal_pop
  ae_NO_IN_ARROW_BEFORE_ARROW:
    - match: '=>'
      scope: storage.type.function.arrow.es
      set: ae_NO_IN_ARROW_AFTER_ARROW
    - include: other_illegal_pop
  ae_NO_IN_ARROW_AFTER_ARROW:
    - match: '((\{))'
      captures:
        1: punctuation.definition.function.arrow.body.begin.es
        2: meta.brace.curly.js
      set: ae_NO_IN_ARROW_AFTER_BRACE
    - match: '{{PLA_anything}}'
      set: assignmentExpression_NO_IN
  ae_NO_IN_ARROW_AFTER_BRACE:
    - match: '((\}))'
      captures:
        1: punctuation.definition.function.arrow.body.end.es
        2: meta.brace.curly.js
      set: ae_NO_IN_AFTER_THING
    - include: useStrict
    - include: statements
    - include: other_illegal
  ae_NO_IN_CLASS_AFTER_CLASS:
    - match: '((\{))'
      captures:
        1: punctuation.definition.class.body.begin.es
        2: meta.brace.curly.js
      set: [ ae_NO_IN_AFTER_THING, classDeclaration_AFTER_BRACE ]
    - match: '((extends)){{idEnd}}'
      captures:
        1: storage.type.extends.js
        2: storage.modifier.extends.es
      set: [ ae_NO_IN_AFTER_THING, classDeclaration_AFTER_HERITAGE, assignmentExpression_NO_IN ]
    - match: '(({{identifier}}))'
      captures:
        1: entity.name.class.js
        2: entity.name.class.es
      set: [ ae_NO_IN_AFTER_THING, classDeclaration_AFTER_NAME ]
    - include: other_illegal_pop
  ae_NO_IN_DO:
    - match: 'do{{idEnd}}'
      scope: keyword.control.do-expression.do.es
      set: [ ae_NO_IN_AFTER_THING, ae_DO_AFTER_DO ]
  ae_NO_IN_FUNCTION_GENERATOR_CLASS:
    - match: 'function\s*\.\s*sent'
      scope: variable.language.function-sent.es
      set: ae_NO_IN_AFTER_THING
    - match: '((function))\s*((\*))'
      captures:
        1: storage.type.function.js
        2: storage.type.function.generator.expression.es
        3: keyword.generator.asterisk.js
        4: storage.modifier.generator.asterisk.expression.es
      set: ae_NO_IN_GENERATOR_AFTER_ASTERISK
    - match: '((async))?\s*((function)){{idEnd}}'
      captures:
        1: storage.type.js
        2: storage.modifier.async.expression.es
        3: storage.type.function.js
        4: storage.type.function.expression.es
      set: ae_NO_IN_FUNCTION_AFTER_FUNCTION
    - match: 'class{{idEnd}}'
      scope: storage.type.class.expression.es
      set: ae_NO_IN_CLASS_AFTER_CLASS
  ae_NO_IN_FUNCTION_AFTER_FUNCTION:
    - match: '\('
      scope: punctuation.definition.parameters.function.begin.es
      set: [ ae_NO_IN_AFTER_THING, functionDeclaration_AFTER_PARAMS, parameters ]
    - match: '{{identifier}}'
      scope: entity.name.function.es
      set: [ ae_NO_IN_AFTER_THING, functionDeclaration_AFTER_NAME ]
    - include: other_illegal_pop
  ae_NO_IN_GENERATOR_AFTER_ASTERISK:
    - match: '\('
      scope: punctuation.definition.parameters.generator.begin.es
      set: [ ae_NO_IN_AFTER_THING, generatorDeclaration_AFTER_PARAMS, parameters ]
    - match: '{{identifier}}'
      scope: entity.name.function.generator.es
      set: [ ae_NO_IN_AFTER_THING, generatorDeclaration_AFTER_NAME ]
    - include: other_illegal_pop
  ae_NO_IN_GENERATOR_COMPREHENSION:
    - match: '((\())\s*(for){{idEnd}}'
      captures:
        1: punctuation.definition.comprehension.generator.begin.es
        2: meta.brace.round.js
        3: keyword.control.loop.for.comprehension.generator.es
      set: ae_NO_IN_GENERATOR_COMPREHENSION_AFTER_FOR
  ae_NO_IN_GENERATOR_COMPREHENSION_AFTER_FOR:
    - match: '((\())'
      captures:
        1: punctuation.definition.expression.loop.comprehension.generator.begin.es
        2: meta.brace.round.js
      set: [ ae_NO_IN_GENERATOR_COMPREHENSION_AFTER_LHSE, assignmentExpression_NO_IN ]
    - match: '{{MAT_word_or_any_one_char}}'
      scope: invalid.illegal.token.es
      set: ae_NO_IN_GENERATOR_COMPREHENSION_BEFORE_CLOSE
  ae_NO_IN_GENERATOR_COMPREHENSION_AFTER_LHSE:
    - match: 'of{{idEnd}}'
      scope: keyword.control.loop.of.comprehension.generator.es
      set: [ ae_NO_IN_GENERATOR_COMPREHENSION_AFTER_EXP_BODY, expression ]
    - match: '{{MAT_word_or_any_one_char}}'
      scope: invalid.illegal.token.es
      set: ae_NO_IN_GENERATOR_COMPREHENSION_AFTER_EXP_BODY
  ae_NO_IN_GENERATOR_COMPREHENSION_AFTER_EXP_BODY:
    - match: '((\)))'
      captures:
        1: punctuation.definition.expression.loop.comprehension.generator.begin.es
        2: meta.brace.round.js
      set: ae_NO_IN_GENERATOR_COMPREHENSION_AFTER_EXP
    - match: '{{MAT_word_or_any_one_char}}'
      scope: invalid.illegal.token.es
      set: ae_NO_IN_GENERATOR_COMPREHENSION_BEFORE_CLOSE
  ae_NO_IN_GENERATOR_COMPREHENSION_AFTER_EXP:
    - match: 'if{{idEnd}}'
      scope: keyword.control.loop.conditional.if.comprehension.generator.es
      set: ae_NO_IN_GENERATOR_COMPREHENSION_AFTER_IF
    - match: 'for{{idEnd}}'
      scope: keyword.control.loop.for.comprehension.generator.es
      set: ae_NO_IN_GENERATOR_COMPREHENSION_AFTER_FOR
    - match: '{{PLA_anything}}'
      set: [ ae_NO_IN_GENERATOR_COMPREHENSION_BEFORE_CLOSE, expression ]
    - match: '{{MAT_word_or_any_one_char}}'
      scope: invalid.illegal.token.es
      set: ae_NO_IN_GENERATOR_COMPREHENSION_BEFORE_CLOSE
  ae_NO_IN_GENERATOR_COMPREHENSION_AFTER_IF:
    - match: '((\())'
      captures:
        1: punctuation.definition.expression.conditional.comprehension.generator.begin.es
        2: meta.brace.round.js
      set: [ ae_NO_IN_GENERATOR_COMPREHENSION_AFTER_IF_EXP, expression ]
    - match: '{{MAT_word_or_any_one_char}}'
      scope: invalid.illegal.token.es
      set: ae_NO_IN_GENERATOR_COMPREHENSION_AFTER_IF_EXP
  ae_NO_IN_GENERATOR_COMPREHENSION_AFTER_IF_EXP:
    - match: '((\)))'
      captures:
        1: punctuation.definition.expression.conditional.comprehension.generator.begin.es
        2: meta.brace.round.js
      set: ae_NO_IN_GENERATOR_COMPREHENSION_AFTER_EXP
    - match: '{{MAT_word_or_any_one_char}}'
      scope: invalid.illegal.token.es
      set: ae_NO_IN_GENERATOR_COMPREHENSION_BEFORE_CLOSE
  ae_NO_IN_GENERATOR_COMPREHENSION_BEFORE_CLOSE:
    - match: '((\)))'
      captures:
        1: punctuation.definition.comprehension.generator.end.es
        2: meta.brace.round.js
      set: ae_NO_IN_AFTER_THING
    - match: '\('
      scope: invalid.illegal.token.es
      set: ae_NO_IN_GENERATOR_COMPREHENSION_AFTER_EXP_BODY
    - include: other_illegal
  ae_NO_IN_IDENTIFIERS:
    - include: ae_NO_IN_IDENTIFIERS_LANGUAGE
    - match: '({{identifier}})\s*(=>)'
      captures:
        1: variable.parameter.es
        2: storage.type.function.arrow.es
      set: ae_NO_IN_ARROW_AFTER_ARROW
    - include: ae_NO_IN_IDENTIFIERS_INTRINSIC
    - include: ae_NO_IN_IDENTIFIERS_ENVIRONMENTAL
    - match: '((({{identifierAllCapsStrict}})))\s*((\())'
      captures:
        1: variable.other.readwrite.allCap.es
        2: meta.function-call
        3: meta.invocation.es
        4: punctuation.definition.arguments.begin.es
        5: meta.brace.round.js
      set: [ ae_NO_IN_AFTER_THING, arguments ]
    - match: '{{identifierAllCapsStrict}}'
      scope: variable.other.readwrite.allCap.es
      set: ae_NO_IN_AFTER_IDENTIFIER
    - match: '((({{identifierInitCapStrict}})))\s*((\())'
      captures:
        1: variable.other.readwrite.initCap.es
        2: meta.function-call
        3: meta.invocation.es
        4: punctuation.definition.arguments.begin.es
        5: meta.brace.round.js
      set: [ ae_NO_IN_AFTER_THING, arguments ]
    - match: '{{identifierInitCapStrict}}'
      scope: variable.other.readwrite.initCap.es
      set: ae_NO_IN_AFTER_IDENTIFIER
    - match: '((({{identifier}})))\s*((\())'
      captures:
        1: variable.other.readwrite.es
        2: meta.function-call
        3: meta.invocation.es
        4: punctuation.definition.arguments.begin.es
        5: meta.brace.round.js
      set: [ ae_NO_IN_AFTER_THING, arguments ]
    - match: '{{identifier}}'
      scope: variable.other.readwrite.es
      set: ae_NO_IN_AFTER_IDENTIFIER
  ae_NO_IN_IDENTIFIERS_LANGUAGE:
    - match: '(((this)))\s*((\())'
      captures:
        1: variable.language.this.es
        2: meta.function-call
        3: meta.invocation.es
        4: punctuation.definition.arguments.begin.es
        5: meta.brace.round.js
      set: [ ae_NO_IN_AFTER_THING, arguments ]
    - match: 'this{{idEnd}}'
      scope: variable.language.this.es
      set: ae_NO_IN_AFTER_THING
    - match: '(((super)))\s*((\())'
      captures:
        1: variable.language.super.es
        2: meta.function-call
        3: meta.invocation.es
        4: punctuation.definition.arguments.begin.es
        5: meta.brace.round.js
      set: [ ae_NO_IN_AFTER_THING, arguments ]
    - match: 'super{{idEnd}}'
      scope: variable.language.super.es
      set: ae_NO_IN_AFTER_THING
    - match: 'import\s*\.\s*meta\b'
      scope: variable.language.import-meta
      set: ae_NO_IN_AFTER_VALUE
    - match: 'import\s*\('
      scope: variable.language.import-dynamic
      set:
        - - match: '\)'
            scope: variable.language.import-dynamic
            set: ae_NO_IN_AFTER_THING
          - include: other_illegal
        - - include: assignmentExpression_NO_IN
    - match: 'arguments{{idEnd}}'
      scope: variable.language.arguments.es
      set: ae_NO_IN_AFTER_THING
  ae_NO_IN_IDENTIFIERS_ENVIRONMENTAL:
    - match: '((((Buffer)))\s*)((\())'
      captures:
        1: variable.other.readwrite.es
        2: meta.instance.constructor entity.name.type.new
        3: meta.instantiation.es
        4: support.class.node.es
        5: punctuation.definition.arguments.begin.es
        6: meta.brace.round.js
      set: [ ae_NO_IN_AFTER_THING, arguments ]
    - match: '(Buffer){{idEnd}}'
      scope: variable.other.readwrite.es
      captures:
        1: support.class.node.es
      set: ae_NO_IN_AFTER_THING
    - match: '(((require)))\s*((\())'
      captures:
        1: meta.function-call
        2: meta.invocation.es
        3: support.function.node.require.es
        4: punctuation.definition.arguments.begin.es
        5: meta.brace.round.js
      set: [ ae_NO_IN_AFTER_THING, arguments ]
    - match: '(global|GLOBAL|process|__(?:dir|file)name|module|exports|require){{idEnd}}'
      scope: support.variable.node.es
      set: ae_NO_IN_AFTER_THING
    - match: '(_|R){{idEnd}}'
      scope: support.variable.functional-library.es
      set: ae_NO_IN_AFTER_THING
    - match: '(?:\$|angular|Polymer|React){{idEnd}}'
      scope: support.variable.dom-library.es
      set: ae_NO_IN_AFTER_THING
    - match: '(document|frames|history|location|navigator|screen|window){{idEnd}}'
      scope: support.variable.dom.es
      set: ae_NO_IN_AFTER_THING
  ae_NO_IN_IDENTIFIERS_INTRINSIC:
    - match: '(?x) (((({{intrinsicConstructors}})))\s*)((\())'
      captures:
        1: variable.other.readwrite.es
        2: meta.instance.constructor entity.name.type.new
        3: meta.instantiation.es
        4: support.class.builtin.es
        5: punctuation.definition.arguments.begin.es
        6: meta.brace.round.js
      set: [ ae_NO_IN_AFTER_THING, arguments ]
    - match: '(?x) ({{intrinsicConstructors}}){{idEnd}}'
      scope: variable.other.readwrite.es
      captures:
        1: support.class.builtin.es
      set: ae_NO_IN_AFTER_THING
    - match: '(?:console|Intl|JSON|Math|SIMD){{idEnd}}'
      scope: support.variable.builtin.es
      set: ae_NO_IN_AFTER_THING
    - match: '(?x) ((( {{intrinsicFunctions}} )))\s*((\())'
      captures:
        1: meta.function-call
        2: meta.invocation.es
        3: support.function.builtin.es
        4: punctuation.definition.arguments.begin.es
        5: meta.brace.round.js
      set: [ ae_NO_IN_AFTER_THING, arguments ]
    - match: '(?x) ({{intrinsicFunctions}}){{idEnd}}'
      scope: support.function.builtin.es
      set: ae_NO_IN_AFTER_THING
  ae_NO_IN_INFIX_OPS:
    - match: '\?'
      scope: keyword.operator.ternary.if.es
      set: ae_NO_IN_TERNARY_AFTER_QUESTION
    - match: '\+(?!=)'
      scope: keyword.operator.arithmetic.addition.es
      set: assignmentExpression_NO_IN
    - match: '-(?!=)'
      scope: keyword.operator.arithmetic.subtraction.es
      set: assignmentExpression_NO_IN
    - match: '\*\*(?!=)'
      scope: keyword.operator.arithmetic.exponentiation.es
      set: assignmentExpression_NO_IN
    - match: >-
        (?x)
          \*
          (?! [=\*])
          (?! \s* " [^"]+ " \s* \( )
          (?! \s* '' [^'']+ '' \s* \( )
          (?! \s* \[ [\]]+ \] \s* \( )
          (?! \s* {{identifier}} \s* \([^)]*\) \s* \{)
      scope: keyword.operator.arithmetic.multiplication.es
      set: assignmentExpression_NO_IN
    - match: '\/(?!=)'
      scope: keyword.operator.arithmetic.division.es
      set: assignmentExpression_NO_IN
    - match: '%(?!=)'
      scope: keyword.operator.arithmetic.modulo.es
      set: assignmentExpression_NO_IN
    - match: '==='
      scope: keyword.operator.comparison.equality.strict.es
      set: assignmentExpression_NO_IN
    - match: '=='
      scope: keyword.operator.comparison.equality.coercive.es
      set: assignmentExpression_NO_IN
    - match: '!=='
      scope: keyword.operator.comparison.non-equality.strict.es
      set: assignmentExpression_NO_IN
    - match: '!='
      scope: keyword.operator.comparison.non-equality.coercive.es
      set: assignmentExpression_NO_IN
    - match: '&&'
      scope: keyword.operator.logical.and.es
      set: assignmentExpression_NO_IN
    - match: '\|\|(?!=)'
      scope: keyword.operator.logical.or.es
      set: assignmentExpression_NO_IN
    - match: '&(?!=)'
      scope: keyword.operator.bitwise.logical.and.es
      set: assignmentExpression_NO_IN
    - match: '\|(?![=\|])'
      scope: keyword.operator.bitwise.logical.or.es
      set: assignmentExpression_NO_IN
    - match: '\^(?!=)'
      scope: keyword.operator.bitwise.logical.xor.es
      set: assignmentExpression_NO_IN
    - match: '<<(?!=)'
      scope: keyword.operator.bitwise.shift.left.es
      set: assignmentExpression_NO_IN
    - match: '>>>(?!=)'
      scope: keyword.operator.bitwise.shift.right.unsigned.es
      set: assignmentExpression_NO_IN
    - match: '>>(?![=>])'
      scope: keyword.operator.bitwise.shift.right.es
      set: assignmentExpression_NO_IN
    - match: '<='
      scope: keyword.operator.relational.lte.es
      set: assignmentExpression_NO_IN
    - match: '<'
      scope: keyword.operator.relational.lt.es
      set: assignmentExpression_NO_IN
    - match: '>='
      scope: keyword.operator.relational.gte.es
      set: assignmentExpression_NO_IN
    - match: '>'
      scope: keyword.operator.relational.gt.es
      set: assignmentExpression_NO_IN
    - match: 'instanceof{{idEnd}}'
      scope: keyword.operator.relational.instanceof.es
      set: assignmentExpression_NO_IN
    - match: '::'
      scope: keyword.operator.bind.es
      set: assignmentExpression_NO_IN
  ae_NO_IN_INFIX_OPS_ASSIGNMENT:
    - match: '=(?!=)'
      scope: keyword.operator.assignment.es
      set: assignmentExpression_NO_IN
    - match: '\+='
      scope: keyword.operator.assignment.augmented.arithmetic.addition.es
      set: assignmentExpression_NO_IN
    - match: '-='
      scope: keyword.operator.assignment.augmented.arithmetic.subtraction.es
      set: assignmentExpression_NO_IN
    - match: '\*\*='
      scope: keyword.operator.assignment.augmented.arithmetic.exponentiation.es
      set: assignmentExpression_NO_IN
    - match: '\*='
      scope: keyword.operator.assignment.augmented.arithmetic.multiplication.es
      set: assignmentExpression_NO_IN
    - match: '\/='
      scope: keyword.operator.assignment.augmented.arithmetic.division.es
      set: assignmentExpression_NO_IN
    - match: '%='
      scope: keyword.operator.assignment.augmented.arithmetic.modulo.es
      set: assignmentExpression_NO_IN
    - match: '\|\|='
      scope: keyword.operator.assignment.conditional.mallet.es
      set: assignmentExpression_NO_IN
    - match: '&='
      scope: keyword.operator.assignment.augmented.bitwise.logical.and.es
      set: assignmentExpression_NO_IN
    - match: '\^='
      scope: keyword.operator.assignment.augmented.bitwise.logical.xor.es
      set: assignmentExpression_NO_IN
    - match: '\|='
      scope: keyword.operator.assignment.augmented.bitwise.logical.or.es
      set: assignmentExpression_NO_IN
    - match: '<<='
      scope: keyword.operator.assignment.augmented.bitwise.shift.left.es
      set: assignmentExpression_NO_IN
    - match: '>>>='
      scope: keyword.operator.assignment.augmented.bitwise.shift.right.unsigned.es
      set: assignmentExpression_NO_IN
    - match: '>>='
      scope: keyword.operator.assignment.augmented.bitwise.shift.right.es
      set: assignmentExpression_NO_IN
  ae_NO_IN_LITERAL_VALUES:
    - match: 'NaN(?![{{ID_Continue}}])'
      scope: constant.language.nan.es
      set: ae_NO_IN_AFTER_VALUE
    - match: 'null(?![{{ID_Continue}}])'
      scope: constant.language.null.es
      set: ae_NO_IN_AFTER_VALUE
    - match: 'true(?![{{ID_Continue}}])'
      scope: constant.language.boolean.true.es
      set: ae_NO_IN_AFTER_VALUE
    - match: 'false(?![{{ID_Continue}}])'
      scope: constant.language.boolean.false.es
      set: ae_NO_IN_AFTER_VALUE
    - match: 'Infinity(?![{{ID_Continue}}])'
      scope: constant.language.infinity.es
      set: ae_NO_IN_AFTER_VALUE
    - match: 'undefined(?![{{ID_Continue}}])'
      scope: constant.language.undefined.es
      set: ae_NO_IN_AFTER_VALUE
  ae_NO_IN_NUMBERS:
    - match: '{{decNum}}'
      scope: constant.numeric.decimal.es
      captures:
        1: punctuation.decimal.es
        2: punctuation.decimal.es
        3: punctuation.decimal.es
        4: meta.numeric.exponent.e.es
        5: meta.numeric.exponent.sign.es
        6: meta.numeric.exponent.digit.es
      set: ae_NO_IN_AFTER_VALUE
    - match: '{{binNum}}'
      scope: constant.numeric.binary.es
      captures:
        1: meta.numeric.prefix.es
      set: ae_NO_IN_AFTER_VALUE
    - match: '{{octNum}}'
      scope: constant.numeric.octal.es
      captures:
        1: meta.numeric.prefix.es
      set: ae_NO_IN_AFTER_VALUE
    - match: '{{hexNum}}'
      scope: constant.numeric.hexadecimal.es
      captures:
        1: meta.numeric.prefix.es
      set: ae_NO_IN_AFTER_VALUE
  ae_NO_IN_OBJECT_ARRAY_BINDING:
    - match: '(?x) ((\{)) (?= (?<brackets> [^\{\}] | \{ \g<brackets>* \} )* \}\s*=[^=])'
      captures:
        1: punctuation.definition.binding.object.begin.es
        2: meta.brace.curly.js
      set: [ ae_NO_IN_AFTER_THING, bindingObject ]
    - match: '(?x) ((\[)) (?= (?<brackets> [^\[\]] | \[ \g<brackets>* \] )* \]\s*=[^=])'
      captures:
        1: punctuation.definition.binding.array.begin.es
        2: meta.brace.square.js
      set: [ ae_NO_IN_AFTER_THING, bindingArray ]
  ae_NO_IN_OBJECT_ARRAY_LITERAL:
    - match: '((\{))'
      captures:
        1: punctuation.definition.object.begin.es
        2: meta.brace.curly.js
      set: [ ae_NO_IN_OBJECT_ARRAY_LITERAL_END, literalObject_OPEN ]
    - match: '((\[))'
      captures:
        1: punctuation.definition.array.begin.es
        2: meta.brace.square.js
      set: [ ae_NO_IN_OBJECT_ARRAY_LITERAL_END, literalArray_OPEN ]
  ae_NO_IN_OBJECT_ARRAY_LITERAL_END:
    - match: '=(?!=)'
      scope: keyword.operator.assignment.es
      set: assignmentExpression_NO_IN
    - include: ae_NO_IN_AFTER_VALUE
  ae_NO_IN_PARENTHESIZED:
    - match: '((\())'
      captures:
        1: punctuation.definition.expression.begin.es
        2: meta.brace.round.js
      set: ae_NO_IN_PARENTHESIZED_AFTER_OPEN
  ae_NO_IN_PARENTHESIZED_AFTER_OPEN:
    - match: '((\)))'
      captures:
        1: punctuation.definition.expression.end.es
        2: meta.brace.round.js
      set: ae_NO_IN_AFTER_IDENTIFIER
    - match: '{{PLA_anything}}'
      push: expression
  ae_NO_IN_POSTFIX_OPS:
    - match: '\+\+'
      scope: keyword.operator.arithmetic.increment.postfix.es
      set: ae_NO_IN_AFTER_POSTFIX
    - match: '--'
      scope: keyword.operator.arithmetic.decrement.postfix.es
      set: ae_NO_IN_AFTER_POSTFIX
  ae_NO_IN_STRING_REGEX:
    - match: "'"
      scope: punctuation.definition.string.quoted.single.begin.es
      set: [ ae_NO_IN_AFTER_VALUE, stringSingle_AFTER_OPEN ]
    - match: '"'
      scope: punctuation.definition.string.quoted.double.begin.es
      set: [ ae_NO_IN_AFTER_VALUE, stringDouble_AFTER_OPEN ]
    - match: '`'
      scope: punctuation.definition.string.interpolated.begin.es
      set: [ ae_NO_IN_AFTER_VALUE, templateString_AFTER_OPEN ]
    - match: '\/'
      scope: punctuation.definition.string.regexp.begin.es
      set: [ ae_NO_IN_AFTER_VALUE, regex_AFTER_OPEN ]
    - match: '((({{identifier}})))\s*(`)'
      captures:
        1: entity.quasi.tag.name.js
        2: variable.other.readwrite.tag.es
        3: punctuation.definition.string.interpolated.begin.es
      set: [ ae_NO_IN_AFTER_VALUE, templateString_AFTER_OPEN ]
  ae_NO_IN_TERNARY_AFTER_QUESTION:
    - match: ':'
      scope: invalid.illegal.token.es
      set: assignmentExpression_NO_IN
    - match: '{{PLA_anything}}'
      set: [ ae_NO_IN_TERNARY_AFTER_IF_CASE, assignmentExpression_NO_IN ]
  ae_NO_IN_TERNARY_AFTER_IF_CASE:
    - match:  ':'
      scope: keyword.operator.ternary.else.es
      set: assignmentExpression_NO_IN
    - include: other_illegal_pop
  ae_NO_IN_YIELD_NEW:
    - match: >-
        (?x)
          (new) \s+ (((
            ( Buffer ) |
            ( {{intrinsicConstructors}} ) |
            {{identifier}}
          ))){{idEnd}}(?!\s*\.)
      captures:
        1: keyword.operator.new.es
        2: variable.other.readwrite.es
        3: meta.instance.constructor entity.name.type.new
        4: meta.instantiation.es
        5: support.class.node.es
        6: support.class.builtin.es
      set: ae_NO_IN_AFTER_THING
    - match: >-
        (?x)
          (new) \s+
          (?: ({{identifier}}) (\.) )
          (?: ({{identifier}}) (\.)
            (?: ({{identifier}}) (\.)
              (?:
                ({{identifier}}) (\.)
              )?
            )?
          )?
          ((({{identifier}})))(?!\s*\.)
      captures:
        1: keyword.operator.new.es
        2: variable.other.readwrite.es
        3: keyword.operator.accessor.es
        4: variable.other.readwrite.es
        5: keyword.operator.accessor.es
        6: variable.other.readwrite.es
        7: keyword.operator.accessor.es
        8: variable.other.readwrite.es
        9: keyword.operator.accessor.es
        10: variable.other.readwrite.es
        11: meta.instance.constructor entity.name.type.new
        12: meta.instantiation.es
      set: ae_NO_IN_AFTER_THING
    - match: '(new)\s*(\.)'
      captures:
        1: variable.language.new-target.fake-object.es
        2: variable.language.new-target.fake-accessor.es
      set: ae_NO_IN_YIELD_NEW_AFTER_NEW_WAT
    - match: 'new{{idEnd}}'
      scope: keyword.operator.new.es
      set: ae_NO_IN_YIELD_NEW_AFTER_NEW_OPERATOR
    - match: 'yield{{idEnd}}'
      scope: keyword.control.flow.yield.es
      set: ae_NO_IN_YIELD_NEW_AFTER_YIELD
  ae_NO_IN_YIELD_NEW_AFTER_YIELD:
    - match: '\*'
      scope: keyword.control.flow.yield.iterate.es
      set: assignmentExpression_NO_IN
    - match: '$'
      pop: true
    - include: assignmentExpression_NO_IN_CORE
    - include: else_pop
  ae_NO_IN_YIELD_NEW_AFTER_NEW_OPERATOR:
    - match: '\.'
      scope: variable.language.new-target.fake-accessor.es
      set: ae_NO_IN_YIELD_NEW_AFTER_NEW_WAT
    - include: assignmentExpression_NO_IN
  ae_NO_IN_YIELD_NEW_AFTER_NEW_WAT:
    - match: 'target{{idEnd}}'
      scope: variable.language.new-target.fake-property.es
      set: ae_NO_IN_AFTER_THING
    - match: '{{MAT_word_or_any_one_char}}'
      scope: invalid.illegal.token.es
      set: ae_NO_IN_AFTER_ACCESSOR_OPERATOR

# END OF REPETITION
################################################################################
################################################################################
################################################################################
################################################################################

# OBJECT & ARRAY LITERALS ######################################################

  literalArray_OPEN:
    - match: '\]'
      scope: punctuation.definition.array.end.es
      pop: true
    - match: ','
      scope: punctuation.separator.array-element.es
    - match: '\.{3}'
      scope: keyword.operator.spread.es
      set: [ literalArray_AFTER_MEMBER, assignmentExpression ]
    - match: '{{PLA_anything}}'
      set: [ literalArray_AFTER_MEMBER, assignmentExpression ]

  literalArray_AFTER_MEMBER:
    # This context is a safety catch for recovering correct scope when it turns
    # out this was really a multiline binding pattern.
    - match:  '(?<=\])(?==)'
      set: bindingArray_AFTER_ELEM
    - match: '{{PLA_anything}}'
      set: literalArray_OPEN

  literalObject_OPEN:
    - match: '((\}))'
      captures:
        1: punctuation.definition.object.end.es
        2: meta.brace.curly.js # ^BS
      pop: true
    # PREFIXED METHODS
    - match: '((\*))'
      captures:
        1: keyword.generator.asterisk.js # ^BS
        2: storage.modifier.generator.asterisk.method.es
      set: [ literalObject_AFTER_AE, generatorMethod_AFTER_ASTERISK ]
    - match: '((get))\s*((:))'
      captures:
        1: constant.other.object.key.js string.unquoted.label.js # ^BS
        2: variable.other.readwrite.property.object-literal.es
        3: constant.other.object.key.js # ^BS
        4: punctuation.separator.key-value.es
      set: [ literalObject_AFTER_AE, assignmentExpression ]
    - match: '((get))(?!\s*\(){{idEnd}}'
      captures:
        1: storage.type.accessor.js # ^BS
        2: storage.modifier.accessor.get.es
      set: [ literalObject_AFTER_AE, accessorMethod_AFTER_GET ]
    - match: '((set))\s*((:))'
      captures:
        1: constant.other.object.key.js string.unquoted.label.js # ^BS
        2: variable.other.readwrite.property.object-literal.es
        3: constant.other.object.key.js # ^BS
        4: punctuation.separator.key-value.es
      set: [ literalObject_AFTER_AE, assignmentExpression ]
    - match: '((set))(?!\s*\(){{idEnd}}'
      captures:
        1: storage.type.accessor.js # ^BS
        2: storage.modifier.accessor.set.es
      set: [ literalObject_AFTER_AE, accessorMethod_AFTER_SET ]
    - match: '((async)){{idEnd}}'
      captures:
        1: storage.type.js # ^BS
        2: storage.modifier.async.es
      set: [ literalObject_AFTER_AE, asyncMethod_AFTER_ASYNC ]
    # NORMAL METHODS
    - match: '(({{allThreeIDs}}))\s*(\()'
      captures:
        1: entity.name.method.js # ^BS -- monokai
        2: entity.name.method.es
        3: variable.other.readwrite.property.allCap.es
        4: variable.other.readwrite.property.initCap.es
        5: variable.other.readwrite.property.es
        6: punctuation.definition.parameters.method.begin.es
      set: [ literalObject_AFTER_AE, method_AFTER_PARAMS, parameters ]
    # NORMAL PROPERTIES
    - match: '({{allThreeIDs}})\s*((:))'
      captures:
        1: constant.other.object.key.js string.unquoted.label.js # ^BS
        2: variable.other.readwrite.property.object-literal.allCap.es
        3: variable.other.readwrite.property.object-literal.initCap.es
        4: variable.other.readwrite.property.object-literal.es
        5: constant.other.object.key.js # ^BS
        6: punctuation.separator.key-value.es
      set: [ literalObject_AFTER_AE, assignmentExpression ]
    # IDENTIFIER REFERENCE (probably)
    # We match references (shorthand properties) last because we must rely on
    # other punctuation to identify ‘regular’ properties and methods.
    - match: '{{allThreeIDs}}'
      captures:
        1: variable.other.readwrite.property.shorthand.allCap.es # -BS
        2: variable.other.readwrite.property.shorthand.initCap.es
        3: variable.other.readwrite.property.shorthand.es
      set: literalObject_AFTER_SHORTHAND
    # NORMALLY ILLEGAL NAME
    - match: '(({{identifierName}}))'
      captures:
        1: constant.other.object.key.js string.unquoted.label.js # ^BS
        2: variable.other.readwrite.property.object-literal.es
      set: literalObject_AFTER_SHORTHAND
    # QUOTED PROPERTY
    - match: "'"
      scope: punctuation.definition.string.quoted.single.begin.es
      set: [ literalObject_AFTER_PROP, stringSingle_AFTER_OPEN ]
    - match: '"'
      scope: punctuation.definition.string.quoted.double.begin.es
      set: [ literalObject_AFTER_PROP, stringDouble_AFTER_OPEN ]
    # ES7?
    - match: '\.{3}'
      scope: keyword.operator.spread.es
      set: [ literalObject_AFTER_AE, assignmentExpression ]
    - match: '((@))'
      captures:
        1: punctuation.definition.tag.js # ^BS
        2: punctuation.definition.decorator.es
      push: decoratorExpression
    # NUMERIC PROPERTY
    - match: '({{decNum}})'
      scope: constant.numeric.decimal.es
      captures:
        1: variable.other.readwrite.property.object-literal.es
        2: punctuation.decimal.es
        3: punctuation.decimal.es
        4: punctuation.decimal.es
        5: meta.numeric.exponent.e.es
        6: meta.numeric.exponent.sign.es
        7: meta.numeric.exponent.digit.es
      set: literalObject_AFTER_PROP
    - match: '({{binNum}})'
      scope: constant.numeric.binary.es
      captures:
        1: variable.other.readwrite.property.object-literal.es
        2: meta.numeric.prefix.es
      set: literalObject_AFTER_PROP
    - match: '({{octNum}})'
      scope: constant.numeric.octal.es
      captures:
        1: variable.other.readwrite.property.object-literal.es
        2: meta.numeric.prefix.es
      set: literalObject_AFTER_PROP
    - match: '({{hexNum}})'
      scope: constant.numeric.hexadecimal.es
      captures:
        1: variable.other.readwrite.property.object-literal.es
        2: meta.numeric.prefix.es
      set: literalObject_AFTER_PROP
    # COMPUTED PROPERTY
    - match: '((\[))'
      captures:
        1: punctuation.definition.accessor.begin.es
        2: meta.brace.square.js # ^BS
      set: [ literalObject_AFTER_PROP, computedProp_AFTER_AE, assignmentExpression ]

  literalObject_AFTER_SHORTHAND:
    # Safety context for " prop \n : "
    - match: '((:))'
      captures:
        1: constant.other.object.key.js # ^BS
        2: punctuation.separator.key-value.es
      set: [ literalObject_AFTER_AE, assignmentExpression ]
    - match: '((\())'
      captures:
        1: punctuation.definition.parameters.method.begin.es
        2: meta.brace.round.js # ^BS
      set: [ literalObject_AFTER_AE, method_AFTER_PARAMS, parameters ]
    - include: literalObject_AFTER_AE

  literalObject_AFTER_PROP:
    - match: '((:))'
      captures:
        1: constant.other.object.key.js # ^BS
        2: punctuation.separator.key-value.es
      set: [ literalObject_AFTER_AE, assignmentExpression ]
    - match: '((\())'
      captures:
        1: punctuation.definition.parameters.method.begin.es
        2: meta.brace.round.js # ^BS
      set: [ literalObject_AFTER_AE, method_AFTER_PARAMS, parameters ]
    - include: other_illegal

  literalObject_AFTER_AE:
    - match: '((,))'
      captures:
        1: punctuation.separator.object-member.es
        2: meta.delimiter.comma.js # ^BS
      set: literalObject_OPEN
    - match: '{{PLA_anything}}'
      set: literalObject_OPEN

  computedProp_AFTER_AE:
    # Also used for property access
    - match: '((\]))'
      captures:
        1: punctuation.definition.accessor.end.es
        2: meta.brace.square.js # ^BS
      pop: true
    - include: other_illegal

# OBJECT & CLASS LITERAL METHODS ###############################################

  method_AFTER_NAME:
    - match: '((\())'
      captures:
        1: punctuation.definition.parameters.method.begin.es
        2: meta.brace.round.js # ^BS
      set: [ method_AFTER_PARAMS, parameters ]
    - include: other_illegal_pop

  method_AFTER_PARAMS:
    - match: '((\)))'
      captures:
        1: punctuation.definition.parameters.method.end.es
        2: meta.brace.round.js # ^BS
      set: method_BEFORE_BRACE
    - include: other_illegal

  method_BEFORE_BRACE:
    - match: '((\{))'
      captures:
        1: punctuation.definition.method.body.begin.es
        2: meta.brace.curly.js # ^BS
      set: method_AFTER_BRACE
    - include: other_illegal_pop

  method_AFTER_BRACE:
    - match: '((\}))'
      captures:
        1: punctuation.definition.method.body.end.es
        2: meta.brace.curly.js # ^BS
      pop: true
    - include: useStrict
    - include: statements

  asyncMethod_AFTER_ASYNC:
    - match: '(({{identifierName}}))'
      captures:
        1: entity.name.method.js # ^BS -- monokai
        2: entity.name.method.async.es
      set: asyncMethod_AFTER_NAME
    - match: "'"
      scope: punctuation.definition.string.quoted.single.begin.es
      set: [ asyncMethod_AFTER_NAME, stringSingle_AFTER_OPEN ]
    - match: '"'
      scope: punctuation.definition.string.quoted.double.begin.es
      set: [ asyncMethod_AFTER_NAME, stringDouble_AFTER_OPEN ]
    - match: '({{decNum}})'
      scope: constant.numeric.decimal.es
      captures:
        1: entity.name.method.es
        2: punctuation.decimal.es
        3: punctuation.decimal.es
        4: punctuation.decimal.es
        5: meta.numeric.exponent.e.es
        6: meta.numeric.exponent.sign.es
        7: meta.numeric.exponent.digit.es
      set: asyncMethod_AFTER_NAME
    - match: '({{binNum}})'
      scope: constant.numeric.binary.es
      captures:
        1: entity.name.method.es
        2: meta.numeric.prefix.es
      set: asyncMethod_AFTER_NAME
    - match: '({{octNum}})'
      scope: constant.numeric.octal.es
      captures:
        1: entity.name.method.es
        2: meta.numeric.prefix.es
      set: asyncMethod_AFTER_NAME
    - match: '({{hexNum}})'
      scope: constant.numeric.hexadecimal.es
      captures:
        1: entity.name.method.es
        2: meta.numeric.prefix.es
      set: asyncMethod_AFTER_NAME
    - match: '((\[))'
      captures:
        1: punctuation.definition.accessor.begin.es
        2: meta.brace.square.js # ^BS
      set: [ asyncMethod_AFTER_NAME, computedProp_AFTER_AE, assignmentExpression ]
    - include: other_illegal_pop

  asyncMethod_AFTER_NAME:
    - match: '((\())'
      captures:
        1: punctuation.definition.parameters.method.async.begin.es
        2: meta.brace.round.js # ^BS
      set: [ asyncMethod_AFTER_PARAMS, parameters ]
    - include: other_illegal_pop

  asyncMethod_AFTER_PARAMS:
    - match: '((\)))'
      captures:
        1: punctuation.definition.parameters.method.async.end.es
        2: meta.brace.round.js # ^BS
      set: asyncMethod_BEFORE_BRACE
    - include: other_illegal

  asyncMethod_BEFORE_BRACE:
    - match: '((\{))'
      captures:
        1: punctuation.definition.method.async.body.begin.es
        2: meta.brace.curly.js # ^BS
      set: asyncMethod_AFTER_BRACE
    - include: other_illegal_pop

  asyncMethod_AFTER_BRACE:
    - match: '((\}))'
      captures:
        1: punctuation.definition.method.async.body.end.es
        2: meta.brace.curly.js # ^BS
      pop: true
    - include: useStrict
    - include: statements

  accessorMethod_AFTER_GET:
    - match: '(({{identifierName}}))'
      captures:
        1: entity.name.method.js # ^BS -- monokai
        2: entity.name.accessor.get.es
      set: accessorMethod_AFTER_GET_NAME
    - match: "'"
      scope: punctuation.definition.string.quoted.single.begin.es
      set: [ accessorMethod_AFTER_GET_NAME, stringSingle_AFTER_OPEN ]
    - match: '"'
      scope: punctuation.definition.string.quoted.double.begin.es
      set: [ accessorMethod_AFTER_GET_NAME, stringDouble_AFTER_OPEN ]
    - match: '({{decNum}})'
      scope: constant.numeric.decimal.es
      captures:
        1: entity.name.method.es
        2: punctuation.decimal.es
        3: punctuation.decimal.es
        4: punctuation.decimal.es
        5: meta.numeric.exponent.e.es
        6: meta.numeric.exponent.sign.es
        7: meta.numeric.exponent.digit.es
      set: accessorMethod_AFTER_GET_NAME
    - match: '({{binNum}})'
      scope: constant.numeric.binary.es
      captures:
        1: entity.name.method.es
        2: meta.numeric.prefix.es
      set: accessorMethod_AFTER_GET_NAME
    - match: '({{octNum}})'
      scope: constant.numeric.octal.es
      captures:
        1: entity.name.method.es
        2: meta.numeric.prefix.es
      set: accessorMethod_AFTER_GET_NAME
    - match: '({{hexNum}})'
      scope: constant.numeric.hexadecimal.es
      captures:
        1: entity.name.method.es
        2: meta.numeric.prefix.es
      set: accessorMethod_AFTER_GET_NAME
    - match: '((\[))'
      captures:
        1: punctuation.definition.accessor.begin.es
        2: meta.brace.square.js # ^BS
      set: [ accessorMethod_AFTER_GET_NAME, computedProp_AFTER_AE, assignmentExpression ]
    # Possibly this is an object property.
    - include: other_illegal_pop

  accessorMethod_AFTER_GET_NAME:
    - match: '((\())'
      captures:
        1: punctuation.definition.parameters.accessor.begin.es
        2: meta.brace.round.js # ^BS
      set: accessorMethod_AFTER_GET_PAREN_OPEN
    - include: other_illegal_pop

  accessorMethod_AFTER_GET_PAREN_OPEN:
    - match: '((\)))'
      captures:
        1: punctuation.definition.parameters.accessor.end.es
        2: meta.brace.round.js # ^BS
      set: accessorMethod_BEFORE_BRACE
    - include: other_illegal

  accessorMethod_AFTER_SET:
    - match: '(({{identifierName}}))'
      captures:
        1: entity.name.method.js # ^BS -- monokai
        2: entity.name.accessor.set.es
      set: accessorMethod_AFTER_SET_NAME
    - match: "'"
      scope: punctuation.definition.string.quoted.single.begin.es
      set: [ accessorMethod_AFTER_SET_NAME, stringSingle_AFTER_OPEN ]
    - match: '"'
      scope: punctuation.definition.string.quoted.double.begin.es
      set: [ accessorMethod_AFTER_SET_NAME, stringDouble_AFTER_OPEN ]
    - match: '({{decNum}})'
      scope: constant.numeric.decimal.es
      captures:
        1: entity.name.method.es
        2: punctuation.decimal.es
        3: punctuation.decimal.es
        4: punctuation.decimal.es
        5: meta.numeric.exponent.e.es
        6: meta.numeric.exponent.sign.es
        7: meta.numeric.exponent.digit.es
      set: accessorMethod_AFTER_SET_NAME
    - match: '({{binNum}})'
      scope: constant.numeric.binary.es
      captures:
        1: entity.name.method.es
        2: meta.numeric.prefix.es
      set: accessorMethod_AFTER_SET_NAME
    - match: '({{octNum}})'
      scope: constant.numeric.octal.es
      captures:
        1: entity.name.method.es
        2: meta.numeric.prefix.es
      set: accessorMethod_AFTER_SET_NAME
    - match: '({{hexNum}})'
      scope: constant.numeric.hexadecimal.es
      captures:
        1: entity.name.method.es
        2: meta.numeric.prefix.es
      set: accessorMethod_AFTER_SET_NAME
    - match: '((\[))'
      captures:
        1: punctuation.definition.accessor.begin.es
        2: meta.brace.square.js # ^BS
      set: [ accessorMethod_AFTER_SET_NAME, computedProp_AFTER_AE, assignmentExpression ]
    - include: other_illegal_pop

  accessorMethod_AFTER_SET_NAME:
    - match: '((\())'
      captures:
        1: punctuation.definition.parameters.accessor.begin.es
        2: meta.brace.round.js # ^BS
      set: [ accessorMethod_AFTER_SET_PARAM, parameters ]
    - include: other_illegal_pop

  accessorMethod_AFTER_SET_PARAM:
    - match: '((\)))'
      captures:
        1: punctuation.definition.parameters.accessor.end.es
        2: meta.brace.round.js # ^BS
      set: accessorMethod_BEFORE_BRACE
    - include: other_illegal

  accessorMethod_BEFORE_BRACE:
    - match: '((\{))'
      captures:
        1: punctuation.definition.accessor.body.begin.es
        2: meta.brace.curly.js # ^BS
      set: accessorMethod_AFTER_BRACE
    - include: other_illegal_pop

  accessorMethod_AFTER_BRACE:
    - match: '((\}))'
      captures:
        1: punctuation.definition.accessor.body.end.es
        2: meta.brace.curly.js # ^BS
      pop: true
    - include: useStrict
    - match: '(return){{idEnd}}'
      scope: keyword.control.flow.return.accessor.es
      push: returnStatement
    - include: statements

  generatorMethod_AFTER_ASTERISK:
    - match: '(({{identifierName}}))'
      captures:
        1: entity.name.method.js # ^BS -- monokai
        2: entity.name.method.generator.es
      set: generatorMethod_AFTER_NAME
    - match: "'"
      scope: punctuation.definition.string.quoted.single.begin.es
      set: [ generatorMethod_AFTER_NAME, stringSingle_AFTER_OPEN ]
    - match: '"'
      scope: punctuation.definition.string.quoted.double.begin.es
      set: [ generatorMethod_AFTER_NAME, stringDouble_AFTER_OPEN ]
    - match: '({{decNum}})'
      scope: constant.numeric.decimal.es
      captures:
        1: entity.name.method.es
        2: punctuation.decimal.es
        3: punctuation.decimal.es
        4: punctuation.decimal.es
        5: meta.numeric.exponent.e.es
        6: meta.numeric.exponent.sign.es
        7: meta.numeric.exponent.digit.es
      set: generatorMethod_AFTER_NAME
    - match: '({{binNum}})'
      scope: constant.numeric.binary.es
      captures:
        1: entity.name.method.es
        2: meta.numeric.prefix.es
      set: generatorMethod_AFTER_NAME
    - match: '({{octNum}})'
      scope: constant.numeric.octal.es
      captures:
        1: entity.name.method.es
        2: meta.numeric.prefix.es
      set: generatorMethod_AFTER_NAME
    - match: '({{hexNum}})'
      scope: constant.numeric.hexadecimal.es
      captures:
        1: entity.name.method.es
        2: meta.numeric.prefix.es
      set: generatorMethod_AFTER_NAME
    - match: '((\[))'
      captures:
        1: punctuation.definition.accessor.begin.es
        2: meta.brace.square.js # ^BS
      set: [ generatorMethod_AFTER_NAME, computedProp_AFTER_AE, assignmentExpression ]
    - include: other_illegal_pop

  generatorMethod_AFTER_NAME:
    - match: '((\())'
      captures:
        1: punctuation.definition.parameters.method.generator.begin.es
        2: meta.brace.round.js # ^BS
      set: [ generatorMethod_AFTER_PARAMS, parameters ]
    - include: other_illegal_pop

  generatorMethod_AFTER_PARAMS:
    - match: '((\)))'
      captures:
        1: punctuation.definition.parameters.method.generator.end.es
        2: meta.brace.round.js # ^BS
      set: generatorMethod_BEFORE_BRACE
    - include: other_illegal

  generatorMethod_BEFORE_BRACE:
    - match: '((\{))'
      captures:
        1: punctuation.definition.method.generator.body.begin.es
        2: meta.brace.curly.js # ^BS
      set: generatorMethod_AFTER_BRACE
    - include: other_illegal_pop

  generatorMethod_AFTER_BRACE:
    - match: '((\}))'
      captures:
        1: punctuation.definition.method.generator.body.end.es
        2: meta.brace.curly.js # ^BS
      pop: true
    - include: useStrict
    - include: statements

  constructorMethod_AFTER_CONSTRUCTOR:
    - match: '((\())'
      captures:
        1: punctuation.definition.parameters.constructor.begin.es
        2: meta.brace.round.js # ^BS
      set: [ constructorMethod_AFTER_PARAMS, parameters ]
    - include: other_illegal_pop

  constructorMethod_AFTER_PARAMS:
    - match: '((\)))'
      captures:
        1: punctuation.definition.parameters.constructor.end.es
        2: meta.brace.round.js # ^BS
      set: constructorMethod_BEFORE_BRACE
    - include: other_illegal

  constructorMethod_BEFORE_BRACE:
    - match: '((\{))'
      captures:
        1: punctuation.definition.constructor.body.begin.es
        2: meta.brace.curly.js # ^BS
      set: constructorMethod_AFTER_BRACE
    - include: other_illegal_pop

  constructorMethod_AFTER_BRACE:
    - match: '((\}))'
      captures:
        1: punctuation.definition.constructor.body.end.es
        2: meta.brace.curly.js # ^BS
      pop: true
    - include: useStrict
    - include: statements

# BINDING PATTERNS #############################################################

  bindingArray:
    - match: '((\]))'
      captures:
        1: punctuation.definition.binding.array.end.es
        2: meta.brace.square.js # ^BS
      pop: true
    - match: '((,))'
      captures:
        1: punctuation.separator.array-element.binding.es
        2: meta.separator.comma.js # ^BS
    - match: '\.{3}'
      scope: keyword.other.rest.es # -BS
      set: bindingArray_AFTER_ELLIPSIS
    - match: '((\[))'
      captures:
        1: punctuation.definition.binding.array.begin.es
        2: meta.brace.square.js # ^BS
      set: [ bindingArray_AFTER_ELEM, bindingArray ]
    - match: '((\{))'
      captures:
        1: punctuation.definition.binding.object.begin.es
        2: meta.brace.curly.js # ^BS
      set: [ bindingArray_AFTER_ELEM, bindingObject ]
    # Actually must be an LHS, but we cannot readily describe that constraint:
    - match: '{{PLA_anything}}'
      set: [ bindingArray_AFTER_ELEM, assignmentExpression ]

  bindingArray_AFTER_ELEM:
    - match: '((\]))'
      captures:
        1: punctuation.definition.binding.array.end.es
        2: meta.brace.square.js # ^BS
      pop: true
    - match: '((,))'
      captures:
        1: punctuation.separator.array-element.binding.es
        2: meta.separator.comma.js # ^BS
      set: bindingArray
    - match: '='
      scope: keyword.operator.assignment.conditional.default.es
      push: assignmentExpression
    - include: other_illegal

  bindingArray_AFTER_ELLIPSIS:
    - match: '{{allThreeIDs}}'
      captures:
        1: variable.other.readwrite.allCap.es # -BS
        2: variable.other.readwrite.initCap.es
        3: variable.other.readwrite.es
      set: bindingArray_AFTER_REST_ELEM
    - match: '\]'
      scope: invalid.illegal.token.es
      pop: true

  bindingArray_AFTER_REST_ELEM:
    - match: '((\]))'
      captures:
        1: punctuation.definition.binding.array.end.es
        2: meta.brace.square.js # ^BS
      pop: true
    - include: other_illegal

  bindingObject:
    - match: '((\}))'
      captures:
        1: punctuation.definition.binding.object.end.es
        2: meta.brace.curly.js # ^BS
      pop: true
    # BOUND PROPERTY ASSIGNMENT, NORMAL PROPERTY STYLE
    - match: '(({{identifierName}}))\s*((:))'
      captures:
        1: constant.other.object.key.js string.unquoted.label.js # ^BS
        2: entity.other.property-binding.es
        3: constant.other.object.key.js # ^BS
        4: punctuation.separator.property-binding.es
      set: bindingObject_AFTER_PROPERTY
    # BOUND PROPERTY ASSIGNMENT, SAME-NAME SHORTHAND
    - match: '{{allThreeIDs}}'
      captures:
        1: variable.other.readwrite.allCap.es # -BS
        2: variable.other.readwrite.initCap.es
        3: variable.other.readwrite.es
      set: bindingObject_AFTER_ELEM
    # COMPUTED PROPERTY
    - match: '((\[))'
      captures:
        1: punctuation.definition.accessor.begin.es
        2: meta.brace.square.js # ^BS
      set: [ bindingObject_BEFORE_COLON, computedProp_AFTER_AE, assignmentExpression ]
    - match: "'"
      scope: punctuation.definition.string.quoted.single.begin.es
      set: [ bindingObject_BEFORE_COLON, stringSingle_AFTER_OPEN ]
    - match: '"'
      scope: punctuation.definition.string.quoted.double.begin.es
      set: [ bindingObject_BEFORE_COLON, stringDouble_AFTER_OPEN ]
    # REST PROPERTIES
    - match: '\.{3}'
      scope: keyword.other.rest.es # -BS
      set: bindingObject_AFTER_ELLIPSIS
    - include: other_illegal
    # NUMERIC PROPERTY
    - match: '({{decNum}})'
      scope: constant.numeric.decimal.es
      captures:
        1: entity.name.method.es
        2: punctuation.decimal.es
        3: punctuation.decimal.es
        4: punctuation.decimal.es
        5: meta.numeric.exponent.e.es
        6: meta.numeric.exponent.sign.es
        7: meta.numeric.exponent.digit.es
      set: bindingObject_BEFORE_COLON
    - match: '({{binNum}})'
      scope: constant.numeric.binary.es
      captures:
        1: entity.name.method.es
        2: meta.numeric.prefix.es
      set: bindingObject_BEFORE_COLON
    - match: '({{octNum}})'
      scope: constant.numeric.octal.es
      captures:
        1: entity.name.method.es
        2: meta.numeric.prefix.es
      set: bindingObject_BEFORE_COLON
    - match: '({{hexNum}})'
      scope: constant.numeric.hexadecimal.es
      captures:
        1: entity.name.method.es
        2: meta.numeric.prefix.es
      set: bindingObject_BEFORE_COLON

  bindingObject_BEFORE_COLON:
    - match: '((:))'
      captures:
        1: constant.other.object.key.js # ^BS, augmented
        2: punctuation.separator.property-binding.es
      set: bindingObject_AFTER_PROPERTY
    - match: '\}'
      scope: invalid.illegal.token.es
      pop: true
    - include: other_illegal

  bindingObject_AFTER_PROPERTY:
    - match: '((\[))'
      captures:
        1: punctuation.definition.binding.array.begin.es
        2: meta.brace.square.js # ^BS
      set: [ bindingObject_AFTER_ELEM, bindingArray ]
    - match: '((\{))'
      captures:
        1: punctuation.definition.binding.object.begin.es
        2: meta.brace.curly.js # ^BS
      set: [ bindingObject_AFTER_ELEM, bindingObject ]
    # Actually must be an LHS, but we cannot readily describe that constraint:
    - match: '{{PLA_anything}}'
      set: [ bindingObject_AFTER_ELEM, assignmentExpression ]

  bindingObject_AFTER_ELEM:
    - match: '((\}))'
      captures:
        1: punctuation.definition.binding.object.end.es
        2: meta.brace.curly.js # ^BS
      pop: true
    - match: '((,))'
      captures:
        1: punctuation.separator.object-member.binding.es
        2: meta.separator.comma.js # ^BS
      set: bindingObject
    - match: '='
      scope: keyword.operator.assignment.conditional.default.es
      push: assignmentExpression

  bindingObject_AFTER_ELLIPSIS:
    - match: '{{allThreeIDs}}'
      captures:
        1: variable.other.readwrite.allCap.es # -BS
        2: variable.other.readwrite.initCap.es
        3: variable.other.readwrite.es
      set: bindingObject_AFTER_REST_ELEM
    - match: '\}'
      scope: invalid.illegal.token.es
      pop: true
    - include: other_illegal

  bindingObject_AFTER_REST_ELEM:
    - match: '((\}))'
      captures:
        1: punctuation.definition.binding.object.end.es
        2: meta.brace.curly.js # ^BS
      pop: true
    - include: other_illegal

  bindingArray_PARAM:
    - match: '((\]))'
      captures:
        1: punctuation.definition.binding.array.parameter.end.es
        2: meta.brace.square.js # ^BS, augmented
      pop: true
    - match: '((,))'
      captures:
        1: punctuation.separator.array-element.binding.parameter.es
        2: meta.separator.comma.js # ^BS, augmented
    - match: '\.{3}'
      scope: keyword.other.rest.parameter.es # -BS
      set: bindingArray_PARAM_AFTER_ELLIPSIS
    - match: '{{identifier}}'
      scope: variable.parameter.es
      set: bindingArray_PARAM_AFTER_ELEM
    - match: '((\[))'
      captures:
        1: punctuation.definition.binding.array.parameter.begin.es
        2: meta.brace.square.js # ^BS, augmented
      set: [ bindingArray_PARAM_AFTER_ELEM, bindingArray_PARAM ]
    - match: '((\{))'
      captures:
        1: punctuation.definition.binding.object.parameter.begin.es
        2: meta.brace.curly.js # ^BS, augmented
      set: [ bindingArray_PARAM_AFTER_ELEM, bindingObject_PARAM ]
    - include: other_illegal

  bindingArray_PARAM_AFTER_ELEM:
    - match: '((\]))'
      captures:
        1: punctuation.definition.binding.array.parameter.end.es
        2: meta.brace.square.js # ^BS, augmented
      pop: true
    - match: '((,))'
      captures:
        1: punctuation.separator.array-element.binding.parameter.es
        2: meta.separator.comma.js # ^BS, augmented
      set: bindingArray_PARAM
    - match: '='
      scope: keyword.operator.assignment.conditional.default.es
      push: assignmentExpression
    - include: other_illegal

  bindingArray_PARAM_AFTER_ELLIPSIS:
    - match: '{{identifier}}'
      scope: variable.parameter.es
      set: bindingArray_PARAM_AFTER_REST_ELEM
    - match: '\]'
      scope: invalid.illegal.token.es
      pop: true

  bindingArray_PARAM_AFTER_REST_ELEM:
    - match: '((\]))'
      captures:
        1: punctuation.definition.binding.array.parameter.end.es
        2: meta.brace.square.js # ^BS, augmented
      pop: true
    - include: other_illegal

  bindingObject_PARAM:
    - match: '((\}))'
      captures:
        1: punctuation.definition.binding.object.parameter.end.es
        2: meta.brace.curly.js # ^BS, augmented
      pop: true
    # BOUND PROPERTY ASSIGNMENT, NORMAL PROPERTY STYLE
    - match: '(({{identifierName}}))\s*((:))'
      captures:
        1: constant.other.object.key.js string.unquoted.label.js # ^BS, augmented
        2: entity.other.property-binding.parameter.es
        3: constant.other.object.key.js # ^BS, augmented
        4: punctuation.separator.property-binding.parameter.es
      set: bindingObject_PARAM_AFTER_PROPERTY
    # BOUND PROPERTY ASSIGNMENT, SAME-NAME SHORTHAND
    - match: '{{identifier}}'
      scope: variable.parameter.es
      set: bindingObject_PARAM_AFTER_ELEM
    # COMPUTED PROPERTY
    - match: '((\[))'
      captures:
        1: punctuation.definition.accessor.begin.es
        2: meta.brace.square.js # ^BS, augmented
      set: [ bindingObject_PARAM_BEFORE_COLON, computedProp_AFTER_AE, assignmentExpression ]
    - match: "'"
      scope: punctuation.definition.string.quoted.single.parameter.begin.es
      set: [ bindingObject_PARAM_BEFORE_COLON, stringSingle_AFTER_OPEN ]
    - match: '"'
      scope: punctuation.definition.string.quoted.double.parameter.begin.es
      set: [ bindingObject_PARAM_BEFORE_COLON, stringDouble_AFTER_OPEN ]
    # REST PROPERTIES
    - match: '\.{3}'
      scope: keyword.other.rest.parameter.es # -BS
      set: bindingObject_PARAM_AFTER_ELLIPSIS
    - include: other_illegal
    # NUMERIC PROPERTY
    - match: '({{decNum}})'
      scope: constant.numeric.decimal.es
      captures:
        1: entity.name.method.es
        2: punctuation.decimal.es
        3: punctuation.decimal.es
        4: punctuation.decimal.es
        5: meta.numeric.exponent.e.es
        6: meta.numeric.exponent.sign.es
        7: meta.numeric.exponent.digit.es
      set: bindingObject_PARAM_BEFORE_COLON
    - match: '({{binNum}})'
      scope: constant.numeric.binary.es
      captures:
        1: entity.name.method.es
        2: meta.numeric.prefix.es
      set: bindingObject_PARAM_BEFORE_COLON
    - match: '({{octNum}})'
      scope: constant.numeric.octal.es
      captures:
        1: entity.name.method.es
        2: meta.numeric.prefix.es
      set: bindingObject_PARAM_BEFORE_COLON
    - match: '({{hexNum}})'
      scope: constant.numeric.hexadecimal.es
      captures:
        1: entity.name.method.es
        2: meta.numeric.prefix.es
      set: bindingObject_PARAM_BEFORE_COLON

  bindingObject_PARAM_BEFORE_COLON:
    - match: '((:))'
      captures:
        1: constant.other.object.key.js # ^BS, augmented
        2: punctuation.separator.property-binding.parameter.es
      set: bindingObject_PARAM_AFTER_PROPERTY
    - match: '\}'
      scope: invalid.illegal.token.es
      pop: true
    - include: other_illegal

  bindingObject_PARAM_AFTER_PROPERTY:
    - match: '{{identifier}}'
      scope: variable.parameter.es
      set: bindingObject_PARAM_AFTER_ELEM
    - match: '((\[))'
      captures:
        1: punctuation.definition.binding.array.parameter.begin.es
        2: meta.brace.square.js # ^BS, augmented
      set: [ bindingObject_PARAM_AFTER_ELEM, bindingArray_PARAM ]
    - match: '((\{))'
      captures:
        1: punctuation.definition.binding.object.parameter.begin.es
        2: meta.brace.curly.js # ^BS, augmented
      set: [ bindingObject_PARAM_AFTER_ELEM, bindingObject_PARAM ]
    - match: '{{MAT_word_or_any_one_char}}'
      scope: invalid.illegal.token.es
      set: bindingObject_PARAM_AFTER_ELEM

  bindingObject_PARAM_AFTER_ELEM:
    - match: '((\}))'
      captures:
        1: punctuation.definition.binding.object.parameter.end.es
        2: meta.brace.curly.js # ^BS, augmented
      pop: true
    - match: '((,))'
      captures:
        1: punctuation.separator.object-member.binding.parameter.es
        2: meta.delimiter.comma.js # ^BS, augmented
      set: bindingObject_PARAM
    - match: '='
      scope: keyword.operator.assignment.conditional.default.es
      push: assignmentExpression

  bindingObject_PARAM_AFTER_ELLIPSIS:
    - match: '{{identifier}}'
      scope: variable.parameter.es
      set: bindingObject_PARAM_AFTER_REST_ELEM
    - match: '\}'
      scope: invalid.illegal.token.es
      pop: true
    - include: other_illegal

  bindingObject_PARAM_AFTER_REST_ELEM:
    - match: '((\}))'
      captures:
        1: punctuation.definition.binding.object.parameter.end.es
        2: meta.brace.curly.js # ^BS, augmented
      pop: true
    - include: other_illegal

# PARAMETERS & ARGUMENTS #######################################################
# Note: Arguments is inclusive of its final delimiter. Parameters is not.

  arguments:
    - match: '((\)))'
      captures:
        1: punctuation.definition.arguments.end.es
        2: meta.brace.round.js # ^BS
      pop: true
    - match: ','
      scope: invalid.illegal.token.es
    - match: '\.{3}'
      scope: keyword.operator.spread.es
      set: [ arguments_AFTER_AE, assignmentExpression ]
    - match: '{{PLA_anything}}'
      set: [ arguments_AFTER_AE, assignmentExpression ]
    - include: other_illegal

  arguments_AFTER_AE:
    - match: '((\)))'
      captures:
        1: punctuation.definition.arguments.end.es
        2: meta.brace.round.js # ^BS
      pop: true
    - match: ','
      scope: punctuation.separator.argument.es
      set: arguments
    - include: other_illegal

  parameters:
    - match: '((\[))'
      captures:
        1: punctuation.definition.binding.array.parameter.begin.es
        2: meta.brace.square.js # ^ES, augmented
      set: [ parameters_AFTER_PARAM, bindingArray_PARAM ]
    - match: '((\{))'
      captures:
        1: punctuation.definition.binding.object.parameter.begin.es
        2: meta.brace.curly.js # ^ES, augmented
      set: [ parameters_AFTER_PARAM, bindingObject_PARAM ]
    - match: '{{identifier}}'
      scope: variable.parameter.es
      set: parameters_AFTER_PARAM
    - match: '\.{3}(?=\s*\))'
      scope: invalid.illegal.token.es
      pop: true
    - match: '\.{3}'
      scope: keyword.other.rest.parameter.es # -ES
      set: parameters_AFTER_ELLIPSIS
    - include: parameters_AFTER_REST_PARAM

  parameters_AFTER_PARAM:
    - match: ','
      scope: punctuation.separator.parameter.es
      set: parameters
    - match: '='
      scope: keyword.operator.assignment.conditional.default.es
      push: assignmentExpression
    - include: parameters_AFTER_REST_PARAM

  parameters_AFTER_ELLIPSIS:
    - match: '((\[))'
      captures:
        1: punctuation.definition.binding.array.parameter.begin.es
        2: meta.brace.square.js # ^BS
      set: [ parameters_AFTER_REST_PARAM, bindingArray_PARAM ]
    - match: '((\{))'
      captures:
        1: punctuation.definition.binding.object.parameter.begin.es
        2: meta.brace.curly.js # ^BS
      set: [ parameters_AFTER_REST_PARAM, bindingObject_PARAM ]
    - match: '{{identifier}}'
      scope: variable.parameter.rest.es
      set: parameters_AFTER_REST_PARAM
    - include: parameters_AFTER_REST_PARAM

  parameters_AFTER_REST_PARAM:
    - match: '(?=\))'
      pop: true
    - include: other_illegal

# STRINGS & REGEX ##############################################################

  regex_AFTER_OPEN:
    - meta_scope: string.regexp.es
    - meta_include_prototype: false
    # It’s okay to put this here; comments are always matched first.
    - include: regex_COMMON_NOT_IN_CLASS_SET

  regex_ANY_CHILD_CONTEXT:
    # Child contexts are tricky here because we need to be able to terminate
    # the parent context from anywhere. Since the conditions of termination are
    # simple enough, we can just include this lookahead in any child context.
    # The regex root context will then handle the ‘actual’ termination.
    - match: '(?=[\n\/])'
      pop: true

  regex_COMMON_NOT_IN_CLASS_SET:
    - include: regex_COMMON
    # DISJUNCTION
    - match: '\|'
      scope: keyword.operator.or.regexp
    # QUANTIFIERS
    - match: '[\?\*\+]|\{\d+\s*(?:,\s*\d*\s*)?\}'
      scope: keyword.operator.quantifier.regexp
    # CHARACTER CLASSES
    - match: '\['
      scope: punctuation.definition.character-class.begin.regexp
      push: regexp_AFTER_BRACKET
    # ASSERTIONS
    - match: '\(\?!'
      scope: punctuation.definition.assertion.negative.begin.regexp
      push: regex_AFTER_ASSERTION_NEGATIVE_OPEN
    - match: '\(\?='
      scope: punctuation.definition.assertion.positive.begin.regexp
      push: regex_AFTER_ASSERTION_POSITIVE_OPEN
    # GROUPS
    - match: '\(\?:'
      scope: punctuation.definition.group.non-capturing.begin.regexp
      push: regex_AFTER_NON_CAPTURE_OPEN
    - match: '\('
      scope: punctuation.definition.group.capturing.begin.regexp
      push: regex_AFTER_CAPTURE_OPEN

  regex_COMMON:
    - match: '\/'
      scope: punctuation.definition.string.regexp.end.es
      set: regex_AFTER_PATTERN
    - match: '\n'
      scope: invalid.illegal.newline.es
      pop: true
    # ASSERTIONS
    - match: '\\[Bb]|[\$\^]'
      scope: keyword.control.anchor.regexp
    # CHARACTER CLASSES
    - match: '\.|\\[DdSsWw]'
      scope: constant.other.character-class.predefined.regexp
    # BACKREFERENCE
    - match: '\\[1-9]\d*'
      scope: keyword.other.back-reference.regexp
    # ESCAPES
    - match: '\\(c[A-Za-z]|[tnvfr])'
      scope: constant.character.escape.control-char.regexp
    - match: '\\x\h\h'
      scope: constant.character.escape.hexadecimal.regexp
    - match: '\\0(?!\d)'
      scope: constant.character.escape.null.regexp
    - match: '{{unicodeEscape}}'
      scope: constant.character.escape.unicode.regexp
    - match: '\\\/'
      scope: constant.character.escape.regexp
    - match: '\\.'
      scope: constant.character.escape.pointless.regexp

  regexp_AFTER_BRACKET:
    - meta_scope: constant.other.character-class.set.regexp
    - meta_include_prototype: false
    - match: '(?<=\[)\^'
      scope: keyword.operator.negation.regexp
    - match: '-'
      scope: punctuation.definition.character-class.dash.regexp
    - match: '\]'
      scope: punctuation.definition.character-class.end.regexp
      pop: true
    - match: '\/'
    - include: regex_ANY_CHILD_CONTEXT
    - include: regex_COMMON

  regex_AFTER_ASSERTION_NEGATIVE_OPEN:
    - meta_scope: meta.group.assertion.negative.regexp
    - meta_include_prototype: false
    - match: '\)'
      scope: punctuation.definition.assertion.negative.end.regexp
      pop: true
    - include: regex_ANY_CHILD_CONTEXT
    - include: regex_COMMON_NOT_IN_CLASS_SET

  regex_AFTER_ASSERTION_POSITIVE_OPEN:
    - meta_scope: meta.group.assertion.positive.regexp
    - meta_include_prototype: false
    - match: '\)'
      scope: punctuation.definition.assertion.positive.end.regexp
      pop: true
    - include: regex_ANY_CHILD_CONTEXT
    - include: regex_COMMON_NOT_IN_CLASS_SET

  regex_AFTER_NON_CAPTURE_OPEN:
    - meta_scope: meta.group.non-capturing.regexp
    - meta_include_prototype: false
    - match: '\)'
      scope: punctuation.definition.group.non-capturing.end.regexp
      pop: true
    - include: regex_ANY_CHILD_CONTEXT
    - include: regex_COMMON_NOT_IN_CLASS_SET

  regex_AFTER_CAPTURE_OPEN:
    - meta_scope: meta.group.capturing.regexp
    - meta_include_prototype: false
    - match: '\)'
      scope: punctuation.definition.group.capturing.end.regexp
      pop: true
    - include: regex_ANY_CHILD_CONTEXT
    - include: regex_COMMON_NOT_IN_CLASS_SET

  regex_AFTER_PATTERN:
    - meta_include_prototype: false
    - match: >-
        (?x) ((
          ([gimyu])
          (?:
            (?!\3) ([gimyu])
            (?:
              (?!\3|\4) ([gimyu])
              (?:
                (?!\3|\4|\5) ([gimyu])
                (?:
                  (?!\3|\4|\5|\6) ([gimyu])
                )?
              )?
            )?
          )?
          ))
          {{idEnd}}
      captures:
        1: string.regexp.js keyword.other.js # ^BS
        2: string.regexp.flags.es
      set: else_pop
    - match: '\w+'
      scope: invalid.illegal.token
      pop: true
    - include: else_pop

  stringDouble_AFTER_OPEN:
    - meta_scope: string.quoted.double.es
    - meta_include_prototype: false
    - match: '\\"'
      scope: constant.character.escape.es
    - match: '"'
      scope: punctuation.definition.string.quoted.double.end.es
      pop: true
    - include: string_COMMON_QUOTED

  stringSingle_AFTER_OPEN:
    - meta_scope: string.quoted.single.es
    - meta_include_prototype: false
    - match: '\\'''
      scope: constant.character.escape.es
    - match: "'"
      scope: punctuation.definition.string.quoted.single.end.es
      pop: true
    - include: string_COMMON_QUOTED

  templateString_AFTER_OPEN:
    - meta_scope: string.interpolated.es # -BS (throughout, exceptions noted)
    - meta_include_prototype: false
    - match: '\\[`\$\{]'
      scope: constant.character.escape.es
    - match: '\\\n'
      scope: constant.character.escape.pointless.es
    - include: string_COMMON_ESCAPES
    - match: '`'
      scope: punctuation.definition.string.interpolated.end.es
      pop: true
    - match: '((\$\{))'
      captures:
        1: entity.quasi.element.js punctuation.quasi.element.begin.js # ^BS
        2: punctuation.definition.string.interpolated.element.begin.es
      set: [ templateString_ELEMENT, expression ]

  templateString_ELEMENT:
    - match: '((\}))'
      captures:
        1: entity.quasi.element.js punctuation.quasi.element.end.js # ^BS
        2: punctuation.definition.string.interpolated.element.end.es
      set: templateString_AFTER_OPEN
    - include: other_illegal_pop

  string_COMMON_QUOTED:
    - include: string_COMMON_ESCAPES
    - match: '\\\n'
      scope: constant.character.escape.newline.es
    - match: '\n'
      scope: invalid.illegal.newline.es
      pop: true

  string_COMMON_ESCAPES:
    - match: '\\[\\bfnrtv]'
      scope: constant.character.escape.es
    - match: '{{unicodeEscape}}'
      scope: constant.character.escape.unicode.es
    - match: '\\x\h\h'
      scope: constant.character.escape.hexadecimal.es
    - match: '\\(?:[1-7][0-7]{0,2}|[0-7]{2,3})'
      scope: invalid.illegal.octal-escape.es
    - match: '\\0'
      scope: constant.character.escape.null.es
    - match: '\\.'
      scope: constant.character.escape.pointless.es

  useStrict:
    - match: '(('')use strict(''))'
      scope: string.quoted.single.es
      captures:
        1: meta.directive.use-strict.es
        2: punctuation.definition.string.quoted.single.begin.es
        3: punctuation.definition.string.quoted.single.end.es
    - match: '((")use strict("))'
      scope: string.quoted.double.es
      captures:
        1: meta.directive.use-strict.es
        2: punctuation.definition.string.quoted.double.begin.es
        3: punctuation.definition.string.quoted.double.end.es

# JSX EXTENSIONS ###############################################################

  ae_JSX:
    - match: '<'
      scope: punctuation.definition.tag.begin.jsx
      set: [ ae_AFTER_THING, ae_JSX_ELEMENT ]

  ae_JSX_ATTRIBUTES:
    - match: '\{'
      scope: punctuation.definition.interpolation.begin.jsx
      set:
        - meta_scope: meta.interpolation.jsx
        - match: '\.{3}'
          scope: keyword.operator.spread.jsx
          set: [ ae_JSX_ATTRIBUTES_INTERPOLATION_END, assignmentExpression ]
        - include: other_illegal
    - match: '(({{jsxIdentifer}})(:){{jsxIdentifer}})'
      captures:
        1: variable.other.attribute.jsx
        2: meta.namespace.jsx
        3: punctuation.separator.namespace.jsx
      set: ae_JSX_ATTRIBUTES_VALUE
    - match: '{{jsxIdentifer}}'
      scope: variable.other.attribute.jsx
      set: ae_JSX_ATTRIBUTES_VALUE
    - match:  '/>'
      scope: punctuation.definition.tag.end.jsx
      pop: true
    - match:  '>'
      scope: punctuation.definition.tag.end.jsx
      set: [ ae_JSX_ELEMENT_CLOSE, ae_JSX_CONTENT ]
    - include: other_illegal

  ae_JSX_ATTRIBUTES_DOUBLE:
    - meta_include_prototype: false
    - meta_scope: 'string.attribute.jsx'
    - match: '"'
      scope: punctuation.definition.attribute.end.jsx
      pop: true

  ae_JSX_ATTRIBUTES_INTERPOLATION_END:
    - meta_scope: meta.interpolation.jsx
    - match: '\}'
      scope: punctuation.definition.interpolation.end.jsx
      set: ae_JSX_ATTRIBUTES
    - include: other_illegal

  ae_JSX_ATTRIBUTES_SINGLE:
    - meta_include_prototype: false
    - meta_scope: 'string.attribute.jsx'
    - match: ''''
      scope: punctuation.definition.attribute.end.jsx
      pop: true

  ae_JSX_ATTRIBUTES_VALUE:
    - match: '='
      scope: punctuation.separator.attribute-value.jsx
      set:
        - match: '"'
          scope: punctuation.definition.attribute.begin.jsx
          set: [ ae_JSX_ATTRIBUTES, ae_JSX_ATTRIBUTES_DOUBLE ]
        - match: ''''
          scope: punctuation.definition.attribute.begin.jsx
          set: [ ae_JSX_ATTRIBUTES, ae_JSX_ATTRIBUTES_SINGLE ]
        - match: '\{'
          scope: punctuation.definition.interpolation.begin.jsx
          set: [ ae_JSX_ATTRIBUTES_INTERPOLATION_END, assignmentExpression ]
        - match: '<'
          scope: punctuation.definition.tag.begin.jsx
          set: [ ae_JSX_ATTRIBUTES, ae_JSX_ELEMENT ]
        - include: other_illegal
    - match: '(?<=\s)|(?=[\>\{])'
      set: ae_JSX_ATTRIBUTES
    - include: other_illegal

  ae_JSX_CONTENT:
    - meta_include_prototype: false
    - match: '&[^&;\{\}<>\s]+;'
      scope: variable.other.entity-reference.jsx
    - match: '[^\{\}<>]'
      scope: string.text.jsx
    - match: '\{'
      scope: punctuation.definition.interpolation.begin.jsx
      set: ae_JSX_CONTENT_INTERPOLATION
    - match: '<(?!\/)'
      scope: punctuation.definition.tag.begin.jsx
      push: ae_JSX_ELEMENT
    - include: else_pop

  ae_JSX_CONTENT_INTERPOLATION:
    - meta_scope: meta.interpolation.jsx
    - match: '\}'
      scope: punctuation.definition.interpolation.end.jsx
      set: ae_JSX_CONTENT
    - match: '{{PLA_anything}}'
      set: [ ae_JSX_CONTENT_INTERPOLATION_END, assignmentExpression ]

  ae_JSX_CONTENT_INTERPOLATION_END:
    - meta_scope: meta.interpolation.jsx
    - match: '\}'
      scope: punctuation.definition.interpolation.end.jsx
      set: ae_JSX_CONTENT
    - include: other_illegal

  ae_JSX_DOT:
    - match: '\.'
      scope: keyword.operator.accessor.jsx
      push:
        - match: '{{jsxIdentifer}}'
          scope: entity.name.tag.jsx
          pop: true
        - include: other_illegal
    - include: else_pop

  ae_JSX_ELEMENT:
    - match: '(({{jsxIdentifer}})(:){{jsxIdentifer}})'
      captures:
        1: entity.name.tag.jsx
        2: meta.namespace.jsx
        3: punctuation.separator.namespace.jsx
      set: [ ae_JSX_ATTRIBUTES, ae_JSX_DOT ]
    - match: '{{jsxIdentifer}}'
      scope: entity.name.tag.jsx
      set: [ ae_JSX_ATTRIBUTES, ae_JSX_DOT ]
    - include: other_illegal

  ae_JSX_ELEMENT_CLOSE:
    - match: '</'
      scope: punctuation.definition.tag.begin.jsx
      set:
        - match: '(({{jsxIdentifer}})(:){{jsxIdentifer}})'
          captures:
            1: entity.name.tag.jsx
            2: meta.namespace.jsx
            3: punctuation.separator.namespace.jsx
          set: [ ae_JSX_ELEMENT_CLOSE_end, ae_JSX_DOT ]
        - match: '{{jsxIdentifer}}'
          scope: entity.name.tag.jsx
          set: [ ae_JSX_ELEMENT_CLOSE_end, ae_JSX_DOT ]
        - include: other_illegal
    - include: other_illegal

  ae_JSX_ELEMENT_CLOSE_end:
    - match: '>'
      scope: punctuation.definition.tag.end.jsx
      pop: true
    - include: other_illegal

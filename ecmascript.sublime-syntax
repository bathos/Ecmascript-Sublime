%YAML 1.2
---
name: Ecmascript
file_extensions: [ js, jsx, es, es6, mjs ]
scope: source.es

# This file is hidden from the syntax menu since the parent syntax `source.js`
# will push this scope onto the stack automatically.
hidden: true

# es 20:15
# though I walk through the valley of the shadow
# of PHP, I will fear no feature creep, for Crockford and Eich...

# Captures with the ^BS suffix are included for interoperability with themes
# that target Babel Sublime or JS Next. This is not always possible to achieve
# since there are cases where one would always clobber the other. In some cases
# you will see "^BS, adapted" or "^BS, partial", indicating scopes which may not
# lead to 1:1 exact coloring between themes but will nonetheless appear
# harmonious. "-BS" indicates cases where it would not be good to include these
# fallback scopes for various reasons, though they won’t cause any real coloring
# problems; in fact some are improvments where we’ve disambiguated a previous
# conflation. Captures with no ‘BS’ annotations either correspond directly
# already to, or are more specific versions of, scopes from BS & JSNext.

variables:
  # CONTEXT CONTROL PATTERNS ###################################################
  MAT_word_or_any_one_char: '\w+|\S'
  PLA_anything: '(?=[\S\s])'

  # UNICODE PROPERTY CLASS SHIMS ###############################################
  ID_Continue: '{{ID_Start}}\p{Mn}\p{Mc}\p{Nd}\p{Pc}{{Other_ID_Continue}}'
  ID_Start: '\p{L}\p{Nl}{{Other_ID_Start}}'
  Other_ID_Continue: '··፩-፱᧚'
  Other_ID_Start: '℘℮゛゜'

  # OTHER CHARACTER GROUPS #####################################################
  boxchars: '[─-╿▀-▟]+'
  whiteNoLine: '[\s&&[^\n\r]]+'

  # KEYWORDS ###################################################################
  # The absence of ‘async’ in reserved is intentional (due to the Node library
  # by that name). Note ‘keywordOther’ includes what are technically identifiers
  # rather than keywords, but for practical purposes they may be considered to
  # belong to the latter group (they may not actually be redefined anymore).
  keywordLanguage: >-
    break | case | catch | class | const | continue | debugger | default |
    delete | do | else | export | extends | finally | for | function | if |
    import | in | instanceof | let | new | return | super | switch | this |
    throw | try | typeof | var | void | while | with | yield
  keywordReserved: >-
    await | enum | implements | interface |
    package | private | protected | public
  keywordLiteral: >-
    false | null | true
  keywordOther: >-
    Infinity | NaN | undefined
  reservedWords: >-
    {{keywordLanguage}}|
    {{keywordReserved}}|
    {{keywordLiteral}}|
    {{keywordOther}}

  # IDENTIFIERS ################################################################
  identifier: >-
    (?x)
      (?! (?:{{reservedWords}})
      [^\$_‍‍{{ID_Continue}}] )
      (?<![{{ID_Continue}}])
      {{identifierName}}
  identifierInitCap: '(?:\p{Lu}{{identifierPart}}){{idEnd}}'
  identifierInitCapStrict: >-
    (?x)
      (?! (?:{{reservedWords}})
      [^\$_‍‍{{ID_Continue}}] )
      (?<![{{ID_Continue}}])
      {{identifierInitCap}}
  identifierAllCaps: '(?:[\p{Lu}\d_]{2,}|\p{Lu}){{idEnd}}'
  identifierAllCapsStrict: >-
    (?x)
      (?! (?:{{reservedWords}})
      [^\$_‍‍{{ID_Continue}}] )
      (?<![{{ID_Continue}}])
      {{identifierAllCaps}}
  identifierName: '{{identifierStart}}{{identifierPart}}'
  identifierPart: '(?:[\$_‍‍{{ID_Continue}}]|{{unicodeEscape}})*' # ZWN?J after _
  identifierStart: '(?:[\$_{{ID_Start}}]|{{unicodeEscape}})'
  allThreeIDs: '({{identifierAllCaps}})|({{identifierInitCap}})|({{identifier}})'
  unicodeEscape: '\\u(?:\h{4}|\{\h+\})'
  jsxComponentIdentifier: '{{identifierInitCapStrict}}'
  jsxElementIdentifier: '{{identifierName}}(?:-(?:{{identifierPart}})*)*'
  jsxNamespaceIdentifier: '({{identifierInitCapStrict}})(\.)'

  # WELL-KNOWN IDENTIFIERS #####################################################
  # Note, Symbol is not a real constructor -- but even ECMA 262 calls it one.

  intrinsicConstructors: >-
    Array(?:Buffer)? | BigInt | Big(Ui|I)nt64Array | Boolean | Date |
    DataView | (?:Eval|Range|Reference|Syntax|Type|URI)?Error |
    Float(?:32|64)Array | Function | Int(?:8|16|32)Array |
    Number | Object | Promise | Proxy | RegExp | SharedArrayBuffer |
    String | Symbol | Uint(?:8(?:Clamped)?|16|32)Array | (?:Weak)?(?:Map|Set)
  intrinsicFunctions: >-
    (?:de|en)codeURI(?:Component)? |
    eval | is(?:Finite|NaN) | parse(?:Float|Int)

  # NUMERIC LITERALS ###########################################################

  binNum: '(0[Bb])(?:[01]+(?:_+[01]+)*)(n)?'
  octNum: '(0[Oo])(?:[0-7]+(?:_+[0-7]+)*)(n)?'

  # Decimal has 7 captures: dec, dec, dec, exp-e, exp-sign, exp-dig, big-int-suf
  decNum: >-
    (?x)
      (?:
        0 (?: (\.) (?:\d+ (?:_+\d+)* )? )? |
        [1-9](?:_*\d+)* (?: (\.) (?:\d+ (?:_+\d+)*)? )? |
        (\.) \d+ (?:_+\d+)*
      )
      (?: ([Ee]) ([\+\-])? (\d+ (?:_+\d+)*) )?
      (n)?
      {{idEnd}}

  hexNum: '(0[Xx])(?:\h+(?:_+\h+)*)(n)?'

  # LOOKAHEADS #################################################################
  idEnd: '(?=[^\$_‍‍{{ID_Continue}}]|$)'

  # SYNTAX DIRECTIVES ##########################################################
  syntaxDirectiveHead: '(\s*syntax\s*:\s*)'
  syntaxDirectiveTail: '\s*(\*\/)\s*(({{identifier}}))?(?=\s*`)'

  syntaxDirective_CSS:                    '([Cc](?:ss|SS))(){{syntaxDirectiveTail}}'
  syntaxDirective_CSS_STYLE:              '([Cc](?:ss|SS))([.#][Ss]tyle){{syntaxDirectiveTail}}'
  syntaxDirective_DOT:                    '([Dd](?:ot|OT))(){{syntaxDirectiveTail}}'
  syntaxDirective_GLSL:                   '([Gg](?:lsl|LSL))(){{syntaxDirectiveTail}}'
  syntaxDirective_HTML:                   '([Hh](?:tml|TML))(){{syntaxDirectiveTail}}'
  syntaxDirective_JS:                     '([Jj](?:ava|AVA)?[Ss](?:cript|CRIPT)?)(){{syntaxDirectiveTail}}'
  syntaxDirective_JS_VALUE:               '([Jj](?:ava|AVA)?[Ss](?:cript|CRIPT)?)([.#][Vv]alue){{syntaxDirectiveTail}}'
  syntaxDirective_JS_METHOD:              '([Jj](?:ava|AVA)?[Ss](?:cript|CRIPT)?)([.#][Mm]ethod){{syntaxDirectiveTail}}'
  syntaxDirective_JS_REGEXP:              '([Jj](?:ava|AVA)?[Ss](?:cript|CRIPT)?)([.#][Rr]egexp?){{syntaxDirectiveTail}}'
  syntaxDirective_JS_OBJECT_LITERAL:      '([Jj](?:ava|AVA)?[Ss](?:cript|CRIPT)?)([.#][Oo]bject-[Ll]iteral){{syntaxDirectiveTail}}'
  syntaxDirective_JS_SIMPLE:              '([Jj](?:ava|AVA)?[Ss](?:cript|CRIPT)?-[Ss](?:imple|IMPLE)){{syntaxDirectiveTail}}'
  syntaxDirective_JSON:                   '([Jj](?:son|SON))(){{syntaxDirectiveTail}}'
  syntaxDirective_LUA:                    '([Ll](?:ua|UA))(){{syntaxDirectiveTail}}'
  syntaxDirective_MARKDOWN:               '([Mm](?:ark[Dd](?:own|OWN)|ARKDOWN|[Dd]))(){{syntaxDirectiveTail}}'
  syntaxDirective_SHELL:                  '([Bb](?:ash|ASH)|[Ss](?:hell|HELL))(){{syntaxDirectiveTail}}'
  syntaxDirective_SQL:                    '([Ss](?:ql|QL))(){{syntaxDirectiveTail}}'
  syntaxDirective_SUBLIME_SYNTAX:         '([Ss](?:ublime-?[Ss]yntax|UBLIME-SYNTAX))(){{syntaxDirectiveTail}}'
  syntaxDirective_SUBLIME_SYNTAX_CONTEXT: '([Ss](?:ublime-?[Ss]yntax|UBLIME-SYNTAX))([.#][Cc]ontexts?){{syntaxDirectiveTail}}'
  syntaxDirective_SUBLIME_SYNTAX_REGEX:   '([Ss](?:ublime-?[Ss]yntax|UBLIME-SYNTAX))([.#][Rr]egexp?){{syntaxDirectiveTail}}'
  syntaxDirective_XML:                    '([Xx](?:ml|ML))(){{syntaxDirectiveTail}}'
  syntaxDirective_YAML:                   '([Yy](?:aml|AML))(){{syntaxDirectiveTail}}'

  syntaxDirective: >-
    (?x)
      ((\/\*)){{syntaxDirectiveHead}}
      (?= {{syntaxDirective_CSS}}
        | {{syntaxDirective_CSS_STYLE}}
        | {{syntaxDirective_DOT}}
        | {{syntaxDirective_GLSL}}
        | {{syntaxDirective_HTML}}
        | {{syntaxDirective_JS}}
        | {{syntaxDirective_JS_VALUE}}
        | {{syntaxDirective_JS_METHOD}}
        | {{syntaxDirective_JS_REGEXP}}
        | {{syntaxDirective_JS_OBJECT_LITERAL}}
        | {{syntaxDirective_JS_SIMPLE}}
        | {{syntaxDirective_JSON}}
        | {{syntaxDirective_LUA}}
        | {{syntaxDirective_MARKDOWN}}
        | {{syntaxDirective_SHELL}}
        | {{syntaxDirective_SQL}}
        | {{syntaxDirective_SUBLIME_SYNTAX}}
        | {{syntaxDirective_SUBLIME_SYNTAX_CONTEXT}}
        | {{syntaxDirective_SUBLIME_SYNTAX_REGEX}}
        | {{syntaxDirective_XML}}
        | {{syntaxDirective_YAML}}
      )

contexts:

# MAIN, META & PROTOTYPE #######################################################

  main:
    - meta_include_prototype: false
    # SHEBANG
    - match: '^(\#\!)(.*)'
      scope: comment.line.shebang.es
      captures:
        1: punctuation.definition.comment.begin.es
        2: meta.comment.body.es
      set: root
    - match: '{{PLA_anything}}'
      set: root

  root:
    - include: useStrict
    # IMPORT DECLARATION
    - match: '((import)){{idEnd}}(?!\s*[\(\.])'
      captures:
        1: storage.type.module.import.es
        2: keyword.operator.module.js # ^BS
      push: moduleDeclaration_AFTER_IMPORT
    # EXPORT DECLARATION
    - match: '((export)){{idEnd}}'
      captures:
        1: storage.type.module.export.es
        2: keyword.operator.module.js # ^BS
      push: moduleDeclaration_AFTER_EXPORT
    # STATEMENT LIST
    - include: statements

  prototype:
    - include: safe_prototype
    - include: non_syntax_block_comment

  safe_prototype:
    # Captured for practical reasons (keeps other patterns simpler)
    - match: '\s+'
      scope: meta.whitespace.es
    # MERGE CONFLICTS
    - match: '<<<<<<< (.+)\n'
      scope: 'invalid.merge-conflict.delimiter.our-changes'
      push: merge_conflict_our_changes
    # COMMENTS
    - match: '((\/\/))'
      captures:
        1: meta.comment.border.es
        2: punctuation.definition.comment.begin.es
      push:
        - meta_scope: comment.line.es
        - match: '\n'
          pop: true
        - match: '\/\/+'
          scope: meta.comment.border.es
        - match: '{{boxchars}}'
          scope: meta.comment.box-drawing.es
        - match: '\b(?i:todo|hack)\b'
          scope: comment.line.todo.es

  non_syntax_block_comment:
    - match: '((\/\*))(?!{{syntaxDirectiveHead}})'
      captures:
        1: meta.comment.border.es
        2: punctuation.definition.comment.begin.es
      push: inside_block_comment

  block_comment:
    - match: '((\/\*))'
      captures:
        1: meta.comment.border.es
        2: punctuation.definition.comment.begin.es
      push: inside_block_comment

  inside_block_comment:
    - meta_scope: comment.block.es
    - match: '((?:\*+)?(\*\/))'
      captures:
        1: meta.comment.border.es
        2: punctuation.definition.comment.end.es
      pop: true
    - match: '(^\/)?((?!\*\/)\*)+'
      scope: meta.comment.border.es
    - match: '{{boxchars}}'
      scope: meta.comment.box-drawing.es
    - match: '\b(?i:todo|hack)\b'
      scope: comment.line.todo.es

  merge_conflict_our_changes:
    - meta_scope: invalid.merge-conflict.our-changes
    - match: '=======\n'
      scope: 'invalid.merge-conflict.delimiter.separator'
      set: merge_conflict_their_changes

  merge_conflict_their_changes:
    - meta_scope: invalid.merge-conflict.their-changes
    - match: '>>>>>>> (.+)\n'
      scope: 'invalid.merge-conflict.delimiter.their-changes'
      pop: true

  # If no match has been made, gently and quietly pop
  else_pop:
    - match: '{{PLA_anything}}'
      pop: true

  # Associated with a handful of "no-line-terminator-here" statements.
  optional_semicolon_pop:
    - match: '$'
      pop: true
    - match: ';'
      scope: punctuation.terminator.statement.es
      pop: true
    - include: else_pop

  # Similar to above but used when a single statement in an if or do may have
  # been an expression statement.
  semicolon_maybe:
    - match: ';'
      scope: punctuation.terminator.statement.es
      pop: true
    - include: else_pop

  # Brand the evil token, but stand your ground.
  other_illegal:
    - match: '{{MAT_word_or_any_one_char}}'
      scope: invalid.illegal.token.es

  # Reject it and run.
  other_illegal_pop:
    - match: '{{MAT_word_or_any_one_char}}'
      scope: invalid.illegal.token.es
      pop: true

# STATEMENTS ###################################################################

  statements:
    # THE NOBLE EMPTY STATEMENT
    - match: ';'
      scope: punctuation.terminator.statement.es
    # Or,
    - match: '{{PLA_anything}}'
      push: statement # note push

  statement:
    - match: ';'
      scope: punctuation.terminator.statement.es
      pop: true
    # BLOCK STATEMENT
    - match: '((\{))'
      captures:
        1: punctuation.definition.block.begin.es
        2: meta.brace.curly.js # ^BS
      set: blockStatement
    # IF STATEMENT
    - match: 'if{{idEnd}}'
      scope: keyword.control.conditional.if.es
      set: ifStatement_AFTER_IF
    # DO STATEMENT
    - match: 'do{{idEnd}}'
      scope: keyword.control.loop.do.es
      set: doStatement_AFTER_DO
    # LET DECLARATION
    - match: 'let{{idEnd}}'
      scope: storage.type.variable.let.es
      set: constLetVarDeclaration_AFTER_WORD
    # VAR DECLARATION
    - match: 'var{{idEnd}}'
      scope: storage.type.variable.var.es
      set: constLetVarDeclaration_AFTER_WORD
    # FOR STATEMENT
    - match: 'for{{idEnd}}'
      scope: keyword.control.loop.for.es
      set: forStatement_AFTER_FOR
    # TRY STATEMENT
    - match: 'try{{idEnd}}'
      scope: keyword.control.trycatch.try.es
      set: tryStatement_AFTER_TRY
    # WITH STATEMENT
    - match: 'with{{idEnd}}'
      scope: keyword.control.with.es # -BS
      set: withStatement_AFTER_WITH
    # CONST DECLARATION
    - match: 'const{{idEnd}}'
      scope: storage.type.constant.es
      set: constLetVarDeclaration_AFTER_WORD
    # CLASS DECLARATION
    - match: 'class{{idEnd}}'
      scope: storage.type.class.es
      set: classDeclaration_AFTER_CLASS
    # WHILE STATEMENT
    - match: 'while{{idEnd}}'
      scope: keyword.control.loop.while.es
      set: whileStatement_AFTER_WHILE
    # THROW STATEMENT
    - match: 'throw{{idEnd}}'
      scope: keyword.control.flow.throw.es # -BS
      set: throwStatement
    # BREAK STATEMENT
    - match: 'break{{idEnd}}'
      scope: keyword.control.flow.break.es # -BS
      set: breakOrContinue_AFTER_WORD
    # RETURN STATEMENT
    - match: 'return{{idEnd}}'
      scope: keyword.control.flow.return.es
      set: returnStatement
    # SWITCH STATEMENT
    - match: 'switch{{idEnd}}'
      scope: keyword.control.switch.es
      set: switchStatement_AFTER_SWITCH
    # * GENERATOR DECLARATION
    - match: '((function))\s*((\*))'
      captures:
        1: storage.type.function.js # ^BS -- Cobalt
        2: storage.type.function.generator.es
        3: keyword.generator.asterisk.js # ^BS
        4: storage.modifier.generator.asterisk.es
      set: generatorDeclaration_AFTER_ASTERISK
    # FUNCTION DECLARATION
    - match: '((function)){{idEnd}}(?!\s*\.)'
      captures:
        1: storage.type.function.js # ^BS -- Cobalt
        2: storage.type.function.es
      set: functionDeclaration_AFTER_FUNCTION
    # ASYNC DECLARATION
    - match: '(async)\s*((function)){{idEnd}}'
      captures:
        1: storage.modifier.async.es # -BS
        2: storage.type.function.js # ^BS -- Cobalt
        3: storage.type.function.async.es
      set: asyncDeclaration_AFTER_FUNCTION
    # CONTINUE STATEMENT
    - match: 'continue{{idEnd}}'
      scope: keyword.control.flow.continue.es # -BS
      set: breakOrContinue_AFTER_WORD
    # DEBUGGER STATEMENT
    - match: 'debugger{{idEnd}}'
      scope: keyword.other.debugger.es
      set: optional_semicolon_pop
    # * LABELLED STATEMENT (note: does not pop or transition)
    - match: '(({{identifier}})\s*(:(?!:)))'
      captures:
        1: constant.other.object.key.js string.unquoted.label.js # ^BS, adapted
        2: entity.name.statement.es
        3: punctuation.separator.label-statement.es # -BS
    # DECORATED CLASS DECLARATION
    - match: '((@))'
      captures:
        1: punctuation.definition.tag.js # ^BS
        2: punctuation.definition.decorator.es
      set: [ classDeclaration_AFTER_DECORATOR, decoratorExpression ]
    # EMPTY STATEMENT
    - match: ';'
      scope: punctuation.terminator.statement.es
    # EXPRESSION STATEMENT
    # Though expression statements are a subset of possible expressions, the
    # disallowed cases are all captured by previous matches.
    - include: expression

  blockStatement:
    - match: '((\}))'
      captures:
        1: punctuation.definition.block.end.es
        2: meta.brace.curly.js # ^BS
      pop: true
    - include: statements

  breakOrContinue_AFTER_WORD:
    - match: '$|(?=\})'
      pop: true
    - match: ';'
      scope: punctuation.terminator.statement.es
      pop: true
    - match: '(({{identifier}}))'
      captures:
        1: constant.other.object.key.js string.unquoted.label.js # ^BS, adapted
        2: entity.name.statement.es
      set: optional_semicolon_pop
    - include: else_pop

  doStatement_AFTER_DO:
    - match: '((\{))'
      captures:
        1: punctuation.definition.block.loop.begin.es
        2: meta.brace.curly.js # ^BS
      set: doStatement_STMT_AFTER_BRACE
    - match: '{{PLA_anything}}'
      set: [ doStatement_AFTER_STMT, semicolon_maybe, statement ]

  doStatement_STMT_AFTER_BRACE:
    - match: '((\}))'
      captures:
        1: punctuation.definition.block.loop.end.es
        2: meta.brace.curly.js # ^BS
      set: doStatement_AFTER_STMT
    - include: statements

  doStatement_AFTER_STMT:
    - match: 'while{{idEnd}}'
      scope: keyword.control.loop.while.es
      set: doStatement_AFTER_WHILE
    - include: else_pop

  doStatement_AFTER_WHILE:
    - match: '((\())'
      captures:
        1: punctuation.definition.expression.loop.begin.es
        2: meta.brace.round.js # ^BS
      set: [ doStatement_AFTER_EXP, expression ]
    - include: other_illegal_pop

  doStatement_AFTER_EXP:
    - match: '((\)))'
      captures:
        1: punctuation.definition.expression.loop.end.es
        2: meta.brace.round.js # ^BS
      pop: true
    - include: other_illegal

  forStatement_AFTER_FOR:
    - match: '((\())'
      captures:
        1: punctuation.definition.expression.loop.begin.es
        2: meta.brace.round.js # ^BS
      set: forStatement_AFTER_PAREN_OPEN
    - match: 'await{{idEnd}}'
      scope: keyword.control.flow.await
      set:
        - match: '((\())'
          captures:
            1: punctuation.definition.expression.loop.begin.es
            2: meta.brace.round.js # ^BS
          set: forStatement_AFTER_PAREN_OPEN
        - include: other_illegal_pop
    - match: '(each){{idEnd}}'
      scope: keyword.control.flow.loop.es
      captures:
        1: invalid.deprecated.es
      set: forStatement_AFTER_EACH
    - include: other_illegal_pop

  forStatement_AFTER_EACH:
    - match: '((\())'
      captures:
        1: punctuation.definition.expression.loop.begin.es
        2: meta.brace.round.js # ^BS
      set: forStatement_AFTER_PAREN_OPEN
    - include: other_illegal_pop

  forStatement_AFTER_PAREN_OPEN:
    # This is an exceedingly tricky area. Consistently differentiating between
    # the three types of ‘for’ statements isn’t only impossible due to the need
    # for lookaheads that may cross lines -- it’s complicated by the fact that
    # any of the tokens we might wish to seek are themselves valid in every
    # other possible pattern if contextualized correctly. While not so terrible
    # generally if it meant only that we were more permissive of malformed
    # syntax, the problem mainly concerns difficulty with distinguishing the
    # homonym ‘in’ (operator vs control keyword).
    #
    # Our best bet, as far as I can tell, is to use the existence of a non-
    # terminal semi-colon as a heuristic indicator that this is a ‘legacy’ for
    # loop. This can be refined further by saying it doesn’t count if ‘in’
    # appeared before the first semicolon, since for-;; loops disallow this
    # expressly.

    # The expression (series) ends abruptly.
    - match: '\)'
      scope: invalid.illegal.token.es
      set: whileOrForStatement_STMT
    # The line contains a non-terminal semicolon, but not after 'in' or 'of'.
    - match: '(?=(?![^;]+\b(in|of)\b).*;.)'
      set: forStatement_EXP_LEGACY_INIT
    # At this point we believe we are in a for-in or for-of loop. Though the
    # circumstances that would lead to this being false would be unusual in
    # practice, we now stand a tiny chance of breaking highlighting. To make it
    # work, we need a whole duplicative version of the expression ‘tree’ that
    # exists only to disallow the ‘in’ operator.
    - match: 'var{{idEnd}}'
      scope: storage.type.variable.var.es
      set: forStatement_IN_OR_OF_DECLARATION_AFTER_WORD
    - match: 'let{{idEnd}}'
      scope: storage.type.variable.let.es
      set: forStatement_IN_OR_OF_DECLARATION_AFTER_WORD
    - match: 'const{{idEnd}}'
      scope: storage.type.constant.es
      set: forStatement_IN_OR_OF_DECLARATION_AFTER_WORD
    - match: '{{PLA_anything}}'
      set: [ forStatement_IN_OR_OF_AFTER_BINDING, assignmentExpression_NO_IN ] # (lhse)

  forStatement_EXP_LEGACY_INIT:
    - match: ';'
      scope: punctuation.separator.loop-expression.es # -BS
      set: forStatement_EXP_LEGACY_COND
    - match: '\)'
      scope: invalid.illegal.token.es
      set: whileOrForStatement_STMT
    - match: 'var{{idEnd}}'
      scope: storage.type.variable.var.es
      set: [ forStatement_EXP_LEGACY_INIT_AFTER_EXP, constLetVarDeclaration_AFTER_WORD ]
    - match: 'let{{idEnd}}'
      scope: storage.type.variable.let.es
      set: [ forStatement_EXP_LEGACY_INIT_AFTER_EXP, constLetVarDeclaration_AFTER_WORD ]
    - match: 'const{{idEnd}}'
      scope: storage.type.constant.es
      set: [ forStatement_EXP_LEGACY_INIT_AFTER_EXP, constLetVarDeclaration_AFTER_WORD ]
    - match: '{{PLA_anything}}'
      set: [ forStatement_EXP_LEGACY_INIT_AFTER_EXP, expression ]

  forStatement_EXP_LEGACY_INIT_AFTER_EXP:
    - match: ';'
      scope: punctuation.separator.loop-expression.es # -BS
      set: forStatement_EXP_LEGACY_COND
    - match: '\)'
      scope: invalid.illegal.token.es
      set: whileOrForStatement_STMT
    - include: other_illegal

  forStatement_EXP_LEGACY_COND:
    - match: ';'
      scope: punctuation.separator.loop-expression.es # -BS
      set: forStatement_EXP_LEGACY_AFTERTHOUGHT
    - match: '\)'
      scope: invalid.illegal.token.es
      set: whileOrForStatement_STMT
    - match: '{{PLA_anything}}'
      set: [ forStatement_EXP_LEGACY_COND_AFTER_EXP, expression ]

  forStatement_EXP_LEGACY_COND_AFTER_EXP:
    - match: ';'
      scope: punctuation.separator.loop-expression.es # -BS
      set: forStatement_EXP_LEGACY_AFTERTHOUGHT
    - match: '\)'
      scope: invalid.illegal.token.es
      set: whileOrForStatement_STMT
    - include: other_illegal

  forStatement_EXP_LEGACY_AFTERTHOUGHT:
    - match: '((\)))'
      captures:
        1: punctuation.definition.expression.loop.end.es
        2: meta.brace.round.js # ^BS
      set: whileOrForStatement_STMT
    - match: '{{PLA_anything}}'
      set: [ forStatement_AFTER_FINAL_EXP, expression ]

  forStatement_IN_OR_OF_DECLARATION_AFTER_WORD:
    - match: '((\[))'
      captures:
        1: punctuation.definition.binding.array.begin.es
        2: meta.brace.square.js # ^BS
      set: [ forStatement_IN_OR_OF_AFTER_BINDING, bindingArray ]
    - match: '((\{))'
      captures:
        1: punctuation.definition.binding.object.begin.es
        2: meta.brace.curly.js # ^BS
      set: [ forStatement_IN_OR_OF_AFTER_BINDING, bindingObject ]
    - match: '{{identifier}}'
      scope: variable.other.readwrite.es
      set: forStatement_IN_OR_OF_AFTER_BINDING
    - include: other_illegal

  forStatement_IN_OR_OF_AFTER_BINDING:
    - match: 'of{{idEnd}}'
      scope: keyword.control.loop.of.es # -BS
      set: [ forStatement_AFTER_FINAL_EXP, assignmentExpression ]
    - match: 'in{{idEnd}}'
      scope: keyword.control.loop.in.es # -BS
      set: [ forStatement_AFTER_FINAL_EXP, expression ]
    - match: ','
      scope: invalid.illegal
    # Perhaps we were really in a for-;; loop that did not have its first
    # semicolon on the initial line... we can recover in some cases.
    - match: ';'
      scope: punctuation.separator.loop-expression.es # -BS
      set: forStatement_EXP_LEGACY_COND
    - include: other_illegal

  forStatement_AFTER_FINAL_EXP:
    - match: '((\)))'
      captures:
        1: punctuation.definition.expression.loop.end.es
        2: meta.brace.round.js # ^BS
      set: whileOrForStatement_STMT
    - include: other_illegal

  ifStatement_AFTER_IF:
    - match: '((\())'
      captures:
        1: punctuation.definition.expression.conditional.begin.es
        2: meta.brace.round.js # ^BS
      set: [ ifStatement_AFTER_EXP, expression ]
    - include: other_illegal_pop

  ifStatement_AFTER_EXP:
    - match: '((\)))'
      captures:
        1: punctuation.definition.expression.conditional.end.es
        2: meta.brace.round.js # ^BS
      set: ifStatement_STMT
    - include: other_illegal

  ifStatement_STMT:
    - match: '((\{))'
      captures:
        1: punctuation.definition.block.conditional.begin.es
        2: meta.brace.curly.js # ^BS
      set: ifStatement_STMT_AFTER_BRACE
    - match: '{{PLA_anything}}'
      set: [ ifStatement_AFTER_STMT, semicolon_maybe, statement ]

  ifStatement_STMT_AFTER_BRACE:
    - match: '((\}))'
      captures:
        1: punctuation.definition.block.conditional.end.es
        2: meta.brace.curly.js # ^BS
      set: ifStatement_AFTER_STMT
    - include: statements

  ifStatement_AFTER_STMT:
    - match: 'else{{idEnd}}'
      scope: keyword.control.conditional.else.es
      set: statement
    - include: else_pop

  returnStatement:
    - match: '$|(?=\})'
      pop: true
    - match: ';'
      scope: punctuation.terminator.statement.es
      pop: true
    - match: '{{PLA_anything}}'
      set: [ optional_semicolon_pop, expression ]

  switchStatement_AFTER_SWITCH:
    - match: '((\())'
      captures:
        1: punctuation.definition.expression.switch.begin.es
        2: meta.brace.round.js # ^BS
      set: [ switchStatement_AFTER_EXP, expression ]
    - include: other_illegal_pop

  switchStatement_AFTER_EXP:
    - match: '((\)))'
      captures:
        1: punctuation.definition.expression.switch.end.es
        2: meta.brace.round.js # ^BS
      set: switchStatement_BEFORE_BRACE
    - include: other_illegal

  switchStatement_BEFORE_BRACE:
    - match: '((\{))'
      captures:
        1: punctuation.definition.block.switch.begin.es
        2: meta.brace.curly.js # ^BS
      set: switchStatement_AFTER_BRACE
    - include: other_illegal_pop

  switchStatement_AFTER_BRACE:
    - match: '((\}))'
      captures:
        1: punctuation.definition.block.switch.end.es
        2: meta.brace.curly.js # ^BS
      pop: true
    - match: 'case{{idEnd}}'
      scope: keyword.control.switch.case.es
      set: [ switchStatement_CASE_AFTER_EXP, expression ]
    - match: 'default{{idEnd}}'
      scope: keyword.control.switch.case.default.es
      set: switchStatement_CASE_AFTER_EXP
    - include: other_illegal

  switchStatement_CASE_AFTER_EXP:
    - match: ':'
      scope: punctuation.separator.case-statements.es # -BS
      set: switchStatement_CASE_STMT
    - match: '((\}))'
      captures:
        1: invalid.illegal.token.es
        2: meta.brace.curly.js # ^BS
      pop: true
    - match: '{{MAT_word_or_any_one_char}}'
      scope: invalid.illegal.token.es
      set: switchStatement_AFTER_BRACE

  switchStatement_CASE_STMT:
    - match: '((\}))'
      captures:
        1: punctuation.definition.block.switch.end.es
        2: meta.brace.curly.js # ^BS
      pop: true
    - match: 'case{{idEnd}}'
      scope: keyword.control.switch.case.es
      set: [ switchStatement_CASE_AFTER_EXP, expression ]
    - match: 'default{{idEnd}}'
      scope: keyword.control.switch.case.default.es
      set: switchStatement_CASE_AFTER_EXP
    - include: statements

  throwStatement:
    - match: '$|(?=\})'
      pop: true
    - match: '{{PLA_anything}}'
      set: [ optional_semicolon_pop, expression ]

  tryStatement_AFTER_TRY:
    - match: '((\{))'
      captures:
        1: punctuation.definition.block.trycatch.begin.es
        2: meta.brace.curly.js # ^BS
      set: tryStatement_AFTER_TRY_BRACE
    - include: other_illegal_pop

  tryStatement_AFTER_TRY_BRACE:
    - match: '((\}))'
      captures:
        1: punctuation.definition.block.trycatch.end.es
        2: meta.brace.curly.js # ^BS
      set: tryStatement_AFTER_TRY_BLOCK
    - include: statements

  tryStatement_AFTER_TRY_BLOCK:
    - match: 'catch{{idEnd}}'
      scope: keyword.control.trycatch.catch.es
      set: tryStatement_AFTER_CATCH
    - match: 'finally{{idEnd}}'
      scope: keyword.control.trycatch.finally.es
      set: tryStatement_AFTER_FINALLY
    - include: other_illegal_pop

  tryStatement_AFTER_CATCH:
    - match: '((\())'
      captures:
        1: punctuation.definition.parameters.catch.begin.es
        2: meta.brace.round.js # ^BS
      set: tryStatement_CATCH_PARAM
    - match: '((\{))'
      captures:
        1: punctuation.definition.block.trycatch.begin.es
        2: meta.brace.curly.js # ^BS
      set: tryStatement_AFTER_CATCH_BRACE
    - include: other_illegal_pop

  tryStatement_CATCH_PARAM:
    - match: '{{identifier}}'
      scope: variable.parameter.catch.es # -BS
      set: tryStatement_AFTER_CATCH_PARAM
    - match: '((\[))'
      captures:
        1: punctuation.definition.binding.array.parameter.begin.es
        2: meta.brace.square.js # ^BS
      set: [ tryStatement_AFTER_CATCH_PARAM, bindingArray_PARAM ]
    - match: '((\{))'
      captures:
        1: punctuation.definition.binding.object.parameter.begin.es
        2: meta.brace.curly.js # ^BS
      set: [ tryStatement_AFTER_CATCH_PARAM, bindingObject_PARAM ]
    - match: '\)'
      scope: invalid.illegal.token.es
      set: tryStatement_AFTER_CATCH_PARAM

  tryStatement_AFTER_CATCH_PARAM:
    - match: '((\)))'
      captures:
        1: punctuation.definition.parameters.catch.end.es
        2: meta.brace.round.js # ^BS
      set: tryStatement_BEFORE_CATCH_BRACE
    - include: other_illegal

  tryStatement_BEFORE_CATCH_BRACE:
    - match: '((\{))'
      captures:
        1: punctuation.definition.block.trycatch.begin.es
        2: meta.brace.curly.js # ^BS
      set: tryStatement_AFTER_CATCH_BRACE
    - include: other_illegal_pop

  tryStatement_AFTER_CATCH_BRACE:
    - match: '((\}))'
      captures:
        1: punctuation.definition.block.trycatch.end.es
        2: meta.brace.curly.js # ^BS
      set: tryStatement_AFTER_CATCH_BLOCK
    - include: statements

  tryStatement_AFTER_CATCH_BLOCK:
    - match: 'finally{{idEnd}}'
      scope: keyword.control.trycatch.finally.es
      set: tryStatement_AFTER_FINALLY
    - include: else_pop

  tryStatement_AFTER_FINALLY:
    - match: '((\{))'
      captures:
        1: punctuation.definition.block.trycatch.begin.es
        2: meta.brace.curly.js # ^BS
      set: tryStatement_AFTER_FINALLY_BRACE
    - include: other_illegal_pop

  tryStatement_AFTER_FINALLY_BRACE:
    - match: '((\}))'
      captures:
        1: punctuation.definition.block.trycatch.end.es
        2: meta.brace.curly.js # ^BS
      pop: true
    - include: statements

  whileStatement_AFTER_WHILE:
    - match: '((\())'
      captures:
        1: punctuation.definition.expression.loop.begin.es
        2: meta.brace.round.js # ^BS
      set: [ whileStatement_AFTER_EXP, expression ]
    - include: other_illegal_pop

  whileStatement_AFTER_EXP:
    - match: '((\)))'
      captures:
        1: punctuation.definition.expression.loop.end.es
        2: meta.brace.round.js # ^BS
      set: whileOrForStatement_STMT
    - include: other_illegal

  whileOrForStatement_STMT:
    - match: '((\{))'
      captures:
        1: punctuation.definition.block.loop.begin.es
        2: meta.brace.curly.js # ^BS
      set: whileOrForStatement_STMT_AFTER_BRACE
    - match: '{{PLA_anything}}'
      set: statement

  whileOrForStatement_STMT_AFTER_BRACE:
    - match: '((\}))'
      captures:
        1: punctuation.definition.block.loop.end.es
        2: meta.brace.curly.js # ^BS
      pop: true
    - include: statements

  withStatement_AFTER_WITH:
    - match: '((\())'
      captures:
        1: punctuation.definition.expression.with.begin.es
        2: meta.brace.round.js # ^BS
      set: [ withStatement_AFTER_EXP, expression ]
    - include: other_illegal_pop

  withStatement_AFTER_EXP:
    - match: '((\)))'
      captures:
        1: punctuation.definition.expression.with.end.es
        2: meta.brace.round.js # ^BS
      set: withStatement_STMT
    - include: other_illegal

  withStatement_STMT:
    - match: '((\{))'
      captures:
        1: punctuation.definition.block.with.begin.es
        2: meta.brace.curly.js # ^BS
      set: withStatement_STMT_AFTER_BRACE
    - match: '{{PLA_anything}}'
      set: statement

  withStatement_STMT_AFTER_BRACE:
    - match: '((\}))'
      captures:
        1: punctuation.definition.block.with.end.es
        2: meta.brace.curly.js # ^BS
      pop: true
    - include: statements

# DECLARATIONS #################################################################

  classDeclaration_AFTER_CLASS:
    - match: '(({{identifier}}))'
      captures:
        1: entity.name.class.js # ^BS -- Monokai
        2: entity.name.class.es
      set: classDeclaration_AFTER_NAME
    - include: other_illegal_pop

  classDeclaration_AFTER_NAME:
    - match: '((\{))'
      captures:
        1: punctuation.definition.class.body.begin.es
        2: meta.brace.curly.js # ^BS
      set: classDeclaration_AFTER_BRACE
    - match: '((extends)){{idEnd}}'
      captures:
        1: storage.type.extends.js # ^BS
        2: storage.modifier.extends.es
      set: [ classDeclaration_AFTER_HERITAGE, assignmentExpression ] # (lhse)
    - include: other_illegal_pop

  classDeclaration_AFTER_HERITAGE:
    - meta_scope: meta.super-expression.es
    - match: '((\{))'
      captures:
        1: punctuation.definition.class.body.begin.es
        2: meta.brace.curly.js # ^BS
      set: classDeclaration_AFTER_BRACE
    - include: other_illegal_pop

  classDeclaration_AFTER_BRACE:
    - match: '((\}))'
      captures:
        1: punctuation.definition.class.body.end.es
        2: meta.brace.curly.js # ^BS
      pop: true
    # Semicolons in the class body are legal.
    - match: ';'
      scope: punctuation.terminator.statement.es
    - match: '((static)){{idEnd}}'
      captures:
        1: storage.modifier.static.es
        2: storage.type.js # ^BS
      set: classDeclaration_AFTER_STATIC
    - match: '((constructor)){{idEnd}}'
      captures:
        1: entity.name.method.js # ^BS
        2: entity.name.constructor.es
      push: constructorMethod_AFTER_CONSTRUCTOR
    - match: '((@))'
      captures:
        1: punctuation.definition.tag.js # ^BS
        2: punctuation.definition.decorator.es
      push: decoratorExpression
    - include: classDeclaration_METHOD_COMMON
    - include: other_illegal_pop

  classDeclaration_AFTER_METHOD_OR_FIELD_NAME:
    - match: ';'
      scope: punctuation.terminator.property.es
      pop: true
    - match: '='
      scope: punctuation.separator.key-value.es
      set:
        - - match: ';'
            scope: punctuation.terminator.property.es
            pop: true
          - include: else_pop
        - - include: assignmentExpression
    - match: '(?!\()'
      pop: true
    - include: method_AFTER_NAME

  classDeclaration_AFTER_STATIC:
    - include: classDeclaration_METHOD_COMMON
    - match: '{{PLA_anything}}'
      set: classDeclaration_AFTER_BRACE

  classDeclaration_METHOD_COMMON:
    - match: '((\*))'
      captures:
        1: keyword.generator.asterisk.js # ^BS
        2: storage.modifier.generator.asterisk.method.es
      set: [ classDeclaration_AFTER_BRACE, generatorMethod_AFTER_ASTERISK_CLASS ]
    - match: '((get)){{idEnd}}(?!\s*[\(=;])'
      captures:
        1: storage.type.accessor.js # ^BS
        2: storage.modifier.accessor.get.es
      set: [ classDeclaration_AFTER_BRACE, accessorMethod_AFTER_GET_CLASS ]
    - match: '((set)){{idEnd}}(?!\s*[\(=;])'
      captures:
        1: storage.type.accessor.js # ^BS
        2: storage.modifier.accessor.set.es
      set: [ classDeclaration_AFTER_BRACE, accessorMethod_AFTER_SET_CLASS ]
    - match: '((async)){{idEnd}}((\s*\*))?'
      captures:
        1: storage.type.js # ^BS
        2: storage.modifier.async.method.es
        3: keyword.generator.asterisk.js # ^BS
        4: storage.modifier.generator.asterisk.method.es
      set: [ classDeclaration_AFTER_BRACE, asyncMethod_AFTER_ASYNC ]
    - match: '(((?:(#{{identifierName}})|({{identifierName}}))))\s*(=)\s*(((async))\s+)?(?=\((?<parens>[^\(\)]|\(\g<parens>*\))*\)\s*=>)'
      captures:
        1: entity.name.function.js # ^BS
        2: meta.symbol-helper.arrow.es
        3: variable.language.private.class.es
        4: variable.other.readwrite.property.class.es
        5: punctuation.separator.key-value.es
        7: storage.type.js
        8: storage.modifier.async.expression.es
      set:
        - - include: classDeclaration_AFTER_BRACE
        - - match: ';'
            scope: punctuation.terminator.property.es
          - include: else_pop
        - - match: '{{PLA_anything}}'
            set: assignmentExpression
    - match: '(?:(#{{identifierName}})|({{identifierName}})){{idEnd}}(?!\s*\()'
      captures:
        1: variable.language.private.class.es
        2: variable.other.readwrite.property.class.es
      set:
        - - include: classDeclaration_AFTER_BRACE
        - - match: ';'
            scope: punctuation.terminator.property.es
            pop: true
          - include: else_pop
        - - match: '='
            scope: punctuation.separator.key-value.es
            set: assignmentExpression
          - match: '{{PLA_anything}}'
            pop: true
    - match: '((#{{identifierName}})){{idEnd}}'
      captures:
        1: entity.name.method.js # ^BS -- monokai
        2: entity.name.method.private.es
      set: [ classDeclaration_AFTER_BRACE, method_AFTER_NAME_PRIVATE ]
    - match: '(({{identifierName}})){{idEnd}}'
      captures:
        1: entity.name.method.js # ^BS -- monokai
        2: entity.name.method.es
      set: [ classDeclaration_AFTER_BRACE, method_AFTER_NAME ]
    - match: "'"
      scope: punctuation.definition.string.quoted.single.begin.es
      set: [ classDeclaration_AFTER_BRACE, classDeclaration_AFTER_METHOD_OR_FIELD_NAME, stringSingle_AFTER_OPEN ]
    - match: '"'
      scope: punctuation.definition.string.quoted.double.begin.es
      set: [ classDeclaration_AFTER_BRACE, classDeclaration_AFTER_METHOD_OR_FIELD_NAME, stringDouble_AFTER_OPEN ]
    # None of the remainder are handled correctly in BS or JSN, so they are all
    # technically "-BS" cases
    - match: '({{binNum}})'
      scope: constant.numeric.binary.es
      captures:
        1: entity.name.method.es
        2: meta.numeric.prefix.es
        3: meta.numeric.suffix.es
      set: [ classDeclaration_AFTER_BRACE, classDeclaration_AFTER_METHOD_OR_FIELD_NAME ]
    - match: '({{octNum}})'
      scope: constant.numeric.octal.es
      captures:
        1: entity.name.method.es
        2: meta.numeric.prefix.es
        3: meta.numeric.suffix.es
      set: [ classDeclaration_AFTER_BRACE, classDeclaration_AFTER_METHOD_OR_FIELD_NAME ]
    - match: '({{hexNum}})'
      scope: constant.numeric.hexadecimal.es
      captures:
        1: entity.name.method.es
        2: meta.numeric.prefix.es
        3: meta.numeric.suffix.es
      set: [ classDeclaration_AFTER_BRACE, classDeclaration_AFTER_METHOD_OR_FIELD_NAME ]
    - match: '({{decNum}})'
      scope: constant.numeric.decimal.es
      captures:
        1: entity.name.method.es
        2: punctuation.decimal.es
        3: punctuation.decimal.es
        4: punctuation.decimal.es
        5: meta.numeric.exponent.e.es
        6: meta.numeric.exponent.sign.es
        7: meta.numeric.exponent.digit.es
        8: meta.numeric.suffix.es
      set: [ classDeclaration_AFTER_BRACE, classDeclaration_AFTER_METHOD_OR_FIELD_NAME ]
    - match: '((\[))'
      captures:
        1: punctuation.definition.accessor.begin.es
        2: meta.brace.square.js # ^BS
      set: [ classDeclaration_AFTER_BRACE, classDeclaration_AFTER_METHOD_OR_FIELD_NAME, computedProp_AFTER_AE, assignmentExpression ]

  classDeclaration_AFTER_DECORATOR:
    - match: '((@))'
      captures:
        1: punctuation.definition.tag.js # ^BS
        2: punctuation.definition.decorator.es
      push: decoratorExpression
    - match: 'class'
      scope: storage.type.class.es
      set: classDeclaration_AFTER_CLASS
    # TEMPORARY, WILL PROBABLY BE REMOVED WHEN BABEL REINTRODUCES DECORATORS
    # In Babel 5, the class decorator implementation departed from the proposal
    # grammar and introduced its own production, <decorator> <exportStatement>,
    # where the exportStatement was a new production restricted to only those
    # which contain class declarations. I’m not sure if this was intentional or
    # accidental, but there’s no sign that this will ever be part of the actual
    # proposal (it looks nice, but syntactically, it doesn’t really make sense),
    # and I suspect Babel 6 will rectify this when it implements the new version
    # of the decorator proposal.
    - match: '(?=export\s+(default\s+)?class)'
      pop: true
    - include: other_illegal_pop

  constLetVarDeclaration_AFTER_WORD:
    # The first four of these are used to assign scopes for using in the symbol
    # list. This is important as the `const x =` function ‘declaration’ pattern
    # seems to be taking off now that there’s an actual reason for it. This same
    # set of matches allows us to apply scopes for BS / JSN themes.
    - match: '((({{allThreeIDs}})))(?=\s*=\s*function\s*\*)'
      captures:
        1: meta.function.js entity.name.function.js # ^BS
        2: meta.symbol-helper.generator.es # -BS
        3: entity.name.function.generator.es
        4: variable.other.readwrite.allCap.es # -BS
        5: variable.other.readwrite.initCap.es
        6: variable.other.readwrite.es
      set: constLetVarDeclaration_AFTER_BINDING
    - match: '((({{allThreeIDs}})))(?=\s*=\s*async\s+function{{idEnd}})'
      captures:
        1: meta.function.js entity.name.function.js # ^BS
        2: meta.symbol-helper.function.es
        3: entity.name.function.async.es
        4: variable.other.readwrite.allCap.es # -BS
        5: variable.other.readwrite.initCap.es
        6: variable.other.readwrite.es
      set: constLetVarDeclaration_AFTER_BINDING
    - match: '((({{allThreeIDs}})))(?=\s*=\s*function{{idEnd}})'
      captures:
        1: meta.function.js entity.name.function.js # ^BS
        2: meta.symbol-helper.function.es
        3: entity.name.function.es
        4: variable.other.readwrite.allCap.es # -BS
        5: variable.other.readwrite.initCap.es
        6: variable.other.readwrite.es
      set: constLetVarDeclaration_AFTER_BINDING
    - match: '(({{allThreeIDs}}))(?=\s*=\s*class\s*(?:\{|extends{idEnd}))'
      captures:
        1: meta.function.js entity.name.class.js # ^BS, augmented
        2: meta.symbol-helper.class.es
        3: variable.other.readwrite.allCap.es # -BS
        4: variable.other.readwrite.initCap.es
        5: variable.other.readwrite.es
      set: constLetVarDeclaration_AFTER_BINDING
    - match: >-
        (?x)
          ((( {{allThreeIDs}} )))
          (?=
            \s* = \s* (async\s+)?
            (?:
              \(
                (?<parens> [^\(\)] | \( \g<parens>* \) )*
              \)
              |
              {{identifierName}}
            )
            \s* =>
          )
      captures:
        1: meta.function.arrow.js entity.name.function.js # ^BS
        2: meta.symbol-helper.arrow.es
        3: entity.name.function.es
        4: variable.other.readwrite.allCap.es
        5: variable.other.readwrite.initCap.es
        6: variable.other.readwrite.es
      set: constLetVarDeclaration_AFTER_BINDING
    - match: '{{allThreeIDs}}'
      captures:
        1: variable.other.readwrite.allCap.es # -BS
        2: variable.other.readwrite.initCap.es
        3: variable.other.readwrite.es
      set: constLetVarDeclaration_AFTER_BINDING
    - match: '((\[))'
      captures:
        1: punctuation.definition.binding.array.begin.es
        2: meta.brace.square.js # ^BS
      set: [ constLetVarDeclaration_AFTER_BINDING_PATTERN, bindingArray ]
    - match: '((\{))'
      captures:
        1: punctuation.definition.binding.object.begin.es
        2: meta.brace.curly.js # ^BS
      set: [ constLetVarDeclaration_AFTER_BINDING_PATTERN, bindingObject ]
    # We forgive syntax errors here to prevent mid-typing scope error cascades
    - include: else_pop

  constLetVarDeclaration_AFTER_BINDING:
    - match: '((,))'
      captures:
        1: punctuation.separator.binding-binding.es
        2: meta.delimiter.comma.js
      set: constLetVarDeclaration_AFTER_WORD
    - match: '='
      scope: keyword.operator.assignment.es
      push: assignmentExpression
    - include: else_pop

  constLetVarDeclaration_AFTER_BINDING_PATTERN:
    - match: '='
      scope: keyword.operator.assignment.es
      set: [ constLetVarDeclaration_AFTER_BINDING, assignmentExpression ]
    - include: other_illegal_pop

  functionDeclaration_AFTER_FUNCTION:
    - match: '{{allThreeIDs}}'
      captures:
        1: entity.name.function.allCap.es
        2: entity.name.function.initCap.es
        3: entity.name.function.es
      set: functionDeclaration_AFTER_NAME
    - include: other_illegal_pop

  functionDeclaration_AFTER_NAME:
    - match: '((\())'
      captures:
        1: punctuation.definition.parameters.function.begin.es
        2: meta.brace.round.js # ^BS
      set: [ functionDeclaration_AFTER_PARAMS, parameters ]
    - include: other_illegal_pop

  functionDeclaration_AFTER_PARAMS:
    - match: '((\)))'
      captures:
        1: punctuation.definition.parameters.function.end.es
        2: meta.brace.round.js # ^BS
      set: functionDeclaration_BEFORE_BRACE
    - include: other_illegal

  functionDeclaration_BEFORE_BRACE:
    - match: '((\{))'
      captures:
        1: punctuation.definition.function.body.begin.es
        2: meta.brace.curly.js # ^BS
      set: functionDeclaration_AFTER_BRACE
    - include: other_illegal_pop

  functionDeclaration_AFTER_BRACE:
    - match: '((\}))'
      captures:
        1: punctuation.definition.function.body.end.es
        2: meta.brace.curly.js # ^BS
      pop: true
    - include: useStrict
    - include: statements

  asyncDeclaration_AFTER_FUNCTION:
    - match: '((\*))'
      captures:
        1: keyword.generator.asterisk.js # ^BS
        2: storage.modifier.generator.asterisk.method.es
      set:
        - match: '{{allThreeIDs}}'
          scope: entity.name.function.async.es
          set: asyncDeclaration_AFTER_NAME
        - include: other_illegal_pop
    - match: '{{allThreeIDs}}'
      scope: entity.name.function.async.es
      set: asyncDeclaration_AFTER_NAME
    - include: other_illegal_pop

  asyncDeclaration_AFTER_NAME:
    - match: '((\())'
      captures:
        1: punctuation.definition.parameters.function.async.begin.es
        2: meta.brace.round.js # ^BS
      set: [ asyncDeclaration_AFTER_PARAMS, parameters ]
    - include: other_illegal_pop

  asyncDeclaration_AFTER_PARAMS:
    - match: '((\)))'
      captures:
        1: punctuation.definition.parameters.function.async.end.es
        2: meta.brace.round.js # ^BS
      set: asyncDeclaration_BEFORE_BRACE
    - include: other_illegal

  asyncDeclaration_BEFORE_BRACE:
    - match: '((\{))'
      captures:
        1: punctuation.definition.function.async.body.begin.es
        2: meta.brace.curly.js # ^BS
      set: asyncDeclaration_AFTER_BRACE
    - include: other_illegal_pop

  asyncDeclaration_AFTER_BRACE:
    - match: '((\}))'
      captures:
        1: punctuation.definition.function.async.body.end.es
        2: meta.brace.curly.js # ^BS
      pop: true
    - include: useStrict
    - include: statements

  generatorDeclaration_AFTER_ASTERISK:
    - match: '{{identifier}}'
      scope: entity.name.function.generator.es
      set: generatorDeclaration_AFTER_NAME
    - include: other_illegal_pop

  generatorDeclaration_AFTER_NAME:
    - match: '((\())'
      captures:
        1: punctuation.definition.parameters.generator.begin.es
        2: meta.brace.round.js # ^BS
      set: [ generatorDeclaration_AFTER_PARAMS, parameters ]
    - include: other_illegal_pop

  generatorDeclaration_AFTER_PARAMS:
    - match: '((\)))'
      captures:
        1: punctuation.definition.parameters.generator.end.es
        2: meta.brace.round.js # ^BS
      set: generatorDeclaration_BEFORE_BRACE
    - include: other_illegal

  generatorDeclaration_BEFORE_BRACE:
    - match: '((\{))'
      captures:
        1: punctuation.definition.generator.body.begin.es
        2: meta.brace.curly.js # ^BS
      set: generatorDeclaration_AFTER_BRACE
    - include: other_illegal_pop

  generatorDeclaration_AFTER_BRACE:
    - match: '((\}))'
      captures:
        1: punctuation.definition.generator.body.end.es
        2: meta.brace.curly.js # ^BS
      pop: true
    - include: useStrict
    - include: statements

  moduleDeclaration_AFTER_EXPORT:
    - match: '((\*))'
      captures:
        1: keyword.operator.module.js # ^BS, augmented
        2: storage.modifier.module.namespace.es
      set: moduleDeclaration_BEFORE_FROM
    - match: '((\{))'
      captures:
        1: punctuation.definition.module-binding.begin.es
        2: meta.brace.curly.js # ^BS
      set: moduleDeclaration_EXPORT_BINDING_AFTER_BRACE
    - match: '((@))'
      captures:
        1: punctuation.definition.tag.js # ^BS
        2: punctuation.definition.decorator.es
      push: decoratorExpression
    - match: '((default)){{idEnd}}'
      captures:
        1: keyword.operator.module.js # ^BS
        2: storage.modifier.module.default.es
      set: moduleDeclaration_AFTER_DEFAULT
    - match: 'let{{idEnd}}'
      scope: storage.type.variable.let.es
      set: constLetVarDeclaration_AFTER_WORD
    - match: 'var{{idEnd}}'
      scope: storage.type.variable.var.es
      set: constLetVarDeclaration_AFTER_WORD
    - match: 'class{{idEnd}}'
      scope: storage.type.class.es
      set: classDeclaration_AFTER_CLASS
    - match: 'const{{idEnd}}'
      scope: storage.type.constant.es
      set: constLetVarDeclaration_AFTER_WORD
    - match: '((function))\s*((\*))'
      captures:
        1: storage.type.function.js # ^BS -- Cobalt
        2: storage.type.function.generator.es
        3: keyword.generator.asterisk.js # ^BS
        4: storage.modifier.generator.asterisk.es
      set: generatorDeclaration_AFTER_ASTERISK
    - match: '((function)){{idEnd}}'
      captures:
        1: storage.type.function.js # ^BS -- Cobalt
        2: storage.type.function.es
      set: functionDeclaration_AFTER_FUNCTION
    - match: '((async))\s*((function)){{idEnd}}'
      captures:
        1: storage.type.js # ^BS
        2: storage.modifier.async.es
        3: storage.type.function.js # ^BS -- Cobalt
        4: storage.type.function.async.es
      set: asyncDeclaration_AFTER_FUNCTION
    # ES proposal: re-export default without 'default' (supported by Babel)
    # Technically if this proposal gets in, I’m guessing it would also permit
    # constructions like...
    #
    # export Foo, { bar } from 'baz'
    #
    # ...but I’m not gonna bother with that quite yet.
    - match: '{{identifier}}'
      scope: variable.other.readwrite.export.es
      set: moduleDeclaration_BEFORE_FROM
    - include: other_illegal_pop

  moduleDeclaration_AFTER_DEFAULT:
    - match: 'class{{idEnd}}'
      scope: storage.type.class.es
      set: moduleDeclaration_DEFAULT_AFTER_CLASS
    - match: '((function))\s*((\*))'
      captures:
        1: storage.type.function.js # ^BS -- Cobalt
        2: storage.type.function.generator.es
        3: keyword.generator.asterisk.js # ^BS
        4: storage.modifier.generator.asterisk.es
      set: moduleDeclaration_DEFAULT_AFTER_ASTERISK
    - match: '((function)){{idEnd}}'
      captures:
        1: storage.type.function.js # ^BS -- Cobalt
        2: storage.type.function.es
      set: moduleDeclaration_DEFAULT_AFTER_FUNCTION
    - match: '((async))\s*((function)){{idEnd}}((\s*\*))?'
      captures:
        1: storage.type.js # ^BS
        2: storage.modifier.async.es
        3: storage.type.function.js # ^BS -- Cobalt
        4: storage.type.function.async.es
        5: keyword.generator.asterisk.js # ^BS
        6: storage.modifier.generator.asterisk.method.es
      set: moduleDeclaration_DEFAULT_AFTER_ASYNC_FUNCTION
    - match: '((@))'
      captures:
        1: punctuation.definition.tag.js # ^BS
        2: punctuation.definition.decorator.es
      set: [ moduleDeclaration_DEFAULT_AFTER_DECORATOR, decoratorExpression ]
    - match: '{{PLA_anything}}'
      set: assignmentExpression

  moduleDeclaration_DEFAULT_AFTER_DECORATOR:
    - match: 'class{{idEnd}}'
      scope: storage.type.class.es
      set: moduleDeclaration_DEFAULT_AFTER_CLASS
    - match: '((@))'
      captures:
        1: punctuation.definition.tag.js # ^BS
        2: punctuation.definition.decorator.es
      push: [ decoratorExpression ]
    - include: other_illegal_pop

  moduleDeclaration_DEFAULT_AFTER_CLASS:
    - match: '((\{))'
      captures:
        1: punctuation.definition.class.body.begin.es
        2: meta.brace.curly.js # ^BS
      set: classDeclaration_AFTER_BRACE
    - match: '((extends)){{idEnd}}'
      captures:
        1: storage.type.extends.js # ^BS
        2: storage.modifier.extends.es
      set: [ classDeclaration_AFTER_HERITAGE, assignmentExpression ]
    - match: '(({{identifier}}))'
      captures:
        1: entity.name.class.js # ^BS -- monokai
        2: entity.name.class.es
      set: classDeclaration_AFTER_NAME
    - include: other_illegal_pop

  moduleDeclaration_DEFAULT_AFTER_ASTERISK:
    - match: '((\())'
      captures:
        1: punctuation.definition.parameters.generator.begin.es
        2: meta.brace.round.js # ^BS
      set: [ generatorDeclaration_AFTER_PARAMS, parameters ]
    - match: '{{identifier}}'
      scope: entity.name.function.generator.es
      set: generatorDeclaration_AFTER_NAME
    - include: other_illegal_pop

  moduleDeclaration_DEFAULT_AFTER_FUNCTION:
    - match: '((\())'
      captures:
        1: punctuation.definition.parameters.function.begin.es
        2: meta.brace.round.js # ^BS
      set: [ functionDeclaration_AFTER_PARAMS, parameters ]
    - match: '{{allThreeIDs}}'
      captures:
        1: entity.name.function.allCap.es
        2: entity.name.function.initCap.es
        3: entity.name.function.es
      set: functionDeclaration_AFTER_NAME
    - include: other_illegal_pop

  moduleDeclaration_DEFAULT_AFTER_ASYNC_FUNCTION:
    - match: '((\())'
      captures:
        1: punctuation.definition.parameters.function.async.begin.es
        2: meta.brace.round.js # ^BS
      set: [ asyncDeclaration_AFTER_PARAMS, parameters ]
    - match: '{{allThreeIDs}}'
      scope: entity.name.function.async.es
      set: asyncDeclaration_AFTER_NAME
    - include: other_illegal_pop

  moduleDeclaration_BEFORE_FROM:
    - match: '((from)){{idEnd}}'
      captures:
        1: keyword.operator.module.js # ^BS
        2: storage.modifier.module.from.es
      set: moduleDeclaration_BEFORE_SPECIFIER
    - include: other_illegal_pop

  moduleDeclaration_BEFORE_SPECIFIER:
    - match: "'"
      scope: punctuation.definition.string.quoted.single.begin.es
      set: stringSingle_AFTER_OPEN
    - match: '"'
      scope: punctuation.definition.string.quoted.double.begin.es
      set: stringDouble_AFTER_OPEN
    - include: other_illegal_pop

  moduleDeclaration_EXPORT_BINDING_AFTER_BRACE:
    - match: '((\}))'
      captures:
        1: punctuation.definition.module-binding.end.es
        2: meta.brace.curly.js # ^BS
      set: moduleDeclaration_EXPORT_AFTER_BINDING
    - match: '({{identifier}})\s+((as)){{idEnd}}'
      captures:
        1: variable.other.readwrite.export.es
        2: keyword.operator.module.js # ^BS
        3: storage.modifier.module.as.es
      set: moduleDeclaration_EXPORT_BINDING_AFTER_AS
    - match: '(default)\s+((as)){{idEnd}}'
      captures:
        1: storage.modifier.module.default.es
        2: keyword.operator.module.js # ^BS
        3: storage.modifier.module.as.es
      set: moduleDeclaration_EXPORT_BINDING_AFTER_AS
    - match: '{{identifier}}'
      scope: variable.other.readwrite.export.es
      set: moduleDeclaration_AFTER_EXPORT_BINDING_SPECIFIER_AMBIG
    - include: other_illegal

  moduleDeclaration_EXPORT_BINDING_AFTER_AS:
    - match: '{{identifierName}}'
      scope: entity.name.module.export.es
      set: moduleDeclaration_AFTER_EXPORT_BINDING_SPECIFIER
    - include: other_illegal_pop

  moduleDeclaration_AFTER_EXPORT_BINDING_SPECIFIER:
    - match: '((\}))'
      captures:
        1: punctuation.definition.module-binding.end.es
        2: meta.brace.curly.js # ^BS
      set: moduleDeclaration_EXPORT_AFTER_BINDING
    - match: '((,))'
      captures:
        1: punctuation.separator.module-binding.es
        2: meta.delimiter.comma.js # ^BS
      set: moduleDeclaration_EXPORT_BINDING_AFTER_BRACE
    - include: other_illegal

  moduleDeclaration_AFTER_EXPORT_BINDING_SPECIFIER_AMBIG:
    - match: '((as)){{idEnd}}'
      captures:
        1: keyword.operator.module.js # ^BS
        2: storage.modifier.module.as.es
      set: moduleDeclaration_EXPORT_BINDING_AFTER_AS
    - include: moduleDeclaration_AFTER_EXPORT_BINDING_SPECIFIER

  moduleDeclaration_EXPORT_AFTER_BINDING:
    - match: ';'
      scope: punctuation.terminator.statement.es
      pop: true
    - match: '((from)){{idEnd}}'
      captures:
        1: keyword.operator.module.js # ^BS
        2: storage.modifier.module.from.es
      set: moduleDeclaration_BEFORE_SPECIFIER
    - include: else_pop

  moduleDeclaration_AFTER_IMPORT:
    - match: '((\*))'
      captures:
        1: keyword.operator.module.js # ^BS, augmented
        2: storage.modifier.module.namespace.es
      set: moduleDeclaration_IMPORT_BINDING_AFTER_ASTERISK
    - match: '((\{))'
      captures:
        1: punctuation.definition.module-binding.begin.es
        2: meta.brace.curly.js # ^BS
      set: moduleDeclaration_IMPORT_BINDING_AFTER_BRACE
    - match: '{{identifier}}'
      scope: variable.other.readwrite.import.es
      set: moduleDeclaration_IMPORT_AFTER_IDENTIFIER
    - include: moduleDeclaration_BEFORE_SPECIFIER

  moduleDeclaration_IMPORT_AFTER_IDENTIFIER:
    - match: '((,))'
      captures:
        1: punctuation.separator.module-binding.es
        2: meta.delimiter.comma.js # ^BS
      set: moduleDeclaration_IMPORT_AFTER_IDENTIFIER_COMMA
    - match: '((from)){{idEnd}}'
      captures:
        1: keyword.operator.module.js # ^BS
        2: storage.modifier.module.from.es
      set: moduleDeclaration_BEFORE_SPECIFIER

  moduleDeclaration_IMPORT_AFTER_IDENTIFIER_COMMA:
    - match: '((\*))'
      captures:
        1: keyword.operator.module.js # ^BS, augmented
        2: storage.modifier.module.namespace.es
      set: moduleDeclaration_IMPORT_BINDING_AFTER_ASTERISK
    - match: '((\{))'
      captures:
        1: punctuation.definition.module-binding.begin.es
        2: meta.brace.curly.js # ^BS
      set: moduleDeclaration_IMPORT_BINDING_AFTER_BRACE
    - include: other_illegal_pop

  moduleDeclaration_IMPORT_BINDING_AFTER_ASTERISK:
    - match: '((as)){{idEnd}}'
      captures:
        1: keyword.operator.module.js # ^BS
        2: storage.modifier.module.as.es
      set: moduleDeclaration_IMPORT_BINDING_AFTER_AS
    - include: other_illegal_pop

  moduleDeclaration_IMPORT_BINDING_AFTER_AS:
    - match: '{{identifier}}'
      scope: variable.other.readwrite.import.es
      set: moduleDeclaration_BEFORE_FROM
    - include: other_illegal_pop

  moduleDeclaration_IMPORT_BINDING_AFTER_BRACE:
    - match: '((\}))'
      captures:
        1: punctuation.definition.module-binding.end.es
        2: meta.brace.curly.js # ^BS
      set: moduleDeclaration_BEFORE_FROM
    - match: '({{identifierName}})\s+((as)){{idEnd}}'
      captures:
        1: entity.name.module.import.es
        2: keyword.operator.module.js # ^BS
        3: storage.modifier.module.as.es
      set: moduleDeclaration_IMPORT_BINDING_AFTER_AS_BEFORE_BRACE_CLOSE
    - match: '{{identifier}}'
      scope: variable.other.readwrite.import.es
      set: moduleDeclaration_AFTER_IMPORT_BINDING_SPECIFIER_AMBIG
    - include: other_illegal

  moduleDeclaration_IMPORT_BINDING_AFTER_AS_BEFORE_BRACE_CLOSE:
    - match: '{{identifier}}'
      scope: variable.other.readwrite.import.es
      set: moduleDeclaration_AFTER_IMPORT_BINDING_SPECIFIER
    - include: other_illegal_pop

  moduleDeclaration_AFTER_IMPORT_BINDING_SPECIFIER:
    - match: '((\}))'
      captures:
        1: punctuation.definition.module-binding.end.es
        2: meta.brace.curly.js # ^BS
      set: moduleDeclaration_BEFORE_FROM
    - match: '((,))'
      captures:
        1: punctuation.separator.module-binding.es
        2: meta.delimiter.comma.js # ^BS
      set: moduleDeclaration_IMPORT_BINDING_AFTER_BRACE
    - include: other_illegal

  moduleDeclaration_AFTER_IMPORT_BINDING_SPECIFIER_AMBIG:
    - match: '((as)){{idEnd}}'
      captures:
        1: keyword.operator.module.js # ^BS
        2: storage.modifier.module.as.es
      set: moduleDeclaration_IMPORT_BINDING_AFTER_AS_BEFORE_BRACE_CLOSE
    - include: moduleDeclaration_AFTER_IMPORT_BINDING_SPECIFIER

# EXPRESSION ###################################################################

  # An expression is either a single assignment expression, or multiple AEs
  # separated by commas. Unlike commas appearing in parameters, imports, arrays,
  # and objects, this comma is an operator (...technically). Sad little thing.

  expression:
    - match: '{{PLA_anything}}'
      set: [ expression_AFTER_AE, assignmentExpression ]

  expression_AFTER_AE:
    - match: ','
      scope: keyword.operator.comma.es
      push: assignmentExpression
    - include: else_pop

  decoratorExpression:
    # The proposed decorator grammar is now constrained to narrower productions,
    # resolving the ambiguity issues that existed in earlier versions of the
    # specification. They achieved this without nerfing it by requiring parens
    # for arbitrary expressions and only allowing a narrowed version of
    # call/member expression ‘bare’.
    #
    # In practice, most decorators will not involve parenthesized expressions,
    # and although they are otherwise really just call/member expressions, it is
    # useful and expected to be able to highlight them as something distinct,
    # especially since they are often meant to be processed away by a compiler,
    # not consumed at runtime (even after they land, this will remain true).

    - match: '{{PLA_anything}}'
      set: [ decoratorExpression_EXIT, decoratorExpression_START ]

  decoratorExpression_ARGS_EXIT:
    - meta_scope: meta.decorator.arguments.es
    - match: '{{PLA_anything}}'
      pop: true

  decoratorExpression_AFTER_ACCESS:
    - match: '(({{identifier}}))'
      captures:
        1: entity.name.tag.js # ^BS
        2: variable.other.readwrite.decorator.es
      set: decoratorExpression_RHS
    - match: '{{MAT_word_or_any_one_char}}'
      scope: invalid.illegal.token.es

  decoratorExpression_EXIT:
    - meta_scope: meta.decorator.es
    - match: '{{PLA_anything}}'
      pop: true

  decoratorExpression_RHS:
    - match: '\.'
      scope: keyword.operator.accessor.decorator.es
      set: decoratorExpression_AFTER_ACCESS
    - match: '((\())'
      captures:
        1: punctuation.definition.arguments.begin.es
        2: meta.brace.round.js # ^BS
      set: [ decoratorExpression_ARGS_EXIT, arguments ]
    - match: '{{PLA_anything}}'
      pop: true

  decoratorExpression_START:
    - match: '((\())'
      captures:
        1: punctuation.definition.decorator.begin.es
        2: meta.brace.round.js # ^BS
      set: [ decoratorExpression_PAREN_EXIT, expression ]
    - include: decoratorExpression_AFTER_ACCESS

  decoratorExpression_PAREN_EXIT:
    - meta_scope: meta.decorator.parenthesized.es
    - match: '((\)))'
      captures:
        1: punctuation.definition.decorator.end.es
        2: meta.brace.round.js # ^BS
      set: decoratorExpression_RHS
    - match: '{{MAT_word_or_any_one_char}}'
      scope: invalid.illegal.token.es

  # AE is what we generally think of when we say ‘expression’. Since we always
  # must arrive at expressions from the ‘statement level’, it’s worth noting
  # that there are only three types of expressions demanded there:
  #
  # - expression
  # - assignment expression
  # - left hand side expression
  #
  # For our purposes, though, the last one must be ignored; there’s just no
  # practical way -- nor any real benefit re: highlighting -- to ensuring that a
  # given expression is in fact an LHSE. And this is just one of many ways that
  # assigning scopes within expressions is far more permissive than the rigid
  # approach used for statements (which generally have nice clear structures and
  # keywords and delimiting punctuation that we want to scope).
  #
  # This context is a greedy consumer. That is, while it requires that there be
  # at least one valid assignment expression, it continues trying to match
  # expression components for as long as possible before popping, since one AE
  # is often be a composition of what could be multiple AEs.
  #
  # Many of the contexts here are only groupings used in includes for clarity
  # and convenience rather than states that one would transition to. However the
  # match sequence is important.
  #
  # Finally note that there are two versions: one which allows the in operator
  # and one which does not. The latter is required for distinguishing the
  # operator from the control keyword in for loops. Though it leads to an
  # especially perverse amount of duplication, I consider this too important to
  # not do.

  assignmentExpression:
    - include: assignmentExpression_CORE
    - include: other_illegal_pop

  assignmentExpression_CORE:
    - include: syntax_OPEN
    - include: ae_LITERAL_VALUES
    - include: ae_NUMBERS
    - include: ae_STRING_REGEX
    - include: ae_OBJECT_ARRAY_BINDING
    - include: ae_OBJECT_ARRAY_LITERAL
    - include: ae_YIELD_NEW
    - include: ae_FUNCTION_GENERATOR_CLASS
    - include: ae_PREFIX_OPS
    - include: ae_ARROW
    - include: ae_IDENTIFIERS
    - include: ae_PARENTHESIZED
    - include: ae_DO
    - include: ae_JSX

  ae_AFTER_IDENTIFIER:
    - match: '=>'
      scope: storage.type.function.arrow.es
      set: ae_ARROW_AFTER_ARROW
    - include: ae_AFTER_THING

  # The ‘thing’ in question is a ‘value’ that is conceivably invocable.
  ae_AFTER_THING:
    - match: '((\())'
      captures:
        1: punctuation.definition.arguments.begin.es
        2: meta.brace.round.js # ^BS
      push: arguments
    - match: '`'
      scope: punctuation.definition.string.interpolated.begin.es # -BS
      set: [ ae_AFTER_VALUE, templateString_AFTER_OPEN ]
    - include: syntax_OPEN
    - include: ae_POSTFIX_OPS
    - include: ae_INFIX_OPS_ASSIGNMENT
    - include: ae_AFTER_VALUE

  # The ‘value’ in question is anything which might be followed by property
  # access or infix operators other than assignment operators -- or it could
  # just be the end of the assignment expression.
  ae_AFTER_VALUE:
    # Refinement for error cases that are artifacts of active typing
    - match: '\.(?=\s*[\}\)\]])'
      scope: invalid.illegal.token
      pop: true
    # Accessor operators
    - match: '\.(?!\d|\.\.)'
      scope: keyword.operator.accessor.es
      set: ae_AFTER_ACCESSOR_OPERATOR
    - match: '\?\.(?!\d)'
      scope: keyword.operator.accessor.optional-chaining.es
      set: ae_AFTER_ACCESSOR_OPERATOR
    # TODO: This concerned earlier grammars for the decorator proposal but it is
    # should not be needed any longer as the grammar no longer permits the parts
    # that were ambiguous. There are probably a few spots that should be updated
    # due to that.
    - match: >-
        (?x) (?=
          \[
            [^\[\]]+
          \]
          \s* \( [^\)]* \) \s* \{
        )
      pop: true
    # Accessor brackets
    - match: '((\[))'
      captures:
        1: punctuation.definition.accessor.begin.es
        2: meta.brace.square.js # ^BS
      set: [ ae_AFTER_THING, computedProp_AFTER_AE, assignmentExpression ]
    - include: ae_AFTER_POSTFIX

  ae_AFTER_POSTFIX:
    - include: ae_INFIX_OPS
    - include: else_pop

  ae_AFTER_ACCESSOR_OPERATOR:
    - match: '((({{identifierAllCaps}})))\s*((\())'
      captures:
        1: variable.other.readwrite.property.allCap.es
        2: meta.function-call # ^BS
        3: meta.invocation.es
        4: punctuation.definition.arguments.begin.es
        5: meta.brace.round.js # ^BS
      set: [ ae_AFTER_THING, arguments ]
    - match: '((({{identifierInitCap}})))\s*((\())'
      captures:
        1: variable.other.readwrite.property.initCap.es
        2: meta.function-call # ^BS
        3: meta.invocation.es
        4: punctuation.definition.arguments.begin.es
        5: meta.brace.round.js # ^BS
      set: [ ae_AFTER_THING, arguments ]
    - match: '((({{identifierName}})))\s*((\())'
      captures:
        1: variable.other.readwrite.property.es
        2: meta.function-call # ^BS
        3: meta.invocation.es
        4: punctuation.definition.arguments.begin.es
        5: meta.brace.round.js # ^BS
      set: [ ae_AFTER_THING, arguments ]
    - match: '(((#{{identifierName}})))\s*((\())'
      captures:
        1: variable.language.private.es
        2: meta.function-call # ^BS
        3: meta.invocation.es
        4: punctuation.definition.arguments.begin.es
        5: meta.brace.round.js # ^BS
      set: [ ae_AFTER_THING, arguments ]
    - match: '(prototype){{idEnd}}'
      scope: variable.other.readwrite.property.prototype.es
      captures:
        1: variable.language.prototype.es # for compatibility
      set: ae_AFTER_THING
    - match: '(__proto__){{idEnd}}'
      scope: variable.other.readwrite.property.proto.es
      captures:
        1: variable.language.proto.es # for compatibility
      set: ae_AFTER_THING
    - match: '(({{identifierName}}))(?=\s*=\s*async\s+function\b)'
      captures:
        1: variable.other.readwrite.property.es
        2: entity.name.method.async.es
      set: ae_AFTER_THING
    - match: '((#{{identifierName}}))(?=\s*=\s*async\s+function\b)'
      captures:
        1: variable.language.private.es
        2: entity.name.method.async.es
      set: ae_AFTER_THING
    - match: '(({{identifierName}}))(?=\s*=\s*function\s*\*)'
      captures:
        1: variable.other.readwrite.property.es
        2: entity.name.method.generator.es
      set: ae_AFTER_THING
    - match: '((#{{identifierName}}))(?=\s*=\s*function\s*\*)'
      captures:
        1: variable.language.private.es
        2: entity.name.method.generator.es
      set: ae_AFTER_THING
    - match: '(({{identifierName}}))(?=\s*=\s*function\b)'
      captures:
        1: variable.other.readwrite.property.es
        2: entity.name.method.es
      set: ae_AFTER_THING
    - match: '((#{{identifierName}}))(?=\s*=\s*function\b)'
      captures:
        1: variable.language.private.es
        2: entity.name.method.es
      set: ae_AFTER_THING
    - match: '(({{identifierName}}))\s*(=)\s*(\()(?=(?<parens>[^\(\)]|\(\g<parens>*\))*\)\s*=>)'
      captures:
        1: variable.other.readwrite.property.es
        2: entity.name.method.es
        3: keyword.operator.assignment.es
        4: punctuation.definition.parameters.function.arrow.begin.es
      set: [ ae_ARROW_AFTER_PARAMS, parameters ]
    - match: '((#{{identifierName}}))\s*(=)\s*(\()(?=(?<parens>[^\(\)]|\(\g<parens>*\))*\)\s*=>)'
      captures:
        1: variable.language.private.es
        2: entity.name.method.es
        3: keyword.operator.assignment.es
        4: punctuation.definition.parameters.function.arrow.begin.es
      set: [ ae_ARROW_AFTER_PARAMS, parameters ]
    - match: '(({{identifierName}}))\s*(=)\s*({{identifier}})\s*(=>)'
      captures:
        1: variable.other.readwrite.property.es
        2: entity.name.method.es
        3: keyword.operator.assignment.es
        4: variable.parameter.es
        5: storage.type.function.arrow.es
      set: ae_ARROW_AFTER_ARROW
    - match: '((#{{identifierName}}))\s*(=)\s*({{identifier}})\s*(=>)'
      captures:
        1: variable.language.private.es
        2: entity.name.method.es
        3: keyword.operator.assignment.es
        4: variable.parameter.es
        5: storage.type.function.arrow.es
      set: ae_ARROW_AFTER_ARROW
    - match: '(({{identifierName}}))\s*(=)\s*((async))\s+({{identifier}})\s*(=>)'
      captures:
        1: variable.other.readwrite.property.es
        2: entity.name.method.async.es
        3: keyword.operator.assignment.es
        4: storage.type.js
        5: storage.modifier.async.expression.es
        6: variable.parameter.es
        7: storage.type.function.arrow.es
      set: ae_ASYNC_ARROW_AFTER_ARROW
    - match: '((#{{identifierName}}))\s*(=)\s*((async))\s+({{identifier}})\s*(=>)'
      captures:
        1: variable.language.private.es
        2: entity.name.method.async.es
        3: keyword.operator.assignment.es
        4: storage.type.js
        5: storage.modifier.async.expression.es
        6: variable.parameter.es
        7: storage.type.function.arrow.es
      set: ae_ASYNC_ARROW_AFTER_ARROW
    - match: '(({{identifierName}}))\s*(=)\s*((async))\s*(\()'
      captures:
        1: variable.other.readwrite.property.es
        2: entity.name.method.async.es
        3: keyword.operator.assignment.es
        4: storage.type.js # ^BS
        5: storage.modifier.async.expression.es
        6: punctuation.definition.parameters.function.arrow.begin.es
      set: [ ae_ASYNC_ARROW_AFTER_PARAMS, parameters ]
    - match: '((#{{identifierName}}))\s*(=)\s*((async))\s*(\()'
      captures:
        1: variable.language.private.es
        2: entity.name.method.async.es
        3: keyword.operator.assignment.es
        4: storage.type.js # ^BS
        5: storage.modifier.async.expression.es
        6: punctuation.definition.parameters.function.arrow.begin.es
      set: [ ae_ASYNC_ARROW_AFTER_PARAMS, parameters ]
    - match: '{{identifierName}}'
      scope: variable.other.readwrite.property.es
      set: ae_AFTER_THING
    - match: '#{{identifierName}}'
      scope: variable.language.private.es
      set: ae_AFTER_THING
    # Refinement for error cases that are artifacts of active typing
    - match: '(?=[\}\)\]])'
      pop: true
    - include: other_illegal_pop

  ae_ARROW:
    # This will work so long as the => is on the same line as the arguments. An
    # arrow function with a single argument will instead be matched in
    # ae_AFTER_VALUE.
    - match: '(?x) \( (?= (?<parens> [^\(\)] | \( \g<parens>* \) )* \)\s*=> )'
      scope: punctuation.definition.parameters.function.arrow.begin.es
      set: [ ae_ARROW_AFTER_PARAMS, parameters ]
    - match: '((async))\s*(\()'
      captures:
        1: storage.type.js # ^BS
        2: storage.modifier.async.expression.es
        3: punctuation.definition.parameters.function.async.arrow.begin.es
      set: [ ae_ASYNC_ARROW_AFTER_PARAMS, parameters ]

  ae_ARROW_AFTER_PARAMS:
    - match: '\)'
      scope: punctuation.definition.parameters.function.arrow.end.es
      set: ae_ARROW_BEFORE_ARROW
    # The following might be unreachable in theory, but just to be safe:
    - include: other_illegal_pop

  ae_ARROW_BEFORE_ARROW:
    - match: '=>'
      scope: storage.type.function.arrow.es
      set: ae_ARROW_AFTER_ARROW
    # (Likewise)
    - include: other_illegal_pop

  ae_ARROW_AFTER_ARROW:
    - match: '((\{))'
      captures:
        1: punctuation.definition.function.arrow.body.begin.es
        2: meta.brace.curly.js # ^BS
      set: ae_ARROW_AFTER_BRACE
    - match: '{{PLA_anything}}'
      set: assignmentExpression

  ae_ARROW_AFTER_BRACE:
    - match: '((\}))'
      captures:
        1: punctuation.definition.function.arrow.body.end.es
        2: meta.brace.curly.js # ^BS
      set: ae_AFTER_THING
    - include: useStrict
    - include: statements
    - include: other_illegal

  ae_ASYNC_ARROW_AFTER_PARAMS:
    - match: '\)'
      scope: punctuation.definition.parameters.function.async.arrow.end.es
      set: ae_ASYNC_ARROW_BEFORE_ARROW
    # The following might be unreachable in theory, but just to be safe:
    - include: other_illegal_pop

  ae_ASYNC_ARROW_BEFORE_ARROW:
    - match: '=>'
      scope: storage.type.function.async.arrow.es
      set: ae_ASYNC_ARROW_AFTER_ARROW
    # (Likewise)
    - include: other_illegal_pop

  ae_ASYNC_ARROW_AFTER_ARROW:
    - match: '((\{))'
      captures:
        1: punctuation.definition.function.async.arrow.body.begin.es
        2: meta.brace.curly.js # ^BS
      set: ae_ASYNC_ARROW_AFTER_BRACE
    - match: '{{PLA_anything}}'
      set: assignmentExpression

  ae_ASYNC_ARROW_AFTER_BRACE:
    - match: '((\}))'
      captures:
        1: punctuation.definition.function.async.arrow.body.end.es
        2: meta.brace.curly.js # ^BS
      set: ae_AFTER_THING
    - include: useStrict
    - include: statements
    - include: other_illegal

  ae_CLASS_AFTER_CLASS:
    - match: '((\{))'
      captures:
        1: punctuation.definition.class.body.begin.es
        2: meta.brace.curly.js # ^BS
      set: [ ae_AFTER_THING, classDeclaration_AFTER_BRACE ]
    - match: '((extends)){{idEnd}}'
      captures:
        1: storage.type.extends.js # ^BS
        2: storage.modifier.extends.es
      set: [ ae_AFTER_THING, classDeclaration_AFTER_HERITAGE, assignmentExpression ]
    - match: '(({{identifier}}))'
      captures:
        1: entity.name.class.js # ^BS -- monokai
        2: entity.name.class.es
      set: [ ae_AFTER_THING, classDeclaration_AFTER_NAME ]
    - include: other_illegal_pop

  ae_DO:
    - match: 'do{{idEnd}}'
      scope: keyword.control.do-expression.do.es
      set: [ ae_AFTER_THING, ae_DO_AFTER_DO ]

  ae_DO_AFTER_DO:
    - match: '((\{))'
      captures:
        1: punctuation.definition.block.do-expression.begin.es
        2: meta.brace.curly.js # ^BS
      set: 'ae_DO_AFTER_BRACE'
    - include: other_illegal_pop

  ae_DO_AFTER_BRACE:
    - match: '((\}))'
      captures:
        1: punctuation.definition.block.do-expression.end.es
        2: meta.brace.curly.js # ^BS
      pop: true
    - include: statements

  ae_FUNCTION_GENERATOR_CLASS:
    - match: 'function\s*\.\s*sent'
      scope: variable.language.function-sent.es
      set: ae_AFTER_THING
    - match: '((function))\s*((\*))'
      captures:
        1: storage.type.function.js # ^BS -- Cobalt
        2: storage.type.function.generator.expression.es
        3: keyword.generator.asterisk.js # ^BS
        4: storage.modifier.generator.asterisk.expression.es
      set: ae_GENERATOR_AFTER_ASTERISK
    - match: '\s*((function)){{idEnd}}'
      captures:
        1: storage.type.function.js # ^BS -- Cobalt
        2: storage.type.function.expression.es
      set: ae_FUNCTION_AFTER_FUNCTION
    - match: '((async))\s+((function)){{idEnd}}'
      captures:
        1: storage.type.js # ^BS
        2: storage.modifier.async.expression.es
        3: storage.type.function.js # ^BS -- Cobalt
        4: storage.type.function.async.expression.es
      set:
        - - include: ae_ASYNC_AFTER_FUNCTION
        - - match: '((\*))'
            captures:
              1: keyword.generator.asterisk.js # ^BS
              2: storage.modifier.generator.asterisk.method.es
            pop: true
          - include: else_pop
    - match: 'class{{idEnd}}'
      scope: storage.type.class.expression.es
      set: ae_CLASS_AFTER_CLASS

  ae_FUNCTION_AFTER_FUNCTION:
    - match: '\('
      scope: punctuation.definition.parameters.function.begin.es
      set: [ ae_AFTER_THING, functionDeclaration_AFTER_PARAMS, parameters ]
    - match: '{{identifier}}'
      scope: entity.name.function.es
      set: [ ae_AFTER_THING, functionDeclaration_AFTER_NAME ]
    - include: other_illegal_pop

  ae_ASYNC_AFTER_FUNCTION:
    - match: '\('
      scope: punctuation.definition.parameters.function.async.begin.es
      set: [ ae_AFTER_THING, asyncDeclaration_AFTER_PARAMS, parameters ]
    - match: '{{identifier}}'
      scope: entity.name.function.async.es
      set: [ ae_AFTER_THING, asyncDeclaration_AFTER_NAME ]
    - include: other_illegal_pop

  ae_GENERATOR_AFTER_ASTERISK:
    - match: '\('
      scope: punctuation.definition.parameters.generator.begin.es
      set: [ ae_AFTER_THING, generatorDeclaration_AFTER_PARAMS, parameters ]
    - match: '{{identifier}}'
      scope: entity.name.function.generator.es
      set: [ ae_AFTER_THING, generatorDeclaration_AFTER_NAME ]
    - include: other_illegal_pop

  ae_IDENTIFIERS:
    - include: ae_IDENTIFIERS_LANGUAGE
    - match: '(({{identifier}}))\s*(=)\s*(\()(?=(?<parens>[^\(\)]|\(\g<parens>*\))*\)\s*=>)'
      captures:
        1: variable.other.readwrite.es
        2: entity.name.function.arrow.es
        3: keyword.operator.assignment.es
        4: punctuation.definition.parameters.function.arrow.begin.es
      set: [ ae_ARROW_AFTER_PARAMS, parameters ]
    - match: '(({{identifier}}))\s*(=)\s*({{identifier}})\s*(=>)'
      captures:
        1: variable.other.readwrite.es
        2: entity.name.function.arrow.es
        3: keyword.operator.assignment.es
        4: variable.parameter.es
        5: storage.type.function.arrow.es
      set: ae_ARROW_AFTER_ARROW
    - match: '(({{identifier}}))\s*(=)\s*((async))\s+({{identifier}})\s*(=>)'
      captures:
        1: variable.other.readwrite.es
        2: entity.name.function.async.arrow.es
        3: keyword.operator.assignment.es
        4: storage.type.js
        5: storage.modifier.async.expression.es
        6: variable.parameter.es
        7: storage.type.function.arrow.es
      set: ae_ASYNC_ARROW_AFTER_ARROW
    - match: '(({{identifier}}))\s*(=)\s*((async))\s*(\()'
      captures:
        1: variable.other.readwrite.es
        2: entity.name.function.async.arrow.es
        3: keyword.operator.assignment.es
        4: storage.type.js # ^BS
        5: storage.modifier.async.expression.es
        6: punctuation.definition.parameters.function.arrow.begin.es
      set: [ ae_ASYNC_ARROW_AFTER_PARAMS, parameters ]
    - match: '(({{identifier}}))\s*(=)\s*(?=function\s*\*)'
      captures:
        1: variable.other.readwrite.es
        2: entity.name.function.generator.es
        3: keyword.operator.assignment.es
      set: assignmentExpression
    - match: '(({{identifier}}))\s*(=)\s*(?=function{{idEnd}})'
      captures:
        1: variable.other.readwrite.es
        2: entity.name.function.es
        3: keyword.operator.assignment.es
      set: assignmentExpression
    - match: '(({{identifier}}))\s*(=)\s*(?=async\s+function{{idEnd}})'
      captures:
        1: variable.other.readwrite.es
        2: entity.name.function.async.es
        3: keyword.operator.assignment.es
      set: assignmentExpression
    - match: '({{identifier}})\s*(=>)'
      captures:
        1: variable.parameter.es
        2: storage.type.function.arrow.es
      set: ae_ARROW_AFTER_ARROW
    - match: '((async))\s+({{identifier}})\s*(=>)'
      captures:
        1: storage.type.js
        2: storage.modifier.async.expression.es
        3: variable.parameter.es
        4: storage.type.function.arrow.es
      set: ae_ASYNC_ARROW_AFTER_ARROW
    - include: ae_IDENTIFIERS_INTRINSIC
    - match: '((({{identifierAllCapsStrict}})))\s*((\())'
      captures:
        1: variable.other.readwrite.allCap.es # -BS
        2: meta.function-call # ^BS
        3: meta.invocation.es
        4: punctuation.definition.arguments.begin.es
        5: meta.brace.round.js # ^BS
      set: [ ae_AFTER_THING, arguments ]
    - match: '{{identifierAllCapsStrict}}'
      scope: variable.other.readwrite.allCap.es # -BS
      set: ae_AFTER_IDENTIFIER
    - match: '((({{identifierInitCapStrict}})))\s*((\())'
      captures:
        1: variable.other.readwrite.initCap.es
        2: meta.function-call # ^BS
        3: meta.invocation.es
        4: punctuation.definition.arguments.begin.es
        5: meta.brace.round.js # ^BS
      set: [ ae_AFTER_THING, arguments ]
    - match: '{{identifierInitCapStrict}}'
      scope: variable.other.readwrite.initCap.es
      set: ae_AFTER_IDENTIFIER
    - match: '((({{identifier}})))\s*((\())'
      captures:
        1: variable.other.readwrite.es
        2: meta.function-call # ^BS
        3: meta.invocation.es
        4: punctuation.definition.arguments.begin.es
        5: meta.brace.round.js # ^BS
      set: [ ae_AFTER_THING, arguments ]
    - match: '{{identifier}}'
      scope: variable.other.readwrite.es
      set: ae_AFTER_IDENTIFIER

  ae_IDENTIFIERS_LANGUAGE:
    # THIS
    - match: '(((this)))\s*((\())'
      captures:
        1: variable.language.this.es
        2: meta.function-call # ^BS
        3: meta.invocation.es
        4: punctuation.definition.arguments.begin.es
        5: meta.brace.round.js # ^BS
      set: [ ae_AFTER_THING, arguments ]
    - match: 'this{{idEnd}}'
      scope: variable.language.this.es
      set: ae_AFTER_THING
    # PIPELINE PROPOSAL
    - match: '#'
      scope: variable.language.topic.es
      set: ae_AFTER_THING
    # SUPER
    - match: '(((super)))\s*((\())'
      captures:
        1: variable.language.super.es
        2: meta.function-call # ^BS
        3: meta.invocation.es
        4: punctuation.definition.arguments.begin.es
        5: meta.brace.round.js # ^BS
      set: [ ae_AFTER_THING, arguments ]
    - match: 'super{{idEnd}}'
      scope: variable.language.super.es
      set: ae_AFTER_THING
    # IMPORT META
    - match: 'import\s*\.\s*meta\b'
      scope: variable.language.import-meta
      set: ae_AFTER_VALUE
    # DYNAMIC IMPORT
    - match: 'import\s*\('
      scope: variable.language.import-dynamic
      set:
        - - match: '\)'
            scope: variable.language.import-dynamic
            set: ae_AFTER_THING
          - include: other_illegal
        - - include: assignmentExpression
    # ARGUMENTS
    - match: 'arguments{{idEnd}}'
      scope: variable.language.arguments.es
      set: ae_AFTER_THING

  ae_IDENTIFIERS_INTRINSIC:
    # CONSTRUCTORS
    - match: '(?x) (((({{intrinsicConstructors}}))))\s*(?=\()'
      captures:
        1: variable.other.readwrite.initCap.es
        2: meta.instance.constructor # ^BS
        3: support.class.builtin.es
        4: meta.invocation.es
      set: ae_AFTER_THING
    - match: '(?x) ({{intrinsicConstructors}}){{idEnd}}'
      scope: variable.other.readwrite.es
      captures:
        1: support.class.builtin.es
      set: ae_AFTER_THING
    # OBJECTS
    - match: '(?:globalThis|Atomics|Intl|JSON|Math|Reflect){{idEnd}}'
      scope: support.variable.builtin.es
      set: ae_AFTER_THING
    # FUNCTIONS
    - match: '(?x) ((( {{intrinsicFunctions}} )))\s*((\())'
      captures:
        1: meta.function-call # ^BS
        2: meta.invocation.es
        3: support.function.builtin.es
        4: punctuation.definition.arguments.begin.es
        5: meta.brace.round.js # ^BS
      set: [ ae_AFTER_THING, arguments ]
    - match: '(?x) ({{intrinsicFunctions}}){{idEnd}}'
      scope: support.function.builtin.es
      set: ae_AFTER_THING

  ae_INFIX_OPS:
    # NULLISH COALESCING
    - match: '\?\?'
      scope: keyword.operator.logical.or.nullish-coalescing.es
      set: assignmentExpression
    # TERNARY
    - match: '\?'
      scope: keyword.operator.ternary.if.es
      set: ae_TERNARY_AFTER_QUESTION
    # ARITHMETIC
    - match: '\+(?!=)'
      scope: keyword.operator.arithmetic.addition.es
      set: assignmentExpression
    - match: '-(?!=)'
      scope: keyword.operator.arithmetic.subtraction.es
      set: assignmentExpression
    - match: '\*\*(?!=)'
      scope: keyword.operator.arithmetic.exponentiation.es
      set: assignmentExpression
    - match: '\*'
      scope: keyword.operator.arithmetic.multiplication.es
      set: assignmentExpression
    - match: '\/(?!=)'
      scope: keyword.operator.arithmetic.division.es
      set: assignmentExpression
    - match: '%(?!=)'
      scope: keyword.operator.arithmetic.modulo.es
      set: assignmentExpression
    # EQUALITY
    - match: '==='
      scope: keyword.operator.comparison.equality.strict.es
      set: assignmentExpression
    - match: '=='
      scope: keyword.operator.comparison.equality.coercive.es
      set: assignmentExpression
    - match: '!=='
      scope: keyword.operator.comparison.non-equality.strict.es
      set: assignmentExpression
    - match: '!='
      scope: keyword.operator.comparison.non-equality.coercive.es
      set: assignmentExpression
    # LOGICAL
    - match: '&&'
      scope: keyword.operator.logical.and.es
      set: assignmentExpression
    - match: '\|\|(?!=)'
      scope: keyword.operator.logical.or.es
      set: assignmentExpression
    # BITWISE LOGICAL
    - match: '&(?!=)'
      scope: keyword.operator.bitwise.logical.and.es
      set: assignmentExpression
    - match: '\|(?![=\|>])'
      scope: keyword.operator.bitwise.logical.or.es
      set: assignmentExpression
    - match: '\^(?!=)'
      scope: keyword.operator.bitwise.logical.xor.es
      set: assignmentExpression
    # BITWISE SHIFT
    - match: '<<(?!=)'
      scope: keyword.operator.bitwise.shift.left.es
      set: assignmentExpression
    - match: '>>>(?!=)'
      scope: keyword.operator.bitwise.shift.right.unsigned.es
      set: assignmentExpression
    - match: '>>(?![=>])'
      scope: keyword.operator.bitwise.shift.right.es
      set: assignmentExpression
    # RELATIONAL
    - match: '<='
      scope: keyword.operator.relational.lte.es
      set: assignmentExpression
    - match: '<'
      scope: keyword.operator.relational.lt.es
      set: assignmentExpression
    - match: '>='
      scope: keyword.operator.relational.gte.es
      set: assignmentExpression
    - match: '>'
      scope: keyword.operator.relational.gt.es
      set: assignmentExpression
    - match: 'instanceof{{idEnd}}'
      scope: keyword.operator.relational.instanceof.es
      set: assignmentExpression
    - match: 'in{{idEnd}}'
      scope: keyword.operator.relational.in.es
      set: assignmentExpression
    # APPLICATION
    - match: '\|>'
      scope: keyword.operator.pipeline.es
      set: assignmentExpression
    - match: '::'
      scope: keyword.operator.bind.es
      set: assignmentExpression

  ae_INFIX_OPS_ASSIGNMENT:
    # VANILLA
    - match: '=(?!=)'
      scope: keyword.operator.assignment.es
      set: assignmentExpression
    # ARITHMETIC
    - match: '\+='
      scope: keyword.operator.assignment.augmented.arithmetic.addition.es
      set: assignmentExpression
    - match: '-='
      scope: keyword.operator.assignment.augmented.arithmetic.subtraction.es
      set: assignmentExpression
    - match: '\*\*='
      scope: keyword.operator.assignment.augmented.arithmetic.exponentiation.es
      set: assignmentExpression
    - match: '\*='
      scope: keyword.operator.assignment.augmented.arithmetic.multiplication.es
      set: assignmentExpression
    - match: '\/='
      scope: keyword.operator.assignment.augmented.arithmetic.division.es
      set: assignmentExpression
    - match: '%='
      scope: keyword.operator.assignment.augmented.arithmetic.modulo.es
      set: assignmentExpression
    # MALLET
    - match: '\|\|='
      scope: keyword.operator.assignment.conditional.mallet.es
      set: assignmentExpression
    # BITWISE LOGICAL
    - match: '&='
      scope: keyword.operator.assignment.augmented.bitwise.logical.and.es
      set: assignmentExpression
    - match: '\^='
      scope: keyword.operator.assignment.augmented.bitwise.logical.xor.es
      set: assignmentExpression
    - match: '\|='
      scope: keyword.operator.assignment.augmented.bitwise.logical.or.es
      set: assignmentExpression
    # BITWISE SHIFT
    - match: '<<='
      scope: keyword.operator.assignment.augmented.bitwise.shift.left.es
      set: assignmentExpression
    - match: '>>>='
      scope: keyword.operator.assignment.augmented.bitwise.shift.right.unsigned.es
      set: assignmentExpression
    - match: '>>='
      scope: keyword.operator.assignment.augmented.bitwise.shift.right.es
      set: assignmentExpression

  ae_LITERAL_VALUES:
    # Technically ‘undefined’ and ‘Infinity’ aren’t language constants, but it’s
    # totally reasonable to scope them as such since this odd fact is just a bit
    # of legacy bs. In modern implementions they can’t be redefined (although
    # the assignment is itself a legal operation, fun fact).
    - match: 'NaN(?![{{ID_Continue}}])'
      scope: constant.language.nan.es
      set: ae_AFTER_VALUE
    - match: 'null(?![{{ID_Continue}}])'
      scope: constant.language.null.es
      set: ae_AFTER_VALUE
    - match: 'true(?![{{ID_Continue}}])'
      scope: constant.language.boolean.true.es
      set: ae_AFTER_VALUE
    - match: 'false(?![{{ID_Continue}}])'
      scope: constant.language.boolean.false.es
      set: ae_AFTER_VALUE
    - match: 'Infinity(?![{{ID_Continue}}])'
      scope: constant.language.infinity.es
      set: ae_AFTER_VALUE
    - match: 'undefined(?![{{ID_Continue}}])'
      scope: constant.language.undefined.es
      set: ae_AFTER_VALUE

  ae_NUMBERS:
    - match: '{{binNum}}'
      scope: constant.numeric.binary.es
      captures:
        1: meta.numeric.prefix.es
        2: meta.numeric.suffix.es
      set: ae_AFTER_VALUE
    - match: '{{octNum}}'
      scope: constant.numeric.octal.es
      captures:
        1: meta.numeric.prefix.es
        2: meta.numeric.suffix.es
      set: ae_AFTER_VALUE
    - match: '{{hexNum}}'
      scope: constant.numeric.hexadecimal.es
      captures:
        1: meta.numeric.prefix.es
        2: meta.numeric.suffix.es
      set: ae_AFTER_VALUE
    - match: '{{decNum}}'
      scope: constant.numeric.decimal.es
      captures:
        1: punctuation.decimal.es
        2: punctuation.decimal.es
        3: punctuation.decimal.es
        4: meta.numeric.exponent.e.es
        5: meta.numeric.exponent.sign.es
        6: meta.numeric.exponent.digit.es
        7: meta.numeric.suffix.es
      set: ae_AFTER_VALUE

  ae_OBJECT_ARRAY_BINDING:
    # Of all the ‘only works without naughty linebreak’ cases, this is the most
    # problematic, simply because unlike the others, it’s quite plausible that
    # a binding pattern could span multiple lines. Not an everyday thing, sure,
    # but I can imagine circumstances where it might make sense. I haven’t yet
    # worked out the best way to deal with this, but I think what we could do
    # is handle certain (normally illegal) tokens in obj/arr literals and
    # switch to binding at that point. You’d have the wrong scopes at the start,
    # but at least no ‘illegal’ sections.
    #
    # Note that ‘ae_AFTER_THING’ is fine since = is preestablished as the next
    # character.
    - match: '(?x) ((\{)) (?= (?<brackets> [^\{\}] | \{ \g<brackets>* \} )* \}\s*=[^=])'
      captures:
        1: punctuation.definition.binding.object.begin.es
        2: meta.brace.curly.js # ^BS
      set: [ ae_AFTER_THING, bindingObject ]
    - match: '(?x) ((\[)) (?= (?<brackets> [^\[\]] | \[ \g<brackets>* \] )* \]\s*=[^=])'
      captures:
        1: punctuation.definition.binding.array.begin.es
        2: meta.brace.square.js # ^BS
      set: [ ae_AFTER_THING, bindingArray ]

  ae_OBJECT_ARRAY_LITERAL:
    - match: '((\{))'
      captures:
        1: punctuation.definition.object.begin.es
        2: meta.brace.curly.js # ^BS
      set: [ ae_OBJECT_ARRAY_LITERAL_END, literalObject_OPEN ]
    - match: '((\[))'
      captures:
        1: punctuation.definition.array.begin.es
        2: meta.brace.square.js # ^BS
      set: [ ae_OBJECT_ARRAY_LITERAL_END, literalArray_OPEN ]

  ae_OBJECT_ARRAY_LITERAL_END:
    # Attempt recovery if this was actually a multiline binding pattern.
    - match: '=(?!=)'
      scope: keyword.operator.assignment.es
      set: assignmentExpression
    - include: ae_AFTER_VALUE

  ae_PARENTHESIZED:
    - match: '((\())'
      captures:
        1: punctuation.definition.expression.begin.es
        2: meta.brace.round.js # ^BS
      set: ae_PARENTHESIZED_AFTER_OPEN

  ae_PARENTHESIZED_AFTER_OPEN:
    # Note that we transition to ae_AFTER_IDENTIFIER. This is deliberate; it
    # allows us to recover from erroneous scoping if the parenthesized
    # expression was actually the parameters of an arrow function whose arrow
    # token was not on the same line as the opening parenthesis.
    - match: '((\)))'
      captures:
        1: punctuation.definition.expression.end.es
        2: meta.brace.round.js # ^BS
      set: ae_AFTER_IDENTIFIER
    - match: '{{PLA_anything}}'
      push: expression

  ae_POSTFIX_OPS:
    # Always wondered: why do we say ‘postfix’ instead of ‘suffix’?
    - match: '\+\+'
      scope: keyword.operator.arithmetic.increment.postfix.es
      set: ae_AFTER_POSTFIX
    - match: '--'
      scope: keyword.operator.arithmetic.decrement.postfix.es
      set: ae_AFTER_POSTFIX

  ae_PREFIX_OPS:
    # Note that these matches do not cause a context transition.
    - match: 'delete{{idEnd}}'
      scope: keyword.operator.unary.delete.es
    - match: 'void{{idEnd}}'
      scope: keyword.operator.unary.void.es
    - match: 'typeof{{idEnd}}'
      scope: keyword.operator.unary.typeof.es
    - match: '\+\+'
      scope: keyword.operator.arithmetic.increment.prefix.es
    - match: '\+'
      scope: keyword.operator.arithmetic.sign.positive.es
    - match: '--'
      scope: keyword.operator.arithmetic.decrement.prefix.es
    - match: '-'
      scope: keyword.operator.arithmetic.sign.negative.es
    - match: '~'
      scope: keyword.operator.bitwise.logical.not.es
    - match: '(!!)'
      scope: keyword.operator.logical.not.es
      captures:
        1: meta.idiomatic-cast.boolean.es
    - match: '!'
      scope: keyword.operator.logical.not.es
    - match: '::'
      scope: keyword.operator.bind.es
    # The current strawman spec suggests this is the reasonable place for await.
    # Syntactically, it isn’t like yield. I’m unsure if this is intended to be a
    # no-linebreak-here situation. Babel currently gets upset by newlines before
    # the operand, but the spec doesn’t say anything about this.
    - match: 'await{{idEnd}}'
      scope: keyword.control.flow.await

  ae_STRING_REGEX:
    - match: "'"
      scope: punctuation.definition.string.quoted.single.begin.es
      set: [ ae_AFTER_VALUE, stringSingle_AFTER_OPEN ]
    - match: '"'
      scope: punctuation.definition.string.quoted.double.begin.es
      set: [ ae_AFTER_VALUE, stringDouble_AFTER_OPEN ]
    - match: '`'
      scope: punctuation.definition.string.interpolated.begin.es
      set: [ ae_AFTER_VALUE, templateString_AFTER_OPEN ]
    - match: '\/'
      scope: punctuation.definition.string.regexp.begin.es
      set: [ ae_AFTER_VALUE, regex_AFTER_OPEN ]
    - match: '((css))\s*(`)'
      comment: '$blacklist(nested)'
      captures:
        1: entity.quasi.tag.name.js # ^BS
        2: variable.other.readwrite.tag.es
        3: string.interpolated.es punctuation.definition.string.interpolated.begin.es
      set: [ ae_AFTER_VALUE, ae_CSS_STRING ]
    - match: '((html))\s*(?=`)'
      comment: '$blacklist(nested)'
      captures:
        1: entity.quasi.tag.name.js # ^BS
        2: variable.other.readwrite.tag.es
      set: [ ae_AFTER_VALUE, syntax_EXIT, syntax_meta_HTML, syntax_HTML_OPEN ]
    - match: '(({{identifier}}))\s*(`)'
      captures:
        1: entity.quasi.tag.name.js # ^BS
        2: variable.other.readwrite.tag.es
        3: punctuation.definition.string.interpolated.begin.es
      set: [ ae_AFTER_VALUE, templateString_AFTER_OPEN ]

  ae_TERNARY_AFTER_QUESTION:
    - match: ':'
      scope: invalid.illegal.token.es
      set: assignmentExpression
    - match: '{{PLA_anything}}'
      set: [ ae_TERNARY_AFTER_IF_CASE, assignmentExpression ]

  ae_TERNARY_AFTER_IF_CASE:
    - match:  ':'
      scope: keyword.operator.ternary.else.es
      set: assignmentExpression
    - include: other_illegal_pop

  ae_YIELD_NEW:
    # Grouped simply because they both have weird rules. Yield is unique
    # because it’s the only time ‘assignment expression or nothing’ is valid.
    # New is weird because, as of ES6, it’s both an operator and, contextually,
    # a ... well, a token in a series of three tokens that resolves to a
    # reference and appears to be property access but actually is a composite
    # language keyword which may contain an arbitrary amount of whitespace and
    # newlines.
    #
    # Congratulations on your new Wat()...
    #
    #   new                               .                          target
    #   ,                                new                        .target
    #   ,                                new                              .
    #   target,                          new
    #                                  .target,
    #   new                            .target,                         new
    #                .                target,new                .
    #   target,     new                .target,                new        .
    #   target,     new                .target,                new        .
    #              target,            new.target              ,new.
    #              target,            new.target,     new   .target,
    #   new       .target,          new.target,new          .target,
    #            new.target,        new.target,new          .target,
    #            new.target,      new . target, new.       target,new
    #            . target ,       new . target ,new.       new.target,
    #            new.target,     new.target,new.target    ,new.target,
    #           new .target, new.target,new. target ,new. target, new.
    #          target,new . target,new. target,new .target,new. target,
    #          new . target,new . target,new . target,new . target,new
    #        .target,new. target,new.target new .target ,new.target,new.
    #        target,new .target,new.target , new. target,new .target,new
    #                          .target == ANGKOR WAT
    - match: >-
        (?x)
          (new) \s+ (((
            ( {{intrinsicConstructors}} ) |
            {{identifier}}
          ))){{idEnd}}(?!\s*\.)
      captures:
        1: keyword.operator.new.es
        2: variable.other.readwrite.es
        3: meta.instance.constructor entity.name.type.new # ^BS
        4: meta.instantiation.es
        5: support.class.builtin.es
      set: ae_AFTER_THING
    # When the constructor is a property it’s tougher. Rather than creating a
    # new set of contexts for this case, we’ll handle up to the fifth level and
    # consider anything else a rare enough edge case to not worry about.
    - match: >-
        (?x)
          (new) \s+
          (?: ({{identifier}}) (\.) )
          (?: ({{identifier}}) (\.)
            (?: ({{identifier}}) (\.)
              (?:
                ({{identifier}}) (\.)
              )?
            )?
          )?
          ((({{identifier}})))(?!\s*\.)
      captures:
        1: keyword.operator.new.es
        2: variable.other.readwrite.es
        3: keyword.operator.accessor.es
        4: variable.other.readwrite.es
        5: keyword.operator.accessor.es
        6: variable.other.readwrite.es
        7: keyword.operator.accessor.es
        8: variable.other.readwrite.es
        9: keyword.operator.accessor.es
        10: variable.other.readwrite.es
        11: meta.instance.constructor entity.name.type.new # ^BS, augmented
        12: meta.instantiation.es
      set: ae_AFTER_THING
    - match: '(new)\s*(\.)'
      captures:
        1: variable.language.new-target.fake-object.es
        2: variable.language.new-target.fake-accessor.es
      set: ae_YIELD_NEW_AFTER_NEW_WAT
    - match: 'new{{idEnd}}'
      scope: keyword.operator.new.es
      set: ae_YIELD_NEW_AFTER_NEW_OPERATOR
    - match: 'yield{{idEnd}}'
      scope: keyword.control.flow.yield.es
      set: ae_YIELD_NEW_AFTER_YIELD

  ae_YIELD_NEW_AFTER_YIELD:
    - match: '\*'
      scope: keyword.control.flow.yield.iterate.es # -BS
      set: assignmentExpression
    - match: '$|(?=\})'
      pop: true
    - include: assignmentExpression_CORE
    - include: else_pop

  ae_YIELD_NEW_AFTER_NEW_OPERATOR:
    # Newlines are permitted, so it’s ‘possible’ that the previously matched
    # ‘new operator’ was actually a reference to the ‘new object’. Hey, I try to
    # be rigorous.
    - match: '\.'
      scope: variable.language.new-target.fake-accessor.es
      set: ae_YIELD_NEW_AFTER_NEW_WAT
    - include: assignmentExpression

  ae_YIELD_NEW_AFTER_NEW_WAT:
    - match: 'target{{idEnd}}'
      scope: variable.language.new-target.fake-property.es
      set: ae_AFTER_THING
    - match: '{{MAT_word_or_any_one_char}}'
      scope: invalid.illegal.token.es
      set: ae_AFTER_ACCESSOR_OPERATOR

################################################################################
################################################################################
################################################################################
#   DO NOT UPDATE THIS SECTION DIRECTLY -- IT SHOULD ALWAYS MIRROR THE ABOVE   #
#   BUT WITH _NO_IN -- and no "in". (Though prefix ops can be reused). Just    #
#   F&R and re-paste over this. I may just add a build script to handle this   #
#   later.                                                                     #
################################################################################

  assignmentExpression_NO_IN:
    - include: assignmentExpression_NO_IN_CORE
    - include: other_illegal_pop
  assignmentExpression_NO_IN_CORE:
    - include: syntax_NO_IN_OPEN
    - include: ae_NO_IN_LITERAL_VALUES
    - include: ae_NO_IN_NUMBERS
    - include: ae_NO_IN_STRING_REGEX
    - include: ae_NO_IN_OBJECT_ARRAY_BINDING
    - include: ae_NO_IN_OBJECT_ARRAY_LITERAL
    - include: ae_NO_IN_YIELD_NEW
    - include: ae_NO_IN_FUNCTION_GENERATOR_CLASS
    - include: ae_PREFIX_OPS
    - include: ae_NO_IN_ARROW
    - include: ae_NO_IN_IDENTIFIERS
    - include: ae_NO_IN_PARENTHESIZED
    - include: ae_NO_IN_DO
  ae_NO_IN_AFTER_IDENTIFIER:
    - match: '=>'
      scope: storage.type.function.arrow.es
      set: ae_NO_IN_ARROW_AFTER_ARROW
    - include: ae_NO_IN_AFTER_THING
  ae_NO_IN_AFTER_THING:
    - match: '((\())'
      captures:
        1: punctuation.definition.arguments.begin.es
        2: meta.brace.round.js
      push: arguments
    - match: '`'
      scope: punctuation.definition.string.interpolated.begin.es
      set: [ ae_NO_IN_AFTER_VALUE, templateString_AFTER_OPEN ]
    - include: syntax_NO_IN_OPEN
    - include: ae_NO_IN_POSTFIX_OPS
    - include: ae_NO_IN_INFIX_OPS_ASSIGNMENT
    - include: ae_NO_IN_AFTER_VALUE
  ae_NO_IN_AFTER_VALUE:
    - match: '\.(?!\d|\.\.)'
      scope: keyword.operator.accessor.es
      set: ae_NO_IN_AFTER_ACCESSOR_OPERATOR
    - match: '\?\.(?!\d)'
      scope: keyword.operator.accessor.optional-chaining.es
      set: ae_NO_IN_AFTER_ACCESSOR_OPERATOR
    - match: '((\[))'
      captures:
        1: punctuation.definition.accessor.begin.es
        2: meta.brace.square.js
      set: [ ae_NO_IN_AFTER_THING, computedProp_AFTER_AE, assignmentExpression_NO_IN ]
    - include: ae_NO_IN_INFIX_OPS
    - include: ae_NO_IN_AFTER_POSTFIX
  ae_NO_IN_AFTER_POSTFIX:
    - include: ae_NO_IN_INFIX_OPS
    - include: else_pop
  ae_NO_IN_AFTER_ACCESSOR_OPERATOR:
    - match: '((({{identifierAllCaps}})))\s*((\())'
      captures:
        1: variable.other.readwrite.property.allCap.es
        2: meta.function-call
        3: meta.invocation.es
        4: punctuation.definition.arguments.begin.es
        5: meta.brace.round.js
      set: [ ae_NO_IN_AFTER_THING, arguments ]
    - match: '((({{identifierInitCap}})))\s*((\())'
      captures:
        1: variable.other.readwrite.property.initCap.es
        2: meta.function-call
        3: meta.invocation.es
        4: punctuation.definition.arguments.begin.es
        5: meta.brace.round.js
      set: [ ae_NO_IN_AFTER_THING, arguments ]
    - match: '((({{identifierName}})))\s*((\())'
      captures:
        1: variable.other.readwrite.property.es
        2: meta.function-call
        3: meta.invocation.es
        4: punctuation.definition.arguments.begin.es
        5: meta.brace.round.js
      set: [ ae_NO_IN_AFTER_THING, arguments ]
    - match: '(((#{{identifierName}})))\s*((\())'
      captures:
        1: variable.language.private.es
        2: meta.function-call
        3: meta.invocation.es
        4: punctuation.definition.arguments.begin.es
        5: meta.brace.round.js
      set: [ ae_NO_IN_AFTER_THING, arguments ]
    - match: '(prototype){{idEnd}}'
      scope: variable.other.readwrite.property.prototype.es
      captures:
        1: variable.language.prototype.es
      set: ae_NO_IN_AFTER_THING
    - match: '(__proto__){{idEnd}}'
      scope: variable.other.readwrite.property.proto.es
      captures:
        1: variable.language.proto.es
      set: ae_NO_IN_AFTER_THING
    - match: '{{identifierName}}'
      scope: variable.other.readwrite.property.es
      set: ae_NO_IN_AFTER_THING
    - match: '#{{identifierName}}'
      scope: variable.language.private.es
      set: ae_NO_IN_AFTER_THING
    - include: other_illegal_pop
  ae_NO_IN_ARROW:
    - match: '(?x) \( (?= (?<parens> [^\(\)] | \( \g<parens>* \) )* \)\s*=> )'
      scope: punctuation.definition.parameters.function.arrow.begin.es
      set: [ ae_NO_IN_ARROW_AFTER_PARAMS, parameters ]
    - match: '((async))\s*(\()'
      captures:
        1: storage.type.js
        2: storage.modifier.async.expression.es
        3: punctuation.definition.parameters.function.arrow.begin.es
      set: [ ae_NO_IN_ARROW_AFTER_PARAMS, parameters ]
  ae_NO_IN_ARROW_AFTER_PARAMS:
    - match: '\)'
      scope: punctuation.definition.parameters.function.arrow.end.es
      set: ae_NO_IN_ARROW_BEFORE_ARROW
    - include: other_illegal_pop
  ae_NO_IN_ARROW_BEFORE_ARROW:
    - match: '=>'
      scope: storage.type.function.arrow.es
      set: ae_NO_IN_ARROW_AFTER_ARROW
    - include: other_illegal_pop
  ae_NO_IN_ARROW_AFTER_ARROW:
    - match: '((\{))'
      captures:
        1: punctuation.definition.function.arrow.body.begin.es
        2: meta.brace.curly.js
      set: ae_NO_IN_ARROW_AFTER_BRACE
    - match: '{{PLA_anything}}'
      set: assignmentExpression_NO_IN
  ae_NO_IN_ARROW_AFTER_BRACE:
    - match: '((\}))'
      captures:
        1: punctuation.definition.function.arrow.body.end.es
        2: meta.brace.curly.js
      set: ae_NO_IN_AFTER_THING
    - include: useStrict
    - include: statements
    - include: other_illegal
  ae_NO_IN_CLASS_AFTER_CLASS:
    - match: '((\{))'
      captures:
        1: punctuation.definition.class.body.begin.es
        2: meta.brace.curly.js
      set: [ ae_NO_IN_AFTER_THING, classDeclaration_AFTER_BRACE ]
    - match: '((extends)){{idEnd}}'
      captures:
        1: storage.type.extends.js
        2: storage.modifier.extends.es
      set: [ ae_NO_IN_AFTER_THING, classDeclaration_AFTER_HERITAGE, assignmentExpression_NO_IN ]
    - match: '(({{identifier}}))'
      captures:
        1: entity.name.class.js
        2: entity.name.class.es
      set: [ ae_NO_IN_AFTER_THING, classDeclaration_AFTER_NAME ]
    - include: other_illegal_pop
  ae_NO_IN_DO:
    - match: 'do{{idEnd}}'
      scope: keyword.control.do-expression.do.es
      set: [ ae_NO_IN_AFTER_THING, ae_DO_AFTER_DO ]
  ae_NO_IN_FUNCTION_GENERATOR_CLASS:
    - match: 'function\s*\.\s*sent'
      scope: variable.language.function-sent.es
      set: ae_NO_IN_AFTER_THING
    - match: '((function))\s*((\*))'
      captures:
        1: storage.type.function.js
        2: storage.type.function.generator.expression.es
        3: keyword.generator.asterisk.js
        4: storage.modifier.generator.asterisk.expression.es
      set: ae_NO_IN_GENERATOR_AFTER_ASTERISK
    - match: '((async))?\s*((function)){{idEnd}}'
      captures:
        1: storage.type.js
        2: storage.modifier.async.expression.es
        3: storage.type.function.js
        4: storage.type.function.expression.es
      set: ae_NO_IN_FUNCTION_AFTER_FUNCTION
    - match: 'class{{idEnd}}'
      scope: storage.type.class.expression.es
      set: ae_NO_IN_CLASS_AFTER_CLASS
  ae_NO_IN_FUNCTION_AFTER_FUNCTION:
    - match: '\('
      scope: punctuation.definition.parameters.function.begin.es
      set: [ ae_NO_IN_AFTER_THING, functionDeclaration_AFTER_PARAMS, parameters ]
    - match: '{{identifier}}'
      scope: entity.name.function.es
      set: [ ae_NO_IN_AFTER_THING, functionDeclaration_AFTER_NAME ]
    - include: other_illegal_pop
  ae_NO_IN_GENERATOR_AFTER_ASTERISK:
    - match: '\('
      scope: punctuation.definition.parameters.generator.begin.es
      set: [ ae_NO_IN_AFTER_THING, generatorDeclaration_AFTER_PARAMS, parameters ]
    - match: '{{identifier}}'
      scope: entity.name.function.generator.es
      set: [ ae_NO_IN_AFTER_THING, generatorDeclaration_AFTER_NAME ]
    - include: other_illegal_pop
  ae_NO_IN_IDENTIFIERS:
    - include: ae_NO_IN_IDENTIFIERS_LANGUAGE
    - match: '({{identifier}})\s*(=>)'
      captures:
        1: variable.parameter.es
        2: storage.type.function.arrow.es
      set: ae_NO_IN_ARROW_AFTER_ARROW
    - include: ae_NO_IN_IDENTIFIERS_INTRINSIC
    - match: '((({{identifierAllCapsStrict}})))\s*((\())'
      captures:
        1: variable.other.readwrite.allCap.es
        2: meta.function-call
        3: meta.invocation.es
        4: punctuation.definition.arguments.begin.es
        5: meta.brace.round.js
      set: [ ae_NO_IN_AFTER_THING, arguments ]
    - match: '{{identifierAllCapsStrict}}'
      scope: variable.other.readwrite.allCap.es
      set: ae_NO_IN_AFTER_IDENTIFIER
    - match: '((({{identifierInitCapStrict}})))\s*((\())'
      captures:
        1: variable.other.readwrite.initCap.es
        2: meta.function-call
        3: meta.invocation.es
        4: punctuation.definition.arguments.begin.es
        5: meta.brace.round.js
      set: [ ae_NO_IN_AFTER_THING, arguments ]
    - match: '{{identifierInitCapStrict}}'
      scope: variable.other.readwrite.initCap.es
      set: ae_NO_IN_AFTER_IDENTIFIER
    - match: '((({{identifier}})))\s*((\())'
      captures:
        1: variable.other.readwrite.es
        2: meta.function-call
        3: meta.invocation.es
        4: punctuation.definition.arguments.begin.es
        5: meta.brace.round.js
      set: [ ae_NO_IN_AFTER_THING, arguments ]
    - match: '{{identifier}}'
      scope: variable.other.readwrite.es
      set: ae_NO_IN_AFTER_IDENTIFIER
  ae_NO_IN_IDENTIFIERS_LANGUAGE:
    - match: '(((this)))\s*((\())'
      captures:
        1: variable.language.this.es
        2: meta.function-call
        3: meta.invocation.es
        4: punctuation.definition.arguments.begin.es
        5: meta.brace.round.js
      set: [ ae_NO_IN_AFTER_THING, arguments ]
    - match: 'this{{idEnd}}'
      scope: variable.language.this.es
      set: ae_NO_IN_AFTER_THING
    - match: '(((super)))\s*((\())'
      captures:
        1: variable.language.super.es
        2: meta.function-call
        3: meta.invocation.es
        4: punctuation.definition.arguments.begin.es
        5: meta.brace.round.js
      set: [ ae_NO_IN_AFTER_THING, arguments ]
    - match: 'super{{idEnd}}'
      scope: variable.language.super.es
      set: ae_NO_IN_AFTER_THING
    - match: 'import\s*\.\s*meta\b'
      scope: variable.language.import-meta
      set: ae_NO_IN_AFTER_VALUE
    - match: 'import\s*\('
      scope: variable.language.import-dynamic
      set:
        - - match: '\)'
            scope: variable.language.import-dynamic
            set: ae_NO_IN_AFTER_THING
          - include: other_illegal
        - - include: assignmentExpression_NO_IN
    - match: 'arguments{{idEnd}}'
      scope: variable.language.arguments.es
      set: ae_NO_IN_AFTER_THING
  ae_NO_IN_IDENTIFIERS_INTRINSIC:
    - match: '(?x) (((({{intrinsicConstructors}}))))\s*(?=\()'
      captures:
        1: variable.other.readwrite.initCap.es
        2: meta.instance.constructor # ^BS
        3: support.class.builtin.es
        4: meta.invocation.es
      set: ae_NO_IN_AFTER_THING
    - match: '(?x) ({{intrinsicConstructors}}){{idEnd}}'
      scope: variable.other.readwrite.es
      captures:
        1: support.class.builtin.es
      set: ae_NO_IN_AFTER_THING
    - match: '(?:globalThis|Intl|JSON|Math|Reflect){{idEnd}}'
      scope: support.variable.builtin.es
      set: ae_NO_IN_AFTER_THING
    - match: '(?x) ((( {{intrinsicFunctions}} )))\s*((\())'
      captures:
        1: meta.function-call
        2: meta.invocation.es
        3: support.function.builtin.es
        4: punctuation.definition.arguments.begin.es
        5: meta.brace.round.js
      set: [ ae_NO_IN_AFTER_THING, arguments ]
    - match: '(?x) ({{intrinsicFunctions}}){{idEnd}}'
      scope: support.function.builtin.es
      set: ae_NO_IN_AFTER_THING
  ae_NO_IN_INFIX_OPS:
    - match: '\?\?'
      scope: keyword.operator.logical.or.nullish-coalescing.es
      set: assignmentExpression_NO_IN
    - match: '\?'
      scope: keyword.operator.ternary.if.es
      set: ae_NO_IN_TERNARY_AFTER_QUESTION
    - match: '\+(?!=)'
      scope: keyword.operator.arithmetic.addition.es
      set: assignmentExpression_NO_IN
    - match: '-(?!=)'
      scope: keyword.operator.arithmetic.subtraction.es
      set: assignmentExpression_NO_IN
    - match: '\*\*(?!=)'
      scope: keyword.operator.arithmetic.exponentiation.es
      set: assignmentExpression_NO_IN
    - match: >-
        (?x)
          \*
          (?! [=\*])
          (?! \s* " [^"]+ " \s* \( )
          (?! \s* '' [^'']+ '' \s* \( )
          (?! \s* \[ [\]]+ \] \s* \( )
          (?! \s* {{identifier}} \s* \([^)]*\) \s* \{)
      scope: keyword.operator.arithmetic.multiplication.es
      set: assignmentExpression_NO_IN
    - match: '\/(?!=)'
      scope: keyword.operator.arithmetic.division.es
      set: assignmentExpression_NO_IN
    - match: '%(?!=)'
      scope: keyword.operator.arithmetic.modulo.es
      set: assignmentExpression_NO_IN
    - match: '==='
      scope: keyword.operator.comparison.equality.strict.es
      set: assignmentExpression_NO_IN
    - match: '=='
      scope: keyword.operator.comparison.equality.coercive.es
      set: assignmentExpression_NO_IN
    - match: '!=='
      scope: keyword.operator.comparison.non-equality.strict.es
      set: assignmentExpression_NO_IN
    - match: '!='
      scope: keyword.operator.comparison.non-equality.coercive.es
      set: assignmentExpression_NO_IN
    - match: '&&'
      scope: keyword.operator.logical.and.es
      set: assignmentExpression_NO_IN
    - match: '\|\|(?!=)'
      scope: keyword.operator.logical.or.es
      set: assignmentExpression_NO_IN
    - match: '&(?!=)'
      scope: keyword.operator.bitwise.logical.and.es
      set: assignmentExpression_NO_IN
    - match: '\|(?![=\|])'
      scope: keyword.operator.bitwise.logical.or.es
      set: assignmentExpression_NO_IN
    - match: '\^(?!=)'
      scope: keyword.operator.bitwise.logical.xor.es
      set: assignmentExpression_NO_IN
    - match: '<<(?!=)'
      scope: keyword.operator.bitwise.shift.left.es
      set: assignmentExpression_NO_IN
    - match: '>>>(?!=)'
      scope: keyword.operator.bitwise.shift.right.unsigned.es
      set: assignmentExpression_NO_IN
    - match: '>>(?![=>])'
      scope: keyword.operator.bitwise.shift.right.es
      set: assignmentExpression_NO_IN
    - match: '<='
      scope: keyword.operator.relational.lte.es
      set: assignmentExpression_NO_IN
    - match: '<'
      scope: keyword.operator.relational.lt.es
      set: assignmentExpression_NO_IN
    - match: '>='
      scope: keyword.operator.relational.gte.es
      set: assignmentExpression_NO_IN
    - match: '>'
      scope: keyword.operator.relational.gt.es
      set: assignmentExpression_NO_IN
    - match: 'instanceof{{idEnd}}'
      scope: keyword.operator.relational.instanceof.es
      set: assignmentExpression_NO_IN
    - match: '::'
      scope: keyword.operator.bind.es
      set: assignmentExpression_NO_IN
  ae_NO_IN_INFIX_OPS_ASSIGNMENT:
    - match: '=(?!=)'
      scope: keyword.operator.assignment.es
      set: assignmentExpression_NO_IN
    - match: '\+='
      scope: keyword.operator.assignment.augmented.arithmetic.addition.es
      set: assignmentExpression_NO_IN
    - match: '-='
      scope: keyword.operator.assignment.augmented.arithmetic.subtraction.es
      set: assignmentExpression_NO_IN
    - match: '\*\*='
      scope: keyword.operator.assignment.augmented.arithmetic.exponentiation.es
      set: assignmentExpression_NO_IN
    - match: '\*='
      scope: keyword.operator.assignment.augmented.arithmetic.multiplication.es
      set: assignmentExpression_NO_IN
    - match: '\/='
      scope: keyword.operator.assignment.augmented.arithmetic.division.es
      set: assignmentExpression_NO_IN
    - match: '%='
      scope: keyword.operator.assignment.augmented.arithmetic.modulo.es
      set: assignmentExpression_NO_IN
    - match: '\|\|='
      scope: keyword.operator.assignment.conditional.mallet.es
      set: assignmentExpression_NO_IN
    - match: '&='
      scope: keyword.operator.assignment.augmented.bitwise.logical.and.es
      set: assignmentExpression_NO_IN
    - match: '\^='
      scope: keyword.operator.assignment.augmented.bitwise.logical.xor.es
      set: assignmentExpression_NO_IN
    - match: '\|='
      scope: keyword.operator.assignment.augmented.bitwise.logical.or.es
      set: assignmentExpression_NO_IN
    - match: '<<='
      scope: keyword.operator.assignment.augmented.bitwise.shift.left.es
      set: assignmentExpression_NO_IN
    - match: '>>>='
      scope: keyword.operator.assignment.augmented.bitwise.shift.right.unsigned.es
      set: assignmentExpression_NO_IN
    - match: '>>='
      scope: keyword.operator.assignment.augmented.bitwise.shift.right.es
      set: assignmentExpression_NO_IN
  ae_NO_IN_LITERAL_VALUES:
    - match: 'NaN(?![{{ID_Continue}}])'
      scope: constant.language.nan.es
      set: ae_NO_IN_AFTER_VALUE
    - match: 'null(?![{{ID_Continue}}])'
      scope: constant.language.null.es
      set: ae_NO_IN_AFTER_VALUE
    - match: 'true(?![{{ID_Continue}}])'
      scope: constant.language.boolean.true.es
      set: ae_NO_IN_AFTER_VALUE
    - match: 'false(?![{{ID_Continue}}])'
      scope: constant.language.boolean.false.es
      set: ae_NO_IN_AFTER_VALUE
    - match: 'Infinity(?![{{ID_Continue}}])'
      scope: constant.language.infinity.es
      set: ae_NO_IN_AFTER_VALUE
    - match: 'undefined(?![{{ID_Continue}}])'
      scope: constant.language.undefined.es
      set: ae_NO_IN_AFTER_VALUE
  ae_NO_IN_NUMBERS:
    - match: '{{binNum}}'
      scope: constant.numeric.binary.es
      captures:
        1: meta.numeric.prefix.es
        2: meta.numeric.suffix.es
      set: ae_NO_IN_AFTER_VALUE
    - match: '{{octNum}}'
      scope: constant.numeric.octal.es
      captures:
        1: meta.numeric.prefix.es
        2: meta.numeric.suffix.es
      set: ae_NO_IN_AFTER_VALUE
    - match: '{{hexNum}}'
      scope: constant.numeric.hexadecimal.es
      captures:
        1: meta.numeric.prefix.es
        2: meta.numeric.suffix.es
      set: ae_NO_IN_AFTER_VALUE
    - match: '{{decNum}}'
      scope: constant.numeric.decimal.es
      captures:
        1: punctuation.decimal.es
        2: punctuation.decimal.es
        3: punctuation.decimal.es
        4: meta.numeric.exponent.e.es
        5: meta.numeric.exponent.sign.es
        6: meta.numeric.exponent.digit.es
        7: meta.numeric.suffix.es
      set: ae_NO_IN_AFTER_VALUE
  ae_NO_IN_OBJECT_ARRAY_BINDING:
    - match: '(?x) ((\{)) (?= (?<brackets> [^\{\}] | \{ \g<brackets>* \} )* \}\s*=[^=])'
      captures:
        1: punctuation.definition.binding.object.begin.es
        2: meta.brace.curly.js
      set: [ ae_NO_IN_AFTER_THING, bindingObject ]
    - match: '(?x) ((\[)) (?= (?<brackets> [^\[\]] | \[ \g<brackets>* \] )* \]\s*=[^=])'
      captures:
        1: punctuation.definition.binding.array.begin.es
        2: meta.brace.square.js
      set: [ ae_NO_IN_AFTER_THING, bindingArray ]
  ae_NO_IN_OBJECT_ARRAY_LITERAL:
    - match: '((\{))'
      captures:
        1: punctuation.definition.object.begin.es
        2: meta.brace.curly.js
      set: [ ae_NO_IN_OBJECT_ARRAY_LITERAL_END, literalObject_OPEN ]
    - match: '((\[))'
      captures:
        1: punctuation.definition.array.begin.es
        2: meta.brace.square.js
      set: [ ae_NO_IN_OBJECT_ARRAY_LITERAL_END, literalArray_OPEN ]
  ae_NO_IN_OBJECT_ARRAY_LITERAL_END:
    - match: '=(?!=)'
      scope: keyword.operator.assignment.es
      set: assignmentExpression_NO_IN
    - include: ae_NO_IN_AFTER_VALUE
  ae_NO_IN_PARENTHESIZED:
    - match: '((\())'
      captures:
        1: punctuation.definition.expression.begin.es
        2: meta.brace.round.js
      set: ae_NO_IN_PARENTHESIZED_AFTER_OPEN
  ae_NO_IN_PARENTHESIZED_AFTER_OPEN:
    - match: '((\)))'
      captures:
        1: punctuation.definition.expression.end.es
        2: meta.brace.round.js
      set: ae_NO_IN_AFTER_IDENTIFIER
    - match: '{{PLA_anything}}'
      push: expression
  ae_NO_IN_POSTFIX_OPS:
    - match: '\+\+'
      scope: keyword.operator.arithmetic.increment.postfix.es
      set: ae_NO_IN_AFTER_POSTFIX
    - match: '--'
      scope: keyword.operator.arithmetic.decrement.postfix.es
      set: ae_NO_IN_AFTER_POSTFIX
  ae_NO_IN_STRING_REGEX:
    - match: "'"
      scope: punctuation.definition.string.quoted.single.begin.es
      set: [ ae_NO_IN_AFTER_VALUE, stringSingle_AFTER_OPEN ]
    - match: '"'
      scope: punctuation.definition.string.quoted.double.begin.es
      set: [ ae_NO_IN_AFTER_VALUE, stringDouble_AFTER_OPEN ]
    - match: '`'
      scope: punctuation.definition.string.interpolated.begin.es
      set: [ ae_NO_IN_AFTER_VALUE, templateString_AFTER_OPEN ]
    - match: '\/'
      scope: punctuation.definition.string.regexp.begin.es
      set: [ ae_NO_IN_AFTER_VALUE, regex_AFTER_OPEN ]
    - match: '(({{identifier}}))\s*(`)'
      captures:
        1: entity.quasi.tag.name.js
        2: variable.other.readwrite.tag.es
        3: punctuation.definition.string.interpolated.begin.es
      set: [ ae_NO_IN_AFTER_VALUE, templateString_AFTER_OPEN ]
  ae_NO_IN_TERNARY_AFTER_QUESTION:
    - match: ':'
      scope: invalid.illegal.token.es
      set: assignmentExpression_NO_IN
    - match: '{{PLA_anything}}'
      set: [ ae_NO_IN_TERNARY_AFTER_IF_CASE, assignmentExpression_NO_IN ]
  ae_NO_IN_TERNARY_AFTER_IF_CASE:
    - match:  ':'
      scope: keyword.operator.ternary.else.es
      set: assignmentExpression_NO_IN
    - include: other_illegal_pop
  ae_NO_IN_YIELD_NEW:
    - match: >-
        (?x)
          (new) \s+ (((
            ( {{intrinsicConstructors}} ) |
            {{identifier}}
          ))){{idEnd}}(?!\s*\.)
      captures:
        1: keyword.operator.new.es
        2: variable.other.readwrite.es
        3: meta.instance.constructor entity.name.type.new
        4: meta.instantiation.es
        5: support.class.builtin.es
      set: ae_NO_IN_AFTER_THING
    - match: >-
        (?x)
          (new) \s+
          (?: ({{identifier}}) (\.) )
          (?: ({{identifier}}) (\.)
            (?: ({{identifier}}) (\.)
              (?:
                ({{identifier}}) (\.)
              )?
            )?
          )?
          ((({{identifier}})))(?!\s*\.)
      captures:
        1: keyword.operator.new.es
        2: variable.other.readwrite.es
        3: keyword.operator.accessor.es
        4: variable.other.readwrite.es
        5: keyword.operator.accessor.es
        6: variable.other.readwrite.es
        7: keyword.operator.accessor.es
        8: variable.other.readwrite.es
        9: keyword.operator.accessor.es
        10: variable.other.readwrite.es
        11: meta.instance.constructor entity.name.type.new
        12: meta.instantiation.es
      set: ae_NO_IN_AFTER_THING
    - match: '(new)\s*(\.)'
      captures:
        1: variable.language.new-target.fake-object.es
        2: variable.language.new-target.fake-accessor.es
      set: ae_NO_IN_YIELD_NEW_AFTER_NEW_WAT
    - match: 'new{{idEnd}}'
      scope: keyword.operator.new.es
      set: ae_NO_IN_YIELD_NEW_AFTER_NEW_OPERATOR
    - match: 'yield{{idEnd}}'
      scope: keyword.control.flow.yield.es
      set: ae_NO_IN_YIELD_NEW_AFTER_YIELD
  ae_NO_IN_YIELD_NEW_AFTER_YIELD:
    - match: '\*'
      scope: keyword.control.flow.yield.iterate.es
      set: assignmentExpression_NO_IN
    - match: '$|(?=\})'
      pop: true
    - include: assignmentExpression_NO_IN_CORE
    - include: else_pop
  ae_NO_IN_YIELD_NEW_AFTER_NEW_OPERATOR:
    - match: '\.'
      scope: variable.language.new-target.fake-accessor.es
      set: ae_NO_IN_YIELD_NEW_AFTER_NEW_WAT
    - include: assignmentExpression_NO_IN
  ae_NO_IN_YIELD_NEW_AFTER_NEW_WAT:
    - match: 'target{{idEnd}}'
      scope: variable.language.new-target.fake-property.es
      set: ae_NO_IN_AFTER_THING
    - match: '{{MAT_word_or_any_one_char}}'
      scope: invalid.illegal.token.es
      set: ae_NO_IN_AFTER_ACCESSOR_OPERATOR

# END OF REPETITION
################################################################################
################################################################################
################################################################################
################################################################################

# OBJECT & ARRAY LITERALS ######################################################

  literalArray_OPEN:
    - match: '((\]))'
      captures:
        1: punctuation.definition.array.end.es
        2: meta.brace.square.js # ^BS
      pop: true
    - match: ','
      scope: punctuation.separator.array-element.es
    - match: '\.{3}'
      scope: keyword.operator.spread.es
      set: [ literalArray_AFTER_ELEMENT, assignmentExpression ]
    - match: '{{PLA_anything}}'
      set: [ literalArray_AFTER_ELEMENT, assignmentExpression ]

  literalArray_AFTER_ELEMENT:
    - match: '((\]))'
      captures:
        1: punctuation.definition.array.end.es
        2: meta.brace.square.js # ^BS
      pop: true
    - match: ','
      scope: punctuation.separator.array-element.es
      set: literalArray_OPEN
    - include: other_illegal

  literalObject_OPEN:
    - match: '((\}))'
      captures:
        1: punctuation.definition.object.end.es
        2: meta.brace.curly.js # ^BS
      pop: true
    # PREFIXED METHODS
    - match: '((\*))'
      captures:
        1: keyword.generator.asterisk.js # ^BS
        2: storage.modifier.generator.asterisk.method.es
      set: [ literalObject_AFTER_AE, generatorMethod_AFTER_ASTERISK ]
    - match: '((get))\s*((:))'
      captures:
        1: constant.other.object.key.js string.unquoted.label.js # ^BS
        2: variable.other.readwrite.property.object-literal.es
        3: constant.other.object.key.js # ^BS
        4: punctuation.separator.key-value.es
      set: [ literalObject_AFTER_AE, assignmentExpression ]
    - match: '((get)){{idEnd}}(?=\s+{{identifierStart}})'
      captures:
        1: storage.type.accessor.js # ^BS
        2: storage.modifier.accessor.get.es
      set: [ literalObject_AFTER_AE, accessorMethod_AFTER_GET ]
    - match: '((set))\s*((:))'
      captures:
        1: constant.other.object.key.js string.unquoted.label.js # ^BS
        2: variable.other.readwrite.property.object-literal.es
        3: constant.other.object.key.js # ^BS
        4: punctuation.separator.key-value.es
      set: [ literalObject_AFTER_AE, assignmentExpression ]
    - match: '((set)){{idEnd}}(?=\s+{{identifierStart}})'
      captures:
        1: storage.type.accessor.js # ^BS
        2: storage.modifier.accessor.set.es
      set: [ literalObject_AFTER_AE, accessorMethod_AFTER_SET ]
    - match: '((async)){{idEnd}}(?:((\s*\*))?|(?!\s*:))'
      captures:
        1: storage.type.js # ^BS
        2: storage.modifier.async.es
        3: keyword.generator.asterisk.js # ^BS
        4: storage.modifier.generator.asterisk.method.es
      set: [ literalObject_AFTER_AE, asyncMethod_AFTER_ASYNC ]
    # NORMAL METHODS
    - match: '(({{allThreeIDs}}))\s*(\()'
      captures:
        1: entity.name.method.js # ^BS -- monokai
        2: entity.name.method.es
        3: variable.other.readwrite.property.allCap.es
        4: variable.other.readwrite.property.initCap.es
        5: variable.other.readwrite.property.es
        6: punctuation.definition.parameters.method.begin.es
      set: [ literalObject_AFTER_AE, method_AFTER_PARAMS, parameters ]
    # NORMAL PROPERTIES
    - match: '({{allThreeIDs}})\s*((:))'
      captures:
        1: constant.other.object.key.js string.unquoted.label.js # ^BS
        2: variable.other.readwrite.property.object-literal.allCap.es
        3: variable.other.readwrite.property.object-literal.initCap.es
        4: variable.other.readwrite.property.object-literal.es
        5: constant.other.object.key.js # ^BS
        6: punctuation.separator.key-value.es
      set: [ literalObject_AFTER_AE, assignmentExpression ]
    # ACTUALLY DESTRUCTURING POSSIBLY!
    # We could be inside an ambiguous destructing sequence. This could be in
    # parameters or it might be an assignment. We simply cannot know. :(
    - match: '(?={{identifier}}\s*=)'
      set: bindingObject
    # IDENTIFIER REFERENCE (probably)
    # We match references (shorthand properties) last because we must rely on
    # other punctuation to identify ‘regular’ properties and methods.
    - match: '{{allThreeIDs}}'
      captures:
        1: variable.other.readwrite.property.shorthand.allCap.es # -BS
        2: variable.other.readwrite.property.shorthand.initCap.es
        3: variable.other.readwrite.property.shorthand.es
      set: literalObject_AFTER_SHORTHAND
    # NORMALLY ILLEGAL NAMED METHOD
    - match: '((({{identifierName}})))\s*(\()'
      captures:
        1: entity.name.method.js # ^BS -- monokai
        2: entity.name.method.es
        3: variable.other.readwrite.property.es
        4: punctuation.definition.parameters.method.begin.es
      set: [ literalObject_AFTER_AE, method_AFTER_PARAMS, parameters ]
    # NORMALLY ILLEGAL NAME
    - match: '(({{identifierName}}))'
      captures:
        1: constant.other.object.key.js string.unquoted.label.js # ^BS
        2: variable.other.readwrite.property.object-literal.es
      set: literalObject_AFTER_SHORTHAND
    # QUOTED PROPERTY
    - match: "'"
      scope: punctuation.definition.string.quoted.single.begin.es
      set: [ literalObject_AFTER_PROP, stringSingle_AFTER_OPEN ]
    - match: '"'
      scope: punctuation.definition.string.quoted.double.begin.es
      set: [ literalObject_AFTER_PROP, stringDouble_AFTER_OPEN ]
    # ES7?
    - match: '\.{3}'
      scope: keyword.operator.spread.es
      set: [ literalObject_AFTER_AE, assignmentExpression ]
    - match: '((@))'
      captures:
        1: punctuation.definition.tag.js # ^BS
        2: punctuation.definition.decorator.es
      push: decoratorExpression
    # NUMERIC PROPERTY
    - match: '({{binNum}})'
      scope: variable.other.readwrite.property.object-literal.es
      captures:
        1: constant.numeric.binary.es
        2: meta.numeric.prefix.es
        3: meta.numeric.suffix.es
      set: literalObject_AFTER_PROP
    - match: '({{octNum}})'
      scope: variable.other.readwrite.property.object-literal.es
      captures:
        1: constant.numeric.octal.es
        2: meta.numeric.prefix.es
        3: meta.numeric.suffix.es
      set: literalObject_AFTER_PROP
    - match: '({{hexNum}})'
      scope: variable.other.readwrite.property.object-literal.es
      captures:
        1: constant.numeric.hexadecimal.es
        2: meta.numeric.prefix.es
        3: meta.numeric.suffix.es
      set: literalObject_AFTER_PROP
    - match: '({{decNum}})'
      scope: variable.other.readwrite.property.object-literal.es
      captures:
        1: constant.numeric.decimal.es
        2: punctuation.decimal.es
        3: punctuation.decimal.es
        4: punctuation.decimal.es
        5: meta.numeric.exponent.e.es
        6: meta.numeric.exponent.sign.es
        7: meta.numeric.exponent.digit.es
        8: meta.numeric.suffix.es
      set: literalObject_AFTER_PROP
    # COMPUTED PROPERTY
    - match: '((\[))'
      captures:
        1: punctuation.definition.accessor.begin.es
        2: meta.brace.square.js # ^BS
      set: [ literalObject_AFTER_PROP, computedProp_AFTER_AE, assignmentExpression ]

  literalObject_AFTER_SHORTHAND:
    # Safety context for " prop \n : "
    - match: '((:))'
      captures:
        1: constant.other.object.key.js # ^BS
        2: punctuation.separator.key-value.es
      set: [ literalObject_AFTER_AE, assignmentExpression ]
    - match: '((\())'
      captures:
        1: punctuation.definition.parameters.method.begin.es
        2: meta.brace.round.js # ^BS
      set: [ literalObject_AFTER_AE, method_AFTER_PARAMS, parameters ]
    - include: literalObject_AFTER_AE

  literalObject_AFTER_PROP:
    - match: '((:))'
      captures:
        1: constant.other.object.key.js # ^BS
        2: punctuation.separator.key-value.es
      set: [ literalObject_AFTER_AE, assignmentExpression ]
    - match: '((\())'
      captures:
        1: punctuation.definition.parameters.method.begin.es
        2: meta.brace.round.js # ^BS
      set: [ literalObject_AFTER_AE, method_AFTER_PARAMS, parameters ]
    - include: other_illegal

  literalObject_AFTER_AE:
    - match: '((,))'
      captures:
        1: punctuation.separator.object-member.es
        2: meta.delimiter.comma.js # ^BS
      set: literalObject_OPEN
    - match: '{{PLA_anything}}'
      set: literalObject_OPEN

  computedProp_AFTER_AE:
    # Also used for property access
    - match: '((\]))'
      captures:
        1: punctuation.definition.accessor.end.es
        2: meta.brace.square.js # ^BS
      pop: true
    - include: other_illegal

# OBJECT & CLASS LITERAL METHODS ###############################################

  method_AFTER_NAME:
    - match: '((\())'
      captures:
        1: punctuation.definition.parameters.method.begin.es
        2: meta.brace.round.js # ^BS
      set: [ method_AFTER_PARAMS, parameters ]
    - include: other_illegal_pop

  method_AFTER_NAME_PRIVATE:
    - match: '((\())'
      captures:
        1: punctuation.definition.parameters.method.private.begin.es
        2: meta.brace.round.js # ^BS
      set: [ method_AFTER_PARAMS_PRIVATE, parameters ]
    - include: other_illegal_pop

  method_AFTER_NAME_PRIVATE_ASYNC:
    - match: '((\())'
      captures:
        1: punctuation.definition.parameters.method.private.async.begin.es
        2: meta.brace.round.js # ^BS
      set: [ method_AFTER_PARAMS_PRIVATE_ASYNC, parameters ]
    - include: other_illegal_pop

  method_AFTER_PARAMS:
    - match: '((\)))'
      captures:
        1: punctuation.definition.parameters.method.end.es
        2: meta.brace.round.js # ^BS
      set: method_BEFORE_BRACE
    - include: other_illegal

  method_AFTER_PARAMS_PRIVATE:
    - match: '((\)))'
      captures:
        1: punctuation.definition.parameters.method.private.end.es
        2: meta.brace.round.js # ^BS
      set: method_BEFORE_BRACE_PRIVATE
    - include: other_illegal

  method_AFTER_PARAMS_PRIVATE_ASYNC:
    - match: '((\)))'
      captures:
        1: punctuation.definition.parameters.method.private.async.end.es
        2: meta.brace.round.js # ^BS
      set: method_BEFORE_BRACE_PRIVATE_ASYNC
    - include: other_illegal

  method_BEFORE_BRACE:
    - match: '((\{))'
      captures:
        1: punctuation.definition.method.body.begin.es
        2: meta.brace.curly.js # ^BS
      set: method_AFTER_BRACE
    - include: other_illegal_pop

  method_BEFORE_BRACE_PRIVATE:
    - match: '((\{))'
      captures:
        1: punctuation.definition.method.private.body.begin.es
        2: meta.brace.curly.js # ^BS
      set: method_AFTER_BRACE_PRIVATE
    - include: other_illegal_pop

  method_BEFORE_BRACE_PRIVATE_ASYNC:
    - match: '((\{))'
      captures:
        1: punctuation.definition.method.private.async.body.begin.es
        2: meta.brace.curly.js # ^BS
      set: method_AFTER_BRACE_PRIVATE_ASYNC
    - include: other_illegal_pop

  method_AFTER_BRACE:
    - match: '((\}))'
      captures:
        1: punctuation.definition.method.body.end.es
        2: meta.brace.curly.js # ^BS
      pop: true
    - include: useStrict
    - include: statements

  method_AFTER_BRACE_PRIVATE:
    - match: '((\}))'
      captures:
        1: punctuation.definition.method.private.body.end.es
        2: meta.brace.curly.js # ^BS
      pop: true
    - include: useStrict
    - include: statements

  method_AFTER_BRACE_PRIVATE_ASYNC:
    - match: '((\}))'
      captures:
        1: punctuation.definition.method.private.async.body.end.es
        2: meta.brace.curly.js # ^BS
      pop: true
    - include: useStrict
    - include: statements

  asyncMethod_AFTER_ASYNC:
    - match: '(({{identifierName}}))'
      captures:
        1: entity.name.method.js # ^BS -- monokai
        2: entity.name.method.async.es
      set: asyncMethod_AFTER_NAME
    - match: '((#{{identifierName}}))'
      captures:
        1: entity.name.method.js # ^BS -- monokai
        2: entity.name.method.private.async.es
      set: method_AFTER_NAME_PRIVATE_ASYNC
    - match: "'"
      scope: punctuation.definition.string.quoted.single.begin.es
      set: [ asyncMethod_AFTER_NAME, stringSingle_AFTER_OPEN ]
    - match: '"'
      scope: punctuation.definition.string.quoted.double.begin.es
      set: [ asyncMethod_AFTER_NAME, stringDouble_AFTER_OPEN ]
    - match: '({{binNum}})'
      scope: entity.name.method.es
      captures:
        1: constant.numeric.binary.es
        2: meta.numeric.prefix.es
        3: meta.numeric.suffix.es
      set: asyncMethod_AFTER_NAME
    - match: '({{octNum}})'
      scope: entity.name.method.es
      captures:
        1: constant.numeric.octal.es
        2: meta.numeric.prefix.es
        3: meta.numeric.suffix.es
      set: asyncMethod_AFTER_NAME
    - match: '({{hexNum}})'
      scope: entity.name.method.es
      captures:
        1: constant.numeric.hexadecimal.es
        2: meta.numeric.prefix.es
        3: meta.numeric.suffix.es
      set: asyncMethod_AFTER_NAME
    - match: '({{decNum}})'
      scope: entity.name.method.es
      captures:
        1: constant.numeric.decimal.es
        2: punctuation.decimal.es
        3: punctuation.decimal.es
        4: punctuation.decimal.es
        5: meta.numeric.exponent.e.es
        6: meta.numeric.exponent.sign.es
        7: meta.numeric.exponent.digit.es
        8: meta.numeric.suffix.es
      set: asyncMethod_AFTER_NAME
    - match: '((\[))'
      captures:
        1: punctuation.definition.accessor.begin.es
        2: meta.brace.square.js # ^BS
      set: [ asyncMethod_AFTER_NAME, computedProp_AFTER_AE, assignmentExpression ]
    - include: other_illegal_pop

  asyncMethod_AFTER_NAME:
    - match: '((\())'
      captures:
        1: punctuation.definition.parameters.method.async.begin.es
        2: meta.brace.round.js # ^BS
      set: [ asyncMethod_AFTER_PARAMS, parameters ]
    - include: other_illegal_pop

  asyncMethod_AFTER_PARAMS:
    - match: '((\)))'
      captures:
        1: punctuation.definition.parameters.method.async.end.es
        2: meta.brace.round.js # ^BS
      set: asyncMethod_BEFORE_BRACE
    - include: other_illegal

  asyncMethod_BEFORE_BRACE:
    - match: '((\{))'
      captures:
        1: punctuation.definition.method.async.body.begin.es
        2: meta.brace.curly.js # ^BS
      set: asyncMethod_AFTER_BRACE
    - include: other_illegal_pop

  asyncMethod_AFTER_BRACE:
    - match: '((\}))'
      captures:
        1: punctuation.definition.method.async.body.end.es
        2: meta.brace.curly.js # ^BS
      pop: true
    - include: useStrict
    - include: statements

  accessorMethod_AFTER_GET:
    - match: '(({{identifierName}}))'
      captures:
        1: entity.name.method.js # ^BS -- monokai
        2: entity.name.accessor.get.es
      set: accessorMethod_AFTER_GET_NAME
    - match: "'"
      scope: punctuation.definition.string.quoted.single.begin.es
      set: [ accessorMethod_AFTER_GET_NAME, stringSingle_AFTER_OPEN ]
    - match: '"'
      scope: punctuation.definition.string.quoted.double.begin.es
      set: [ accessorMethod_AFTER_GET_NAME, stringDouble_AFTER_OPEN ]
    - match: '({{binNum}})'
      scope: constant.numeric.binary.es
      captures:
        1: entity.name.method.es
        2: meta.numeric.prefix.es
        3: meta.numeric.suffix.es
      set: accessorMethod_AFTER_GET_NAME
    - match: '({{octNum}})'
      scope: entity.name.method.es
      captures:
        1: constant.numeric.octal.es
        2: meta.numeric.prefix.es
        3: meta.numeric.suffix.es
      set: accessorMethod_AFTER_GET_NAME
    - match: '({{hexNum}})'
      scope: entity.name.method.es
      captures:
        1: constant.numeric.hexadecimal.es
        2: meta.numeric.prefix.es
        3: meta.numeric.suffix.es
      set: accessorMethod_AFTER_GET_NAME
    - match: '({{decNum}})'
      scope: entity.name.method.es
      captures:
        1: constant.numeric.decimal.es
        2: punctuation.decimal.es
        3: punctuation.decimal.es
        4: punctuation.decimal.es
        5: meta.numeric.exponent.e.es
        6: meta.numeric.exponent.sign.es
        7: meta.numeric.exponent.digit.es
        8: meta.numeric.suffix.es
      set: accessorMethod_AFTER_GET_NAME
    - match: '((\[))'
      captures:
        1: punctuation.definition.accessor.begin.es
        2: meta.brace.square.js # ^BS
      set: [ accessorMethod_AFTER_GET_NAME, computedProp_AFTER_AE, assignmentExpression ]
    # Possibly this is an object property.
    - include: other_illegal_pop

  accessorMethod_AFTER_GET_CLASS:
    - match: ((#{{identifierName}}))
      captures:
        1: entity.name.method.js # ^BS -- monokai
        2: entity.name.accessor.get.private.es
      set: accessorMethod_AFTER_GET_NAME_PRIVATE
    - include: accessorMethod_AFTER_GET

  accessorMethod_AFTER_GET_NAME:
    - match: '((\())'
      captures:
        1: punctuation.definition.parameters.accessor.begin.es
        2: meta.brace.round.js # ^BS
      set: accessorMethod_AFTER_GET_PAREN_OPEN
    - include: other_illegal_pop

  accessorMethod_AFTER_GET_NAME_PRIVATE:
    - match: '((\())'
      captures:
        1: punctuation.definition.parameters.accessor.private.begin.es
        2: meta.brace.round.js # ^BS
      set: accessorMethod_AFTER_GET_PAREN_OPEN_PRIVATE
    - include: other_illegal_pop

  accessorMethod_AFTER_GET_PAREN_OPEN:
    - match: '((\)))'
      captures:
        1: punctuation.definition.parameters.accessor.end.es
        2: meta.brace.round.js # ^BS
      set: accessorMethod_BEFORE_BRACE
    - include: other_illegal

  accessorMethod_AFTER_GET_PAREN_OPEN_PRIVATE:
    - match: '((\)))'
      captures:
        1: punctuation.definition.parameters.accessor.private.end.es
        2: meta.brace.round.js # ^BS
      set: accessorMethod_BEFORE_BRACE_PRIVATE
    - include: other_illegal

  accessorMethod_AFTER_SET:
    - match: '(({{identifierName}}))'
      captures:
        1: entity.name.method.js # ^BS -- monokai
        2: entity.name.accessor.set.es
      set: accessorMethod_AFTER_SET_NAME
    - match: "'"
      scope: punctuation.definition.string.quoted.single.begin.es
      set: [ accessorMethod_AFTER_SET_NAME, stringSingle_AFTER_OPEN ]
    - match: '"'
      scope: punctuation.definition.string.quoted.double.begin.es
      set: [ accessorMethod_AFTER_SET_NAME, stringDouble_AFTER_OPEN ]
    - match: '({{binNum}})'
      scope: constant.numeric.binary.es
      captures:
        1: entity.name.method.es
        2: meta.numeric.prefix.es
        3: meta.numeric.suffix.es
      set: accessorMethod_AFTER_SET_NAME
    - match: '({{octNum}})'
      scope: constant.numeric.octal.es
      captures:
        1: entity.name.method.es
        2: meta.numeric.prefix.es
        3: meta.numeric.suffix.es
      set: accessorMethod_AFTER_SET_NAME
    - match: '({{hexNum}})'
      scope: constant.numeric.hexadecimal.es
      captures:
        1: entity.name.method.es
        2: meta.numeric.prefix.es
        3: meta.numeric.suffix.es
      set: accessorMethod_AFTER_SET_NAME
    - match: '({{decNum}})'
      scope: constant.numeric.decimal.es
      captures:
        1: entity.name.method.es
        2: punctuation.decimal.es
        3: punctuation.decimal.es
        4: punctuation.decimal.es
        5: meta.numeric.exponent.e.es
        6: meta.numeric.exponent.sign.es
        7: meta.numeric.exponent.digit.es
        8: meta.numeric.suffix.es
      set: accessorMethod_AFTER_SET_NAME
    - match: '((\[))'
      captures:
        1: punctuation.definition.accessor.begin.es
        2: meta.brace.square.js # ^BS
      set: [ accessorMethod_AFTER_SET_NAME, computedProp_AFTER_AE, assignmentExpression ]
    - include: other_illegal_pop

  accessorMethod_AFTER_SET_CLASS:
    - match: ((#{{identifierName}}))
      captures:
        1: entity.name.method.js # ^BS -- monokai
        2: entity.name.accessor.set.private.es
      set: accessorMethod_AFTER_SET_NAME_PRIVATE
    - include: accessorMethod_AFTER_SET

  accessorMethod_AFTER_SET_NAME:
    - match: '((\())'
      captures:
        1: punctuation.definition.parameters.accessor.begin.es
        2: meta.brace.round.js # ^BS
      set: [ accessorMethod_AFTER_SET_PARAM, parameters ]
    - include: other_illegal_pop

  accessorMethod_AFTER_SET_NAME_PRIVATE:
    - match: '((\())'
      captures:
        1: punctuation.definition.parameters.accessor.private.begin.es
        2: meta.brace.round.js # ^BS
      set: [ accessorMethod_AFTER_SET_PARAM_PRIVATE, parameters ]
    - include: other_illegal_pop

  accessorMethod_AFTER_SET_PARAM:
    - match: '((\)))'
      captures:
        1: punctuation.definition.parameters.accessor.end.es
        2: meta.brace.round.js # ^BS
      set: accessorMethod_BEFORE_BRACE
    - include: other_illegal

  accessorMethod_AFTER_SET_PARAM_PRIVATE:
    - match: '((\)))'
      captures:
        1: punctuation.definition.parameters.accessor.private.end.es
        2: meta.brace.round.js # ^BS
      set: accessorMethod_BEFORE_BRACE_PRIVATE
    - include: other_illegal

  accessorMethod_BEFORE_BRACE:
    - match: '((\{))'
      captures:
        1: punctuation.definition.accessor.body.begin.es
        2: meta.brace.curly.js # ^BS
      set: accessorMethod_AFTER_BRACE
    - include: other_illegal_pop

  accessorMethod_BEFORE_BRACE_PRIVATE:
    - match: '((\{))'
      captures:
        1: punctuation.definition.accessor.private.body.begin.es
        2: meta.brace.curly.js # ^BS
      set: accessorMethod_AFTER_BRACE_PRIVATE
    - include: other_illegal_pop

  accessorMethod_AFTER_BRACE:
    - match: '((\}))'
      captures:
        1: punctuation.definition.accessor.body.end.es
        2: meta.brace.curly.js # ^BS
      pop: true
    - include: useStrict
    - match: '(return){{idEnd}}'
      scope: keyword.control.flow.return.accessor.es
      push: returnStatement
    - include: statements

  accessorMethod_AFTER_BRACE_PRIVATE:
    - match: '((\}))'
      captures:
        1: punctuation.definition.accessor.private.body.end.es
        2: meta.brace.curly.js # ^BS
      pop: true
    - include: useStrict
    - match: '(return){{idEnd}}'
      scope: keyword.control.flow.return.accessor.es
      push: returnStatement
    - include: statements

  generatorMethod_AFTER_ASTERISK:
    - match: '(({{identifierName}}))'
      captures:
        1: entity.name.method.js # ^BS -- monokai
        2: entity.name.method.generator.es
      set: generatorMethod_AFTER_NAME
    - match: "'"
      scope: punctuation.definition.string.quoted.single.begin.es
      set: [ generatorMethod_AFTER_NAME, stringSingle_AFTER_OPEN ]
    - match: '"'
      scope: punctuation.definition.string.quoted.double.begin.es
      set: [ generatorMethod_AFTER_NAME, stringDouble_AFTER_OPEN ]
    - match: '({{binNum}})'
      scope: constant.numeric.binary.es
      captures:
        1: entity.name.method.es
        2: meta.numeric.prefix.es
        3: meta.numeric.suffix.es
      set: generatorMethod_AFTER_NAME
    - match: '({{octNum}})'
      scope: constant.numeric.octal.es
      captures:
        1: entity.name.method.es
        2: meta.numeric.prefix.es
        3: meta.numeric.suffix.es
      set: generatorMethod_AFTER_NAME
    - match: '({{hexNum}})'
      scope: constant.numeric.hexadecimal.es
      captures:
        1: entity.name.method.es
        2: meta.numeric.prefix.es
        3: meta.numeric.suffix.es
      set: generatorMethod_AFTER_NAME
    - match: '({{decNum}})'
      scope: constant.numeric.decimal.es
      captures:
        1: entity.name.method.es
        2: punctuation.decimal.es
        3: punctuation.decimal.es
        4: punctuation.decimal.es
        5: meta.numeric.exponent.e.es
        6: meta.numeric.exponent.sign.es
        7: meta.numeric.exponent.digit.es
        8: meta.numeric.suffix.es
      set: generatorMethod_AFTER_NAME
    - match: '((\[))'
      captures:
        1: punctuation.definition.accessor.begin.es
        2: meta.brace.square.js # ^BS
      set: [ generatorMethod_AFTER_NAME, computedProp_AFTER_AE, assignmentExpression ]
    - include: other_illegal_pop

  generatorMethod_AFTER_ASTERISK_CLASS:
    - match: '((#{{identifierName}})){{idEnd}}'
      captures:
        1: entity.name.method.js # ^BS -- monokai
        2: entity.name.method.private.es
      set: [ classDeclaration_AFTER_BRACE, method_AFTER_NAME_PRIVATE ]
    - include: generatorMethod_AFTER_ASTERISK

  generatorMethod_AFTER_NAME:
    - match: '((\())'
      captures:
        1: punctuation.definition.parameters.method.generator.begin.es
        2: meta.brace.round.js # ^BS
      set: [ generatorMethod_AFTER_PARAMS, parameters ]
    - include: other_illegal_pop

  generatorMethod_AFTER_PARAMS:
    - match: '((\)))'
      captures:
        1: punctuation.definition.parameters.method.generator.end.es
        2: meta.brace.round.js # ^BS
      set: generatorMethod_BEFORE_BRACE
    - include: other_illegal

  generatorMethod_BEFORE_BRACE:
    - match: '((\{))'
      captures:
        1: punctuation.definition.method.generator.body.begin.es
        2: meta.brace.curly.js # ^BS
      set: generatorMethod_AFTER_BRACE
    - include: other_illegal_pop

  generatorMethod_AFTER_BRACE:
    - match: '((\}))'
      captures:
        1: punctuation.definition.method.generator.body.end.es
        2: meta.brace.curly.js # ^BS
      pop: true
    - include: useStrict
    - include: statements

  constructorMethod_AFTER_CONSTRUCTOR:
    - match: '((\())'
      captures:
        1: punctuation.definition.parameters.constructor.begin.es
        2: meta.brace.round.js # ^BS
      set: [ constructorMethod_AFTER_PARAMS, parameters ]
    - include: other_illegal_pop

  constructorMethod_AFTER_PARAMS:
    - match: '((\)))'
      captures:
        1: punctuation.definition.parameters.constructor.end.es
        2: meta.brace.round.js # ^BS
      set: constructorMethod_BEFORE_BRACE
    - include: other_illegal

  constructorMethod_BEFORE_BRACE:
    - match: '((\{))'
      captures:
        1: punctuation.definition.constructor.body.begin.es
        2: meta.brace.curly.js # ^BS
      set: constructorMethod_AFTER_BRACE
    - include: other_illegal_pop

  constructorMethod_AFTER_BRACE:
    - match: '((\}))'
      captures:
        1: punctuation.definition.constructor.body.end.es
        2: meta.brace.curly.js # ^BS
      pop: true
    - include: useStrict
    - include: statements

# BINDING PATTERNS #############################################################

  bindingArray:
    - match: '((\]))'
      captures:
        1: punctuation.definition.binding.array.end.es
        2: meta.brace.square.js # ^BS
      pop: true
    - match: '((,))'
      captures:
        1: punctuation.separator.array-element.binding.es
        2: meta.separator.comma.js # ^BS
    - match: '\.{3}'
      scope: keyword.other.rest.es # -BS
      set: bindingArray_AFTER_ELLIPSIS
    - match: '((\[))'
      captures:
        1: punctuation.definition.binding.array.begin.es
        2: meta.brace.square.js # ^BS
      set: [ bindingArray_AFTER_ELEM, bindingArray ]
    - match: '((\{))'
      captures:
        1: punctuation.definition.binding.object.begin.es
        2: meta.brace.curly.js # ^BS
      set: [ bindingArray_AFTER_ELEM, bindingObject ]
    # Actually must be an LHS, but we cannot readily describe that constraint:
    - match: '{{PLA_anything}}'
      set: [ bindingArray_AFTER_ELEM, assignmentExpression ]

  bindingArray_AFTER_ELEM:
    - match: '((\]))'
      captures:
        1: punctuation.definition.binding.array.end.es
        2: meta.brace.square.js # ^BS
      pop: true
    - match: '((,))'
      captures:
        1: punctuation.separator.array-element.binding.es
        2: meta.separator.comma.js # ^BS
      set: bindingArray
    - match: '='
      scope: keyword.operator.assignment.conditional.default.es
      push: assignmentExpression
    - include: other_illegal

  bindingArray_AFTER_ELLIPSIS:
    - match: '{{allThreeIDs}}'
      captures:
        1: variable.other.readwrite.allCap.es # -BS
        2: variable.other.readwrite.initCap.es
        3: variable.other.readwrite.es
      set: bindingArray_AFTER_REST_ELEM
    - match: '\]'
      scope: invalid.illegal.token.es
      pop: true

  bindingArray_AFTER_REST_ELEM:
    - match: '((\]))'
      captures:
        1: punctuation.definition.binding.array.end.es
        2: meta.brace.square.js # ^BS
      pop: true
    - include: other_illegal

  bindingObject:
    - match: '((\}))'
      captures:
        1: punctuation.definition.binding.object.end.es
        2: meta.brace.curly.js # ^BS
      pop: true
    # BOUND PROPERTY ASSIGNMENT, NORMAL PROPERTY STYLE
    - match: '(({{identifierName}}))\s*((:))'
      captures:
        1: constant.other.object.key.js string.unquoted.label.js # ^BS
        2: entity.other.property-binding.es
        3: constant.other.object.key.js # ^BS
        4: punctuation.separator.property-binding.es
      set: bindingObject_AFTER_PROPERTY
    # BOUND PROPERTY ASSIGNMENT, SAME-NAME SHORTHAND
    - match: '{{allThreeIDs}}'
      captures:
        1: variable.other.readwrite.allCap.es # -BS
        2: variable.other.readwrite.initCap.es
        3: variable.other.readwrite.es
      set: bindingObject_AFTER_ELEM
    # COMPUTED PROPERTY
    - match: '((\[))'
      captures:
        1: punctuation.definition.accessor.begin.es
        2: meta.brace.square.js # ^BS
      set: [ bindingObject_BEFORE_COLON, computedProp_AFTER_AE, assignmentExpression ]
    - match: "'"
      scope: punctuation.definition.string.quoted.single.begin.es
      set: [ bindingObject_BEFORE_COLON, stringSingle_AFTER_OPEN ]
    - match: '"'
      scope: punctuation.definition.string.quoted.double.begin.es
      set: [ bindingObject_BEFORE_COLON, stringDouble_AFTER_OPEN ]
    # REST PROPERTIES
    - match: '\.{3}'
      scope: keyword.other.rest.es # -BS
      set: bindingObject_AFTER_ELLIPSIS
    # NUMERIC PROPERTY
    - match: '({{binNum}})'
      scope: constant.numeric.binary.es
      captures:
        1: entity.other.property-binding.es
        2: meta.numeric.prefix.es
        3: meta.numeric.suffix.es
      set: bindingObject_BEFORE_COLON
    - match: '({{octNum}})'
      scope: constant.numeric.octal.es
      captures:
        1: entity.other.property-binding.es
        2: meta.numeric.prefix.es
        3: meta.numeric.suffix.es
      set: bindingObject_BEFORE_COLON
    - match: '({{hexNum}})'
      scope: constant.numeric.hexadecimal.es
      captures:
        1: entity.other.property-binding.es
        2: meta.numeric.prefix.es
        3: meta.numeric.suffix.es
      set: bindingObject_BEFORE_COLON
    - match: '({{decNum}})'
      scope: constant.numeric.decimal.es
      captures:
        1: entity.other.property-binding.es
        2: punctuation.decimal.es
        3: punctuation.decimal.es
        4: punctuation.decimal.es
        5: meta.numeric.exponent.e.es
        6: meta.numeric.exponent.sign.es
        7: meta.numeric.exponent.digit.es
        8: meta.numeric.suffix.es
      set: bindingObject_BEFORE_COLON
    - include: other_illegal

  bindingObject_BEFORE_COLON:
    - match: '((:))'
      captures:
        1: constant.other.object.key.js # ^BS, augmented
        2: punctuation.separator.property-binding.es
      set: bindingObject_AFTER_PROPERTY
    - match: '\}'
      scope: invalid.illegal.token.es
      pop: true
    - include: other_illegal

  bindingObject_AFTER_PROPERTY:
    - match: '((\[))'
      captures:
        1: punctuation.definition.binding.array.begin.es
        2: meta.brace.square.js # ^BS
      set: [ bindingObject_AFTER_ELEM, bindingArray ]
    - match: '((\{))'
      captures:
        1: punctuation.definition.binding.object.begin.es
        2: meta.brace.curly.js # ^BS
      set: [ bindingObject_AFTER_ELEM, bindingObject ]
    # Actually must be an LHS, but we cannot readily describe that constraint:
    - match: '{{PLA_anything}}'
      set: [ bindingObject_AFTER_ELEM, assignmentExpression ]

  bindingObject_AFTER_ELEM:
    - match: '((\}))'
      captures:
        1: punctuation.definition.binding.object.end.es
        2: meta.brace.curly.js # ^BS
      pop: true
    - match: '((,))'
      captures:
        1: punctuation.separator.object-member.binding.es
        2: meta.separator.comma.js # ^BS
      set: bindingObject
    - match: '='
      scope: keyword.operator.assignment.conditional.default.es
      push: assignmentExpression

  bindingObject_AFTER_ELLIPSIS:
    - match: '{{allThreeIDs}}'
      captures:
        1: variable.other.readwrite.allCap.es # -BS
        2: variable.other.readwrite.initCap.es
        3: variable.other.readwrite.es
      set: bindingObject_AFTER_REST_ELEM
    - match: '\}'
      scope: invalid.illegal.token.es
      pop: true
    - include: other_illegal

  bindingObject_AFTER_REST_ELEM:
    - match: '((\}))'
      captures:
        1: punctuation.definition.binding.object.end.es
        2: meta.brace.curly.js # ^BS
      pop: true
    - include: other_illegal

  bindingArray_PARAM:
    - match: '((\]))'
      captures:
        1: punctuation.definition.binding.array.parameter.end.es
        2: meta.brace.square.js # ^BS, augmented
      pop: true
    - match: '((,))'
      captures:
        1: punctuation.separator.array-element.binding.parameter.es
        2: meta.separator.comma.js # ^BS, augmented
    - match: '\.{3}'
      scope: keyword.other.rest.parameter.es # -BS
      set: bindingArray_PARAM_AFTER_ELLIPSIS
    - match: '{{identifier}}'
      scope: variable.parameter.es
      set: bindingArray_PARAM_AFTER_ELEM
    - match: '((\[))'
      captures:
        1: punctuation.definition.binding.array.parameter.begin.es
        2: meta.brace.square.js # ^BS, augmented
      set: [ bindingArray_PARAM_AFTER_ELEM, bindingArray_PARAM ]
    - match: '((\{))'
      captures:
        1: punctuation.definition.binding.object.parameter.begin.es
        2: meta.brace.curly.js # ^BS, augmented
      set: [ bindingArray_PARAM_AFTER_ELEM, bindingObject_PARAM ]
    - include: other_illegal

  bindingArray_PARAM_AFTER_ELEM:
    - match: '((\]))'
      captures:
        1: punctuation.definition.binding.array.parameter.end.es
        2: meta.brace.square.js # ^BS, augmented
      pop: true
    - match: '((,))'
      captures:
        1: punctuation.separator.array-element.binding.parameter.es
        2: meta.separator.comma.js # ^BS, augmented
      set: bindingArray_PARAM
    - match: '='
      scope: keyword.operator.assignment.conditional.default.es
      push: assignmentExpression
    - include: other_illegal

  bindingArray_PARAM_AFTER_ELLIPSIS:
    - match: '{{identifier}}'
      scope: variable.parameter.es
      set: bindingArray_PARAM_AFTER_REST_ELEM
    - match: '\]'
      scope: invalid.illegal.token.es
      pop: true

  bindingArray_PARAM_AFTER_REST_ELEM:
    - match: '((\]))'
      captures:
        1: punctuation.definition.binding.array.parameter.end.es
        2: meta.brace.square.js # ^BS, augmented
      pop: true
    - include: other_illegal

  bindingObject_PARAM:
    - match: '((\}))'
      captures:
        1: punctuation.definition.binding.object.parameter.end.es
        2: meta.brace.curly.js # ^BS, augmented
      pop: true
    # BOUND PROPERTY ASSIGNMENT, NORMAL PROPERTY STYLE
    - match: '(({{identifierName}}))\s*((:))'
      captures:
        1: constant.other.object.key.js string.unquoted.label.js # ^BS, augmented
        2: entity.other.property-binding.parameter.es
        3: constant.other.object.key.js # ^BS, augmented
        4: punctuation.separator.property-binding.parameter.es
      set: bindingObject_PARAM_AFTER_PROPERTY
    # BOUND PROPERTY ASSIGNMENT, SAME-NAME SHORTHAND
    - match: '{{identifier}}'
      scope: variable.parameter.es
      set: bindingObject_PARAM_AFTER_ELEM
    # COMPUTED PROPERTY
    - match: '((\[))'
      captures:
        1: punctuation.definition.accessor.begin.es
        2: meta.brace.square.js # ^BS, augmented
      set: [ bindingObject_PARAM_BEFORE_COLON, computedProp_AFTER_AE, assignmentExpression ]
    - match: "'"
      scope: punctuation.definition.string.quoted.single.parameter.begin.es
      set: [ bindingObject_PARAM_BEFORE_COLON, stringSingle_AFTER_OPEN ]
    - match: '"'
      scope: punctuation.definition.string.quoted.double.parameter.begin.es
      set: [ bindingObject_PARAM_BEFORE_COLON, stringDouble_AFTER_OPEN ]
    # REST PROPERTIES
    - match: '\.{3}'
      scope: keyword.other.rest.parameter.es # -BS
      set: bindingObject_PARAM_AFTER_ELLIPSIS
    # NUMERIC PROPERTY
    - match: '({{binNum}})'
      scope: constant.numeric.binary.es
      captures:
        1: entity.other.property-binding.parameter.es
        2: meta.numeric.prefix.es
        3: meta.numeric.suffix.es
      set: bindingObject_PARAM_BEFORE_COLON
    - match: '({{octNum}})'
      scope: constant.numeric.octal.es
      captures:
        1: entity.other.property-binding.parameter.es
        2: meta.numeric.prefix.es
        3: meta.numeric.suffix.es
      set: bindingObject_PARAM_BEFORE_COLON
    - match: '({{hexNum}})'
      scope: constant.numeric.hexadecimal.es
      captures:
        1: entity.other.property-binding.parameter.es
        2: meta.numeric.prefix.es
        3: meta.numeric.suffix.es
      set: bindingObject_PARAM_BEFORE_COLON
    - match: '({{decNum}})'
      scope: constant.numeric.decimal.es
      captures:
        1: entity.other.property-binding.parameter.es
        2: punctuation.decimal.es
        3: punctuation.decimal.es
        4: punctuation.decimal.es
        5: meta.numeric.exponent.e.es
        6: meta.numeric.exponent.sign.es
        7: meta.numeric.exponent.digit.es
        8: meta.numeric.suffix.es
      set: bindingObject_PARAM_BEFORE_COLON
    - include: other_illegal

  bindingObject_PARAM_BEFORE_COLON:
    - match: '((:))'
      captures:
        1: constant.other.object.key.js # ^BS, augmented
        2: punctuation.separator.property-binding.parameter.es
      set: bindingObject_PARAM_AFTER_PROPERTY
    - match: '\}'
      scope: invalid.illegal.token.es
      pop: true
    - include: other_illegal

  bindingObject_PARAM_AFTER_PROPERTY:
    - match: '{{identifier}}'
      scope: variable.parameter.es
      set: bindingObject_PARAM_AFTER_ELEM
    - match: '((\[))'
      captures:
        1: punctuation.definition.binding.array.parameter.begin.es
        2: meta.brace.square.js # ^BS, augmented
      set: [ bindingObject_PARAM_AFTER_ELEM, bindingArray_PARAM ]
    - match: '((\{))'
      captures:
        1: punctuation.definition.binding.object.parameter.begin.es
        2: meta.brace.curly.js # ^BS, augmented
      set: [ bindingObject_PARAM_AFTER_ELEM, bindingObject_PARAM ]
    - match: '{{MAT_word_or_any_one_char}}'
      scope: invalid.illegal.token.es
      set: bindingObject_PARAM_AFTER_ELEM

  bindingObject_PARAM_AFTER_ELEM:
    - match: '((\}))'
      captures:
        1: punctuation.definition.binding.object.parameter.end.es
        2: meta.brace.curly.js # ^BS, augmented
      pop: true
    - match: '((,))'
      captures:
        1: punctuation.separator.object-member.binding.parameter.es
        2: meta.delimiter.comma.js # ^BS, augmented
      set: bindingObject_PARAM
    - match: '='
      scope: keyword.operator.assignment.conditional.default.es
      push: assignmentExpression

  bindingObject_PARAM_AFTER_ELLIPSIS:
    - match: '{{identifier}}'
      scope: variable.parameter.es
      set: bindingObject_PARAM_AFTER_REST_ELEM
    - match: '\}'
      scope: invalid.illegal.token.es
      pop: true
    - include: other_illegal

  bindingObject_PARAM_AFTER_REST_ELEM:
    - match: '((\}))'
      captures:
        1: punctuation.definition.binding.object.parameter.end.es
        2: meta.brace.curly.js # ^BS, augmented
      pop: true
    - include: other_illegal

# PARAMETERS & ARGUMENTS #######################################################
# Note: Arguments is inclusive of its final delimiter. Parameters is not.

  arguments:
    - match: '((\)))'
      captures:
        1: punctuation.definition.arguments.end.es
        2: meta.brace.round.js # ^BS
      pop: true
    - match: ','
      scope: invalid.illegal.token.es
    - match: '\.{3}'
      scope: keyword.operator.spread.es
      set: [ arguments_AFTER_AE, assignmentExpression ]
    # PARTIAL APPLICATION PROPOSAL
    - match: '\?(?!\?|\.(?!\d))'
      scope: variable.language.partial-application.es
      set: arguments_AFTER_AE
    - match: '{{PLA_anything}}'
      set: [ arguments_AFTER_AE, assignmentExpression ]
    - include: other_illegal

  arguments_AFTER_AE:
    - match: '((\)))'
      captures:
        1: punctuation.definition.arguments.end.es
        2: meta.brace.round.js # ^BS
      pop: true
    - match: ','
      scope: punctuation.separator.argument.es
      set: arguments
    - include: other_illegal

  parameters:
    - match: '((\[))'
      captures:
        1: punctuation.definition.binding.array.parameter.begin.es
        2: meta.brace.square.js # ^ES, augmented
      set: [ parameters_AFTER_PARAM, bindingArray_PARAM ]
    - match: '((\{))'
      captures:
        1: punctuation.definition.binding.object.parameter.begin.es
        2: meta.brace.curly.js # ^ES, augmented
      set: [ parameters_AFTER_PARAM, bindingObject_PARAM ]
    - match: '{{identifier}}'
      scope: variable.parameter.es
      set: parameters_AFTER_PARAM
    - match: '\.{3}(?=\s*\))'
      scope: invalid.illegal.token.es
      pop: true
    - match: '\.{3}'
      scope: keyword.other.rest.parameter.es # -ES
      set: parameters_AFTER_ELLIPSIS
    - include: parameters_AFTER_REST_PARAM

  parameters_AFTER_PARAM:
    - match: ','
      scope: punctuation.separator.parameter.es
      set: parameters
    - match: '='
      scope: keyword.operator.assignment.conditional.default.es
      push: assignmentExpression
    - include: parameters_AFTER_REST_PARAM

  parameters_AFTER_ELLIPSIS:
    - match: '((\[))'
      captures:
        1: punctuation.definition.binding.array.parameter.begin.es
        2: meta.brace.square.js # ^BS
      set: [ parameters_AFTER_REST_PARAM, bindingArray_PARAM ]
    - match: '((\{))'
      captures:
        1: punctuation.definition.binding.object.parameter.begin.es
        2: meta.brace.curly.js # ^BS
      set: [ parameters_AFTER_REST_PARAM, bindingObject_PARAM ]
    - match: '{{identifier}}'
      scope: variable.parameter.rest.es
      set: parameters_AFTER_REST_PARAM
    - include: parameters_AFTER_REST_PARAM

  parameters_AFTER_REST_PARAM:
    - match: '(?=\))'
      pop: true
    - include: other_illegal

# STRINGS & REGEX ##############################################################

  regex_AFTER_OPEN:
    - meta_scope: string.regexp.es
    - meta_include_prototype: false
    # It’s okay to put this here; comments are always matched first.
    - include: regex_COMMON_NOT_IN_CLASS_SET

  regex_ANY_CHILD_CONTEXT:
    # Child contexts are tricky here because we need to be able to terminate
    # the parent context from anywhere. Since the conditions of termination are
    # simple enough, we can just include this lookahead in any child context.
    # The regex root context will then handle the ‘actual’ termination.
    - match: '(?=[\n\/])'
      pop: true

  regex_COMMON_NOT_IN_CLASS_SET:
    - include: regex_COMMON
    # DISJUNCTION
    - match: '\|'
      scope: keyword.operator.or.regexp
    # QUANTIFIERS
    - match: '[\?\*\+]|\{\d+\s*(?:,\s*\d*\s*)?\}'
      scope: keyword.operator.quantifier.regexp
    # CHARACTER CLASSES
    - match: '\['
      scope: punctuation.definition.character-class.begin.regexp
      push: regexp_AFTER_BRACKET
    # ASSERTIONS
    - match: '\(\?<?!'
      scope: punctuation.definition.assertion.negative.begin.regexp
      push: regex_AFTER_ASSERTION_NEGATIVE_OPEN
    - match: '\(\?<?='
      scope: punctuation.definition.assertion.positive.begin.regexp
      push: regex_AFTER_ASSERTION_POSITIVE_OPEN
    # GROUPS
    - match: '(\(\?<)({{identifierName}})(>)' # technically slightly off
      captures:
        1: punctuation.definition.group.capturing.begin.regexp
        2: variable.other.named-capture.regexp
        3: punctuation.definition.group.capturing.begin.regexp
      push: regex_AFTER_CAPTURE_OPEN
    - match: '\(\?:'
      scope: punctuation.definition.group.non-capturing.begin.regexp
      push: regex_AFTER_NON_CAPTURE_OPEN
    - match: '\('
      scope: punctuation.definition.group.capturing.begin.regexp
      push: regex_AFTER_CAPTURE_OPEN

  regex_COMMON:
    - match: '\/'
      scope: punctuation.definition.string.regexp.end.es
      set: regex_AFTER_PATTERN
    - match: '\n'
      scope: invalid.illegal.newline.es
      pop: true
    # ASSERTIONS
    - match: '\\[Bb]|[\$\^]'
      scope: keyword.control.anchor.regexp
    # CHARACTER CLASSES
    - match: '\.|\\[DdSsWw]'
      scope: constant.other.character-class.predefined.regexp
    # PROPERTY CLASSES
    - match: '\\[Pp]\{'
      scope: punctuation.definition.character-property.regexp.begin.es
      push:
        - - meta_scope: meta.character-property.regexp
          - match: '([A-Za-z_]+)(=)([A-Za-z\d]+)'
            captures:
              1: constant.other.character-class.unicode-property-name.regexp
              2: punctuation.separator.character-property-name-value.regexp
              3: constant.other.character-class.unicode-property-value.regexp
            set:
              - - meta_scope: meta.character-property.regexp
                - match: '\}'
                  scope: punctuation.definition.character-property.regexp.end.es
                  pop: true
                - include: other_illegal_pop
          - match: '[A-Za-z_\d]+'
            scope: constant.other.character-class.unicode-property-value.regexp
            set:
              - - meta_scope: meta.character-property.regexp
                - match: '\}'
                  scope: punctuation.definition.character-property.regexp.end.es
                  pop: true
                - include: other_illegal_pop
          - match: '\}'
            scope: invalid.illegal.token
            pop: true
          - include: other_illegal_pop
    # BACKREFERENCE
    - match: '\\k<({{identifierName}})>'
      scope: keyword.other.back-reference.regexp
      captures:
        1: variable.other.named-capture.regexp
    - match: '\\[1-9]\d*'
      scope: keyword.other.back-reference.regexp
    # ESCAPES
    - match: '\\(c[A-Za-z]|[tnvfr])'
      scope: constant.character.escape.control-char.regexp
    - match: '\\x\h\h'
      scope: constant.character.escape.hexadecimal.regexp
    - match: '\\0(?!\d)'
      scope: constant.character.escape.null.regexp
    - match: '{{unicodeEscape}}'
      scope: constant.character.escape.unicode.regexp
    - match: '\\\/'
      scope: constant.character.escape.regexp
    - match: '\\.'
      scope: constant.character.escape.pointless.regexp

  regexp_AFTER_BRACKET:
    - meta_scope: constant.other.character-class.set.regexp
    - meta_include_prototype: false
    - match: '(?<=\[)\^'
      scope: keyword.operator.negation.regexp
    - match: '(?<!\[\^|\[)-(?!\])'
      scope: punctuation.definition.character-class.dash.regexp
    - match: '\]'
      scope: punctuation.definition.character-class.end.regexp
      pop: true
    - match: '[/$.^]'
    - include: regex_ANY_CHILD_CONTEXT
    - include: regex_COMMON

  regex_AFTER_ASSERTION_NEGATIVE_OPEN:
    - meta_scope: meta.group.assertion.negative.regexp
    - meta_include_prototype: false
    - match: '\)'
      scope: punctuation.definition.assertion.negative.end.regexp
      pop: true
    - include: regex_ANY_CHILD_CONTEXT
    - include: regex_COMMON_NOT_IN_CLASS_SET

  regex_AFTER_ASSERTION_POSITIVE_OPEN:
    - meta_scope: meta.group.assertion.positive.regexp
    - meta_include_prototype: false
    - match: '\)'
      scope: punctuation.definition.assertion.positive.end.regexp
      pop: true
    - include: regex_ANY_CHILD_CONTEXT
    - include: regex_COMMON_NOT_IN_CLASS_SET

  regex_AFTER_NON_CAPTURE_OPEN:
    - meta_scope: meta.group.non-capturing.regexp
    - meta_include_prototype: false
    - match: '\)'
      scope: punctuation.definition.group.non-capturing.end.regexp
      pop: true
    - include: regex_ANY_CHILD_CONTEXT
    - include: regex_COMMON_NOT_IN_CLASS_SET

  regex_AFTER_CAPTURE_OPEN:
    - meta_scope: meta.group.capturing.regexp
    - meta_include_prototype: false
    - match: '\)'
      scope: punctuation.definition.group.capturing.end.regexp
      pop: true
    - include: regex_ANY_CHILD_CONTEXT
    - include: regex_COMMON_NOT_IN_CLASS_SET

  regex_AFTER_PATTERN:
    - meta_include_prototype: false
    - match: >-
        (?x) ((
          ([gimsyu])
          (?:
            (?!\3) ([gimsyu])
            (?:
              (?!\3|\4) ([gimsyu])
              (?:
                (?!\3|\4|\5) ([gimsyu])
                (?:
                  (?!\3|\4|\5|\6) ([gimsyu])
                  (
                    (?!\3|\4|\5|\6\7) ([gimsyu])
                  )?
                )?
              )?
            )?
          )?
          ))
          {{idEnd}}
      captures:
        1: string.regexp.js keyword.other.js # ^BS
        2: string.regexp.flags.es
      set: else_pop
    - match: '\w+'
      scope: invalid.illegal.token
      pop: true
    - include: else_pop

  stringDouble_AFTER_OPEN:
    - meta_scope: string.quoted.double.es
    - meta_include_prototype: false
    - match: '\\"'
      scope: constant.character.escape.es
    - match: '"'
      scope: punctuation.definition.string.quoted.double.end.es
      pop: true
    - include: string_COMMON_QUOTED

  stringSingle_AFTER_OPEN:
    - meta_scope: string.quoted.single.es
    - meta_include_prototype: false
    - match: '\\'''
      scope: constant.character.escape.es
    - match: "'"
      scope: punctuation.definition.string.quoted.single.end.es
      pop: true
    - include: string_COMMON_QUOTED

  templateString_AFTER_OPEN:
    - meta_scope: string.interpolated.es # -BS (throughout, exceptions noted)
    - meta_include_prototype: false
    - match: '\\[`\$\{]'
      scope: constant.character.escape.es
    - match: '\\\n'
      scope: constant.character.escape.pointless.es
    - include: string_COMMON_ESCAPES
    - match: '`'
      scope: punctuation.definition.string.interpolated.end.es
      pop: true
    - match: '((\$\{))'
      captures:
        1: entity.quasi.element.js punctuation.quasi.element.begin.js # ^BS
        2: punctuation.definition.string.interpolated.element.begin.es
      set: [ templateString_ELEMENT, expression ]

  templateString_ELEMENT:
    - match: '((\}))'
      captures:
        1: entity.quasi.element.js punctuation.quasi.element.end.js # ^BS
        2: punctuation.definition.string.interpolated.element.end.es
      set: templateString_AFTER_OPEN
    - include: other_illegal_pop

  string_COMMON_QUOTED:
    - include: string_COMMON_ESCAPES
    - match: '\\\n'
      scope: constant.character.escape.newline.es
    - match: '\n'
      scope: invalid.illegal.newline.es
      pop: true

  string_COMMON_ESCAPES:
    - match: '\\[\\bfnrtv]'
      scope: constant.character.escape.es
    - match: '{{unicodeEscape}}'
      scope: constant.character.escape.unicode.es
    - match: '\\x\h\h'
      scope: constant.character.escape.hexadecimal.es
    - match: '\\(?:[1-7][0-7]{0,2}|[0-7]{2,3})'
      scope: invalid.illegal.octal-escape.es
    - match: '\\0'
      scope: constant.character.escape.null.es
    - match: '\\.'
      scope: constant.character.escape.pointless.es

  useStrict:
    - match: '(('')use strict(''))'
      scope: string.quoted.single.es
      captures:
        1: meta.directive.use-strict.es
        2: punctuation.definition.string.quoted.single.begin.es
        3: punctuation.definition.string.quoted.single.end.es
    - match: '((")use strict("))'
      scope: string.quoted.double.es
      captures:
        1: meta.directive.use-strict.es
        2: punctuation.definition.string.quoted.double.begin.es
        3: punctuation.definition.string.quoted.double.end.es

# JSX EXTENSIONS ###############################################################

  ae_JSX:
    - match: '<>'
      scope: punctuation.definition.tag.fragment.begin.jsx
      set: [ ae_AFTER_THING, ae_JSX_FRAGMENT_END, ae_JSX_CONTENT ]
    - match: '<'
      scope: punctuation.definition.tag.begin.jsx
      set: [ ae_AFTER_THING, ae_JSX_ELEMENT ]

  ae_JSX_ATTRIBUTES:
    - match: '\{'
      scope: punctuation.definition.interpolation.begin.jsx
      push: [ ae_JSX_INTERPOLATION_END, ae_JSX_INTERPOLATION_SPREAD ]
    - match: '{{jsxElementIdentifier}}'
      scope: variable.other.attribute.jsx
      push: ae_JSX_ATTRIBUTES_VALUE
    - match: '/>'
      scope: punctuation.definition.tag.end.jsx
      pop: true
    - match: '>'
      scope: punctuation.definition.tag.end.jsx
      set: [ ae_JSX_ELEMENT_CLOSE, ae_JSX_CONTENT ]
    - include: other_illegal

  ae_JSX_ATTRIBUTES_STYLE:
    - match: 'jsx{{idEnd}}'
      scope: variable.other.attribute.jsx
      set: [ ae_JSX_ATTRIBUTES_STYLED_JSX, ae_JSX_ATTRIBUTES_VALUE ]
    - include: ae_JSX_ATTRIBUTES

  ae_JSX_ATTRIBUTES_STYLED_JSX:
    - match: '>'
      scope: punctuation.definition.tag.end.jsx
      set: [ ae_JSX_ELEMENT_CLOSE, ae_JSX_CONTENT_STYLED_JSX ]
    - include: ae_JSX_ATTRIBUTES

  ae_JSX_ATTRIBUTES_VALUE:
    - match: '='
      scope: punctuation.separator.attribute-value.jsx
      set:
        - - match: '"'
            scope: punctuation.definition.attribute.begin.jsx
            set:
              - - meta_include_prototype: false
                - meta_scope: string.attribute.jsx
                - match: '"'
                  scope: punctuation.definition.attribute.end.jsx
                  pop: true
          - match: ''''
            scope: punctuation.definition.attribute.begin.jsx
            set:
              - - meta_include_prototype: false
                - meta_scope: string.attribute.jsx
                - match: ''''
                  scope: punctuation.definition.attribute.end.jsx
                  pop: true
          - match: '\{'
            scope: punctuation.definition.interpolation.begin.jsx
            set: [ ae_JSX_INTERPOLATION_END, ae_JSX_INTERPOLATION ]
          - include: other_illegal
    - include: else_pop

  ae_JSX_CONTENT:
    - meta_include_prototype: false
    - match: '&[^&;\{\}<>\s]+;'
      scope: variable.other.entity-reference.jsx
    - match: '[^\{\}<>]'
      scope: string.text.jsx
    - match: '\{'
      scope: punctuation.definition.interpolation.begin.jsx
      push: [ ae_JSX_INTERPOLATION_END, ae_JSX_INTERPOLATION ]
    - match: '<(?!\/)'
      scope: punctuation.definition.tag.begin.jsx
      push: ae_JSX_ELEMENT
    - include: else_pop

  ae_JSX_CONTENT_STYLED_JSX:
    - meta_include_prototype: false
    - match: '\{'
      scope: punctuation.definition.interpolation.begin.jsx
      push:
        - - meta_scope: meta.interpolation.jsx
          - include: ae_JSX_INTERPOLATION_END
        - - match: '`'
            scope: string.interpolated.es punctuation.definition.string.interpolated.begin.es
            set: ae_CSS_STRING
          - include: ae_JSX_INTERPOLATION
    - include: ae_JSX_CONTENT

  ae_JSX_ELEMENT:
    - match: '{{jsxNamespaceIdentifier}}'
      scope: meta.namespace.jsx
      captures:
        1: entity.name.class.jsx
        2: keyword.operator.accessor.jsx
      set: [ ae_JSX_ATTRIBUTES, ae_JSX_ELEMENT_MEMBER ]
    - match: '{{jsxComponentIdentifier}}'
      scope: entity.name.class.jsx
      set: [ ae_JSX_ATTRIBUTES ]
    - match: 'style{{idEnd}}'
      scope: entity.name.tag.jsx
      set: [ ae_JSX_ATTRIBUTES_STYLE ]
    - match: '{{jsxElementIdentifier}}'
      scope: entity.name.tag.jsx
      set: [ ae_JSX_ATTRIBUTES ]
    - include: other_illegal

  ae_JSX_ELEMENT_CLOSE:
    - match: '</'
      scope: punctuation.definition.tag.begin.jsx
      set:
        - - match: '>'
            scope: punctuation.definition.tag.end.jsx
            pop: true
          - include: other_illegal
        - - match: '{{jsxNamespaceIdentifier}}'
            scope: meta.namespace.jsx
            captures:
              1: entity.name.class.jsx
              2: keyword.operator.accessor.jsx
            set:
              - - match: '{{jsxNamespaceIdentifier}}'
                  scope: meta.namespace.jsx
                  captures:
                    1: entity.name.class.jsx
                    2: keyword.operator.accessor.jsx
                - match: '{{jsxComponentIdentifier}}'
                  scope: entity.name.class.jsx
                  pop: true
                - include: other_illegal
          - match: '{{jsxComponentIdentifier}}'
            scope: entity.name.class.jsx
            pop: true
          - match: '{{jsxElementIdentifier}}'
            scope: entity.name.tag.jsx
            pop: true
          - include: other_illegal
    - include: other_illegal

  ae_JSX_ELEMENT_MEMBER:
    - match: '{{jsxNamespaceIdentifier}}'
      scope: meta.namespace.jsx
      captures:
        1: entity.name.class.jsx
        2: keyword.operator.accessor.jsx
    - match: '{{jsxComponentIdentifier}}'
      scope: entity.name.class.jsx
      pop: true
    - include: other_illegal

  ae_JSX_FRAGMENT_END:
    - match: '</>'
      scope: punctuation.definition.tag.fragment.end.jsx
      pop: true
    - include: other_illegal

  ae_JSX_INTERPOLATION:
    - meta_scope: meta.interpolation.jsx
    - match: '(?=\})'
      pop: true
    - match: '{{PLA_anything}}'
      set: assignmentExpression

  ae_JSX_INTERPOLATION_END:
    - meta_scope: meta.interpolation.jsx
    - match: '\}'
      scope: punctuation.definition.interpolation.end.jsx
      pop: true
    - include: other_illegal

  ae_JSX_INTERPOLATION_SPREAD:
    - meta_scope: meta.interpolation.jsx
    - match: '\.{3}'
      scope: keyword.operator.spread.jsx
      set: assignmentExpression
    - include: other_illegal

# TAGGED TEMPLATE STRING LITERAL SYNTAX EXTENSIONS #############################
#
# Each embedded syntax requires its own set of 2 contexts. The first one simply
# provides a meta scope for the breadth of the template literal so that we can
# highlight it properly (e.g., with a different background-color / font-style).
# This gets pushed to the stack before the 'OPEN' context and immediately pops
# when that context ends (triggered by template-ending punctuation lookahead).
#
# The 'OPEN' context matches the template-starting punctuation and then
# pushes the nested syntax, injecting our own rules that match the enclosing
# template string by using `with_prototype`. When an interpolation sequence is
# found, our agnostic context 'ELEMENT' is pushed to the stack, behind the usual
# 'expression' context. The 'ELEMENT' context is necessary becuase rather than
# using `set` the way 'templateString_ELEMENT' does, it needs to pop so that the
# parent syntax scope remains in the stack.
#
# The following contexts are general helper contexts for any of the syntax-
# specific contexts:

  syntax_OPEN:
    - match: '{{syntaxDirective}}'
      captures:
        1: meta.comment.border.es
        2: punctuation.definition.comment.begin.es
        3: meta.directive.syntax.keyword.es
      set: [ ae_AFTER_VALUE, syntax_EXIT, syntax_DIRECTIVE ]
    - include: block_comment

  syntax_NO_IN_OPEN:
    - match: '{{syntaxDirective}}'
      captures:
        1: meta.comment.border.es
        2: punctuation.definition.comment.begin.es
        3: meta.directive.syntax.keyword.es
      set: [ ae_NO_IN_AFTER_VALUE, syntax_EXIT, syntax_DIRECTIVE ]
    - include: block_comment

  syntax_AFTER_OPEN:
    - meta_include_prototype: false
    - match: '(?=`)'
      pop: true
    - match: '\\[`\$\{]'
      scope: constant.character.escape.es
    - match: '\\\n'
      scope: constant.character.escape.es
    - include: string_COMMON_ESCAPES
    - match: '((\$\{))'
      scope: meta.interpolation.interpolated.es
      captures:
        1: entity.quasi.element.js punctuation.quasi.element.begin.js # ^BS
        2: punctuation.definition.string.interpolated.element.begin.es
      push:
        - - meta_include_prototype: false
          - meta_content_scope: meta.interpolation.interpolated.es
          - match: '{{PLA_anything}}'
            pop: true
        - - include: syntax_ELEMENT
        - - include: expression

  # this context is used when the nested syntax either is, or is capable of nesting, `source.js`.
  #   it handles proper escaping within the nested string so that "backslash backtick" can be
  #   consumed by the `source.js.nested.es` syntax
  syntax_AFTER_OPEN_NESTS_JS:
    - meta_include_prototype: false
    - match: '(?=`)'
      pop: true
    - match: '\\\n'
      scope: constant.character.escape.es
    - match: '\\[bfnrtv]'
      scope: constant.character.escape.es meta.interpolation.interpolated.es
    - match: '\\\\(?=[^\\]|\\[^`\$])'
      scope: constant.character.escape.es meta.interpolation.interpolated.es
    - match: '{{unicodeEscape}}'
      scope: constant.character.escape.unicode.es
    - match: '\\x\h\h'
      scope: constant.character.escape.hexadecimal.es
    - match: '\\(?:[1-7][0-7]{0,2}|[0-7]{2,3})'
      scope: invalid.illegal.octal-escape.es
    - match: '\\0'
      scope: constant.character.escape.null.es
    # - match: '\\.'
    #   scope: constant.character.escape.pointless.es
    - match: '((\$\{))'
      scope: meta.interpolation.interpolated.es
      captures:
        1: entity.quasi.element.js punctuation.quasi.element.begin.js # ^BS
        2: punctuation.definition.string.interpolated.element.begin.es
      push:
        - - meta_include_prototype: false
          - meta_content_scope: meta.interpolation.interpolated.es
          - match: '{{PLA_anything}}'
            pop: true
        - - include: syntax_ELEMENT
        - - include: expression

  syntax_ELEMENT:
    - match: '((\}))'
      captures:
        1: entity.quasi.element.js punctuation.quasi.element.end.js # ^BS
        2: punctuation.definition.string.interpolated.element.end.es
      pop: true
    - include: other_illegal_pop

  syntax_EXIT:
    - meta_include_prototype: false
    - match: '`'
      scope: string.interpolated.es punctuation.definition.string.interpolated.end.es
      pop: true

  syntax_DIRECTIVE:
    - meta_scope: comment.block.es
    - meta_include_prototype: false
    - match: '{{syntaxDirective_CSS}}'
      captures:
        1: meta.directive.syntax.language.es
        2: meta.directive.syntax.context.es
        3: punctuation.definition.comment.end.es
        4: entity.quasi.tag.name.js # ^BS
        5: variable.other.readwrite.tag.es
      set: [ syntax_meta_CSS, syntax_CSS_OPEN ]
    - match: '{{syntaxDirective_CSS_STYLE}}'
      captures:
        1: meta.directive.syntax.language.es
        2: meta.directive.syntax.context.es
        3: punctuation.definition.comment.end.es
        4: entity.quasi.tag.name.js # ^BS
        5: variable.other.readwrite.tag.es
      set: [ syntax_meta_CSS, syntax_CSS_RULE_LIST_BODY_OPEN ]
    - match: '{{syntaxDirective_DOT}}'
      captures:
        1: meta.directive.syntax.language.es
        2: meta.directive.syntax.context.es
        3: punctuation.definition.comment.end.es
        4: entity.quasi.tag.name.js # ^BS
        5: variable.other.readwrite.tag.es
      set: [ syntax_meta_DOT, syntax_DOT_OPEN ]
    - match: '{{syntaxDirective_GLSL}}'
      captures:
        1: meta.directive.syntax.language.es
        2: meta.directive.syntax.context.es
        3: punctuation.definition.comment.end.es
        4: entity.quasi.tag.name.js # ^BS
        5: variable.other.readwrite.tag.es
      set: [ syntax_meta_GLSL, syntax_GLSL_OPEN ]
    - match: '{{syntaxDirective_HTML}}'
      captures:
        1: meta.directive.syntax.language.es
        2: meta.directive.syntax.context.es
        3: punctuation.definition.comment.end.es
        4: entity.quasi.tag.name.js # ^BS
        5: variable.other.readwrite.tag.es
      set: [ syntax_meta_HTML, syntax_HTML_OPEN ]
    - match: '{{syntaxDirective_JS}}'
      captures:
        1: meta.directive.syntax.language.es
        2: meta.directive.syntax.context.es
        3: punctuation.definition.comment.end.es
        4: entity.quasi.tag.name.js # ^BS
        5: variable.other.readwrite.tag.es
      set: [ syntax_meta_JS, syntax_JS_OPEN ]
    - match: '{{syntaxDirective_JS_VALUE}}'
      captures:
        1: meta.directive.syntax.language.es
        2: meta.directive.syntax.context.es
        3: punctuation.definition.comment.end.es
        4: entity.quasi.tag.name.js # ^BS
        5: variable.other.readwrite.tag.es
      set: [ syntax_meta_JS, syntax_JS_VALUE_OPEN ]
    - match: '{{syntaxDirective_JS_METHOD}}'
      captures:
        1: meta.directive.syntax.language.es
        2: meta.directive.syntax.context.es
        3: punctuation.definition.comment.end.es
        4: entity.quasi.tag.name.js # ^BS
        5: variable.other.readwrite.tag.es
      set: [ syntax_meta_JS, syntax_JS_METHOD_OPEN ]
    - match: '{{syntaxDirective_JS_REGEXP}}'
      captures:
        1: meta.directive.syntax.language.es
        2: meta.directive.syntax.context.es
        3: punctuation.definition.comment.end.es
        4: entity.quasi.tag.name.js # ^BS
        5: variable.other.readwrite.tag.es
      set: [ syntax_meta_JS, syntax_JS_REGEXP_OPEN ]
    - match: '{{syntaxDirective_JS_OBJECT_LITERAL}}'
      captures:
        1: meta.directive.syntax.language.es
        2: meta.directive.syntax.context.es
        3: punctuation.definition.comment.end.es
        4: entity.quasi.tag.name.js # ^BS
        5: variable.other.readwrite.tag.es
      set: [ syntax_meta_JS, syntax_JS_OBJECT_LITERAL_OPEN ]
    - match: '{{syntaxDirective_JS_SIMPLE}}'
      captures:
        1: meta.directive.syntax.language.es
        2: meta.directive.syntax.context.es
        3: punctuation.definition.comment.end.es
        4: entity.quasi.tag.name.js # ^BS
        5: variable.other.readwrite.tag.es
      set: [ syntax_meta_JS, syntax_JS_SIMPLE_OPEN ]
    - match: '{{syntaxDirective_JSON}}'
      captures:
        1: meta.directive.syntax.language.es
        2: meta.directive.syntax.context.es
        3: punctuation.definition.comment.end.es
        4: entity.quasi.tag.name.js # ^BS
        5: variable.other.readwrite.tag.es
      set: [ syntax_meta_JSON, syntax_JSON_OPEN ]
    - match: '{{syntaxDirective_LUA}}'
      captures:
        1: meta.directive.syntax.language.es
        2: meta.directive.syntax.context.es
        3: punctuation.definition.comment.end.es
        4: entity.quasi.tag.name.js # ^BS
        5: variable.other.readwrite.tag.es
      set: [ syntax_meta_LUA, syntax_LUA_OPEN ]
    - match: '{{syntaxDirective_MARKDOWN}}'
      captures:
        1: meta.directive.syntax.language.es
        2: meta.directive.syntax.context.es
        3: punctuation.definition.comment.end.es
        4: entity.quasi.tag.name.js # ^BS
        5: variable.other.readwrite.tag.es
      set: [ syntax_meta_MARKDOWN, syntax_MARKDOWN_OPEN ]
    - match: '{{syntaxDirective_SHELL}}'
      captures:
        1: meta.directive.syntax.language.es
        2: meta.directive.syntax.context.es
        3: punctuation.definition.comment.end.es
        4: entity.quasi.tag.name.js # ^BS
        5: variable.other.readwrite.tag.es
      set: [ syntax_meta_SHELL, syntax_SHELL_OPEN ]
    - match: '{{syntaxDirective_SQL}}'
      captures:
        1: meta.directive.syntax.language.es
        2: meta.directive.syntax.context.es
        3: punctuation.definition.comment.end.es
        4: entity.quasi.tag.name.js # ^BS
        5: variable.other.readwrite.tag.es
      set: [ syntax_meta_SQL, syntax_SQL_OPEN ]
    - match: '{{syntaxDirective_SUBLIME_SYNTAX}}'
      captures:
        1: meta.directive.syntax.language.es
        2: meta.directive.syntax.context.es
        3: punctuation.definition.comment.end.es
        4: entity.quasi.tag.name.js # ^BS
        5: variable.other.readwrite.tag.es
      set: [ syntax_meta_SUBLIME_SYNTAX, syntax_SUBLIME_SYNTAX_OPEN ]
    - match: '{{syntaxDirective_SUBLIME_SYNTAX_CONTEXT}}'
      captures:
        1: meta.directive.syntax.language.es
        2: meta.directive.syntax.context.es
        3: punctuation.definition.comment.end.es
        4: entity.quasi.tag.name.js # ^BS
        5: variable.other.readwrite.tag.es
      set: [ syntax_meta_SUBLIME_SYNTAX, syntax_SUBLIME_SYNTAX_CONTEXT_OPEN ]
    - match: '{{syntaxDirective_SUBLIME_SYNTAX_REGEX}}'
      captures:
        1: meta.directive.syntax.language.es
        2: meta.directive.syntax.context.es
        3: punctuation.definition.comment.end.es
        4: entity.quasi.tag.name.js # ^BS
        5: variable.other.readwrite.tag.es
      set: [ syntax_meta_SUBLIME_SYNTAX, syntax_SUBLIME_SYNTAX_REGEX_OPEN ]
    - match: '{{syntaxDirective_XML}}'
      captures:
        1: meta.directive.syntax.language.es
        2: meta.directive.syntax.context.es
        3: punctuation.definition.comment.end.es
        4: entity.quasi.tag.name.js # ^BS
        5: variable.other.readwrite.tag.es
      set: [ syntax_meta_XML, syntax_XML_OPEN ]
    - match: '{{syntaxDirective_YAML}}'
      captures:
        1: meta.directive.syntax.language.es
        2: meta.directive.syntax.context.es
        3: punctuation.definition.comment.end.es
        4: entity.quasi.tag.name.js # ^BS
        5: variable.other.readwrite.tag.es
      set: [ syntax_meta_YAML, syntax_YAML_OPEN ]

# CSS SYNTAX ###################################################################

  syntax_meta_CSS:
    - meta_content_scope: meta.interpolation.syntax.css
    - meta_include_prototype: false
    - match: '{{PLA_anything}}'
      pop: true

  syntax_CSS_OPEN:
    - meta_include_prototype: false
    - match: '`'
      scope: string.interpolated.es punctuation.definition.string.interpolated.begin.es
      set: scope:source.css
      with_prototype:
        - include: syntax_AFTER_OPEN

  syntax_CSS_RULE_LIST_BODY_OPEN:
    - meta_include_prototype: false
    - match: '`'
      scope: string.interpolated.es punctuation.definition.string.interpolated.begin.es
      set: scope:source.css#rule-list-body
      with_prototype:
        - include: syntax_AFTER_OPEN

# IMPROVED CSS SYNTAX ##########################################################
#
# Templated CSS, like all templated langs, is tricky to provide highlighting
# for because of ‘resuming’ after interpolation. I originally tried delegating
# to the CSS syntax definition, but this doesn’t work so great because in
# typical usage, one will be embedding expressions in Styled JSX strings for
# style-related constants — numeric values, colors, etc. Each time we exited and
# returned to the CSS literal portions, it’s starting from a blank slate, so the
# CSS highlighting ends up fairly unpredictable. Also notable is that the core
# CSS definition has some bugs at the time of writing that come up frequently in
# modern codebases — in particular, paren matching for nested var() function
# tokens fails, and the syntax uses a keyword whitelist that does not cover all
# of CSS.
#
# Since there’s no constraint on what might be interpolated — it could be
# values or portions of values, rule names, selectors, or any arbitrary chunk —
# and because the nature of what is included thusly is opaque to us, our best
# bet is to spin off very simple CSS highlighting rules that provide a few
# basics without having contextual awareness. In other words, we restrict the
# matches to very fuzzy heuristics for lexical tokens. It’s enough to improve
# the usage experience while avoiding stuff that could potentially lead to bad
# highlighting. It’s unsophisticated, but it is spiritually consistent with how
# the CSS grammar really works: at the base level, it really is just lexical
# token lists + brace matching, which is why the same root grammar works for
# productions other than stylesheets: style attributes, query selectors,
# CSSStyleRule.prototype.selectorText = "...", etc., which tend to come up often
# in ES usage.
#
# This section predates the generalized /*syntax:directive*/ pattern that was
# introduced later by blake. It was originally specific to supporting StyledJSX.
# However it is now also used for any template tag named ‘css’, so it enhances
# highlighting for source that uses lit-html and other similar libraries by
# default. Using the /*syntax:css*/ comment directive opts into the built-in CSS
# syntax definition instead, so both solutions are available.

  ae_CSS_STRING:
    - meta_content_scope: source.css meta.interpolation.syntax.css
    - meta_include_prototype: false
    - match: '\/\*'
      scope: punctuation.definition.comment.css
      push:
        - - meta_scope: comment.block.css
          - match: '\*\/'
            scope: punctuation.definition.comment.css
            pop: true
          # gonna just assume people don’t interpolate in the middle of comments
    - match: '@[\w\-]+'
      scope: keyword.control.at-rule.css
    - match: '#[\w\-]+'
      scope: entity.other.attribute-name.id.css
    - match: '\.[\w\-]+'
      scope: entity.other.attribute-name.class.css
    - match: '::[\w\-]+'
      scope: entity.other.pseudo-element.css
    - match: ':global\('
      scope: meta.styled-jsx.global.jsx
      push:
        - - match: '\)'
            scope: meta.styled-jsx.global.jsx
            pop: true
          - include: ae_CSS_STRING
    - match: ':[\w\-]+'
      scope: entity.other.pseudo-class.css
    - match: '--[\w\-]+'
      scope: support.type.custom-property.name.css
    - match: '[\w\-]+(?=\s*:)'
      scope: meta.property-name.css
    - match: 'url\('
      scope: meta.function-call.css
      push:
        - - match: '\)'
            scope: meta.function-call.css
            pop: true
          - match: '(?:"[^"]*"|''[^'']*'')'
            scope: string.quoted.css
          - match: '(?!`|\$\{|\/\*).'
            scope: string.unquoted.css
          - include: ae_CSS_STRING
    - match: '(?:[\w\-]*\(|[\(\)])'
      scope: meta.function-call.css
    - match: '(?:cm|deg|e[mx]|g(?:ra)?d|k?Hz|in|m[ms]|p[ctx]|r(?:ad|em)|s|turn|v[hmw]|%)(?!\w)'
      scope: keyword.other.unit.css
    - match: '(?!-?\d)[\w\-]+'
      scope: meta.property-value.css # will also include much more
    - match: ':'
      scope: punctuation.separator.key-value.css
    - match: ';'
      scope: punctuation.terminator.rule.css
    - match: '[+>~,\-\/\*]'
      scope: punctuation.separator.combinator.css
    - match: '[{}]'
      scope: punctuation.section.property-list.css
    - match: '(?:[\[\]]|[~\|\^\$\*]?=|i\])'
      scope: keyword.operator.attribute-selector.css
    - match: '\-?[\d\.]*\d[\d\.]*'
      scope: constant.numeric.css
    - match: '(?:"[^"]*"|''[^'']*'')'
      scope: string.quoted.css
    - match: '\\[`\$\{]'
      scope: constant.character.escape.es
    - match: '\\\n'
      scope: constant.character.escape.pointless.es
    - include: string_COMMON_ESCAPES
    - match: '`'
      scope: string.interpolated.es punctuation.definition.string.interpolated.end.es
      pop: true
    - match: '((\$\{))'
      captures:
        1: entity.quasi.element.js punctuation.quasi.element.begin.js # ^BS
        2: punctuation.definition.string.interpolated.element.begin.es
      push:
        - - match: '((\}))'
            captures:
              1: entity.quasi.element.js punctuation.quasi.element.end.js # ^BS
              2: punctuation.definition.string.interpolated.element.end.es
            pop: true
          - include: other_illegal_pop
        - - include: expression

# DOT (GRAPHVIZ) SYNTAX ########################################################

  syntax_meta_DOT:
    - meta_content_scope: meta.interpolation.syntax.dot
    - meta_include_prototype: false
    - match: '{{PLA_anything}}'
      pop: true

  syntax_DOT_OPEN:
    - meta_include_prototype: false
    - match: '`'
      scope: string.interpolated.es punctuation.definition.string.interpolated.begin.es
      set: scope:source.dot.nested.es
      with_prototype:
        - include: syntax_AFTER_OPEN

# GLSL SYNTAX ###################################################################

  syntax_meta_GLSL:
    - meta_content_scope: meta.interpolation.syntax.glsl
    - meta_include_prototype: false
    - match: '{{PLA_anything}}'
      pop: true

  syntax_GLSL_OPEN:
    - meta_include_prototype: false
    - match: '`'
      scope: string.interpolated.es punctuation.definition.string.interpolated.begin.es
      set: scope:source.glsl
      with_prototype:
        - include: syntax_AFTER_OPEN

# HTML SYNTAX ##################################################################

  syntax_meta_HTML:
    - meta_content_scope: meta.interpolation.syntax.html
    - meta_include_prototype: false
    - match: '{{PLA_anything}}'
      pop: true

  syntax_HTML_OPEN:
    - meta_include_prototype: false
    - match: '`'
      scope: string.interpolated.es punctuation.definition.string.interpolated.begin.es
      set: scope:text.html.basic.nested.es
      with_prototype:
        - include: syntax_AFTER_OPEN_NESTS_JS

# JS (JAVASCRIPT) SYNTAX #######################################################

  syntax_meta_JS:
    - meta_content_scope: meta.interpolation.syntax.js
    - meta_include_prototype: false
    - match: '{{PLA_anything}}'
      pop: true

  syntax_JS_OPEN:
    - meta_include_prototype: false
    - match: '`'
      scope: string.interpolated.es punctuation.definition.string.interpolated.begin.es
      set: scope:source.js.nested.es
      with_prototype:
        - include: syntax_AFTER_OPEN_NESTS_JS

  syntax_JS_VALUE_OPEN:
    - meta_include_prototype: false
    - match: '`'
      scope: string.interpolated.es punctuation.definition.string.interpolated.begin.es
      set: scope:source.js.nested.es#assignmentExpression_CORE
      with_prototype:
        - include: syntax_AFTER_OPEN_NESTS_JS

  syntax_JS_METHOD_OPEN:
    - meta_include_prototype: false
    - match: '`'
      scope: string.interpolated.es punctuation.definition.string.interpolated.begin.es
      set: scope:source.js.nested.es#classDeclaration_AFTER_BRACE
      with_prototype:
        - include: syntax_AFTER_OPEN_NESTS_JS

  syntax_JS_REGEXP_OPEN:
    - meta_include_prototype: false
    - match: '`'
      scope: string.interpolated.es punctuation.definition.string.interpolated.begin.es
      set: scope:source.js.nested.es#regex_AFTER_OPEN
      with_prototype:
        - include: syntax_AFTER_OPEN_NESTS_JS

  syntax_JS_OBJECT_LITERAL_OPEN:
    - meta_include_prototype: false
    - match: '`'
      scope: string.interpolated.es punctuation.definition.string.interpolated.begin.es
      set: scope:source.js.nested.es#literalObject_OPEN
      with_prototype:
        - include: syntax_AFTER_OPEN_NESTS_JS

  syntax_JS_SIMPLE_OPEN:
    - meta_include_prototype: false
    - match: '`'
      scope: string.interpolated.es punctuation.definition.string.interpolated.begin.es
      set: Packages/JavaScript/JavaScript.sublime-syntax
      with_prototype:
        # We must also compete with the 'tagged-template' rule in the default
        # JavaScript.sublime-syntax so that we can pop out
        - match: '([_$\p{L}\p{Nl}][_$\p{L}\p{Nl}\p{Mn}\p{Mc}\p{Nd}\p{Pc}\x{200C}\x{200D}]*)(?=\s*`)'
          captures:
            1: variable.other.readwrite.es
            2: string.interpolated.es punctuation.definition.string.interpolated.end.es
          pop: true
        - include: syntax_AFTER_OPEN_NESTS_JS

# JSON SYNTAX ##################################################################

  syntax_meta_JSON:
    - meta_content_scope: meta.interpolation.syntax.json
    - meta_include_prototype: false
    - match: '{{PLA_anything}}'
      pop: true

  syntax_JSON_OPEN:
    - meta_include_prototype: false
    - match: '`'
      scope: string.interpolated.es punctuation.definition.string.interpolated.begin.es
      set: scope:source.json
      with_prototype:
        - include: syntax_AFTER_OPEN

# LUA SYNTAX ###################################################################

  syntax_meta_LUA:
    - meta_content_scope: meta.interpolation.syntax.lua
    - meta_include_prototype: false
    - match: '{{PLA_anything}}'
      pop: true

  syntax_LUA_OPEN:
    - meta_include_prototype: false
    - match: '`'
      scope: string.interpolated.es punctuation.definition.string.interpolated.begin.es
      set: scope:source.lua
      with_prototype:
        - include: syntax_AFTER_OPEN

# MARKDOWN SYNTAX ##############################################################

  syntax_meta_MARKDOWN:
    - meta_content_scope: meta.interpolation.syntax.md
    - meta_include_prototype: false
    - match: '{{PLA_anything}}'
      pop: true

  syntax_MARKDOWN_OPEN:
    - meta_include_prototype: false
    - match: '`'
      scope: string.interpolated.es punctuation.definition.string.interpolated.begin.es
      set: scope:text.html.markdown.nested.es
      with_prototype:
        - include: syntax_AFTER_OPEN

# SHELL (BASH) SYNTAX ##########################################################

  syntax_meta_SHELL:
    - meta_content_scope: meta.interpolation.syntax.shell
    - meta_include_prototype: false
    - match: '{{PLA_anything}}'
      pop: true

  syntax_SHELL_OPEN:
    - meta_include_prototype: false
    - match: '`'
      scope: string.interpolated.es punctuation.definition.string.interpolated.begin.es
      set: scope:source.shell
      with_prototype:
        - include: syntax_AFTER_OPEN

# SQL SYNTAX ###################################################################

  syntax_meta_SQL:
    - meta_content_scope: meta.interpolation.syntax.sql
    - meta_include_prototype: false
    - match: '{{PLA_anything}}'
      pop: true

  syntax_SQL_OPEN:
    - meta_include_prototype: false
    - match: '`'
      scope: string.interpolated.es punctuation.definition.string.interpolated.begin.es
      set: scope:source.sql
      with_prototype:
        - include: syntax_AFTER_OPEN

# SUBLIME-SYNTAX SYNTAX ########################################################

  syntax_meta_SUBLIME_SYNTAX:
    - meta_content_scope: meta.interpolation.syntax.sublime-syntax
    - meta_include_prototype: false
    - match: '{{PLA_anything}}'
      pop: true

  syntax_SUBLIME_SYNTAX_OPEN:
    - meta_include_prototype: false
    - match: '`'
      scope: string.interpolated.es punctuation.definition.string.interpolated.begin.es
      set: scope:source.yaml.sublime.syntax.nested.es
      with_prototype:
        - include: syntax_AFTER_OPEN

  syntax_SUBLIME_SYNTAX_CONTEXT_OPEN:
    - meta_include_prototype: false
    - match: '`'
      scope: string.interpolated.es punctuation.definition.string.interpolated.begin.es
      set: scope:source.yaml.sublime.syntax.nested.es#contexts_block
      with_prototype:
        - include: syntax_AFTER_OPEN

  syntax_SUBLIME_SYNTAX_REGEX_OPEN:
    - meta_include_prototype: false
    - match: '`'
      scope: string.interpolated.es punctuation.definition.string.interpolated.begin.es
      set: scope:source.yaml.sublime.syntax.nested.es#expect_regexp
      with_prototype:
        - include: syntax_AFTER_OPEN

# XML SYNTAX ###################################################################

  syntax_meta_XML:
    - meta_content_scope: meta.interpolation.syntax.xml
    - meta_include_prototype: false
    - match: '{{PLA_anything}}'
      pop: true

  syntax_XML_OPEN:
    - meta_include_prototype: false
    - match: '`'
      scope: string.interpolated.es punctuation.definition.string.interpolated.begin.es
      set: scope:text.xml
      with_prototype:
        - include: syntax_AFTER_OPEN

# YAML SYNTAX ##################################################################

  syntax_meta_YAML:
    - meta_content_scope: meta.interpolation.syntax.yaml
    - meta_include_prototype: false
    - match: '{{PLA_anything}}'
      pop: true

  syntax_YAML_OPEN:
    - meta_include_prototype: false
    - match: '`'
      scope: string.interpolated.es punctuation.definition.string.interpolated.begin.es
      set: scope:source.yaml
      with_prototype:
        - include: syntax_AFTER_OPEN
